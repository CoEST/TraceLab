creat a new swing gui public swing gui dim dim string titl super titl thi dim dim init dim set gui callback thi 
return the menubar of thi debugg frame public menubar get menubar return menubar 
set the link runnabl that will be run when the exit menu item is chosen public void set exit action runnabl r exit action r 
return the debugg consol compon public jsintern consol get consol return consol 
set the visibl of the debugg gui public void set visibl boolean b super set visibl b if b thi need to be done after the window is visibl consol consol text area request focu context split set divid locat 0 5 try consol set maximum true consol set select true consol show consol consol text area request focu catch except exc 
record a new intern frame void add top level string kei jframe frame if frame thi toplevel put kei frame 
construct the debugg gui privat void init menubar new menubar thi set jmenu bar menubar tool bar new jtool bar jbutton button jbutton break button go button step into button step over button step out button string tool tip break paus go f5 step into f11 step over f7 step out f8 int count 0 button break button new jbutton break jbutton focu button button button set tool tip text break button set action command break button add action listen menubar button set enabl true button set tool tip text tool tip count button go button new jbutton go button set tool tip text go button set action command go button add action listen menubar button set enabl fals button set tool tip text tool tip count button step into button new jbutton step into button set tool tip text step into button set action command step into button add action listen menubar button set enabl fals button set tool tip text tool tip count button step over button new jbutton step over button set tool tip text step over button set action command step over button set enabl fals button add action listen menubar button set tool tip text tool tip count button step out button new jbutton step out button set tool tip text step out button set action command step out button set enabl fals button add action listen menubar button set tool tip text tool tip count dimens dim step over button get prefer size break button set prefer size dim break button set minimum size dim break button set maximum size dim break button set size dim go button set prefer size dim go button set minimum size dim go button set maximum size dim step into button set prefer size dim step into button set minimum size dim step into button set maximum size dim step over button set prefer size dim step over button set minimum size dim step over button set maximum size dim step out button set prefer size dim step out button set minimum size dim step out button set maximum size dim tool bar add break button tool bar add go button tool bar add step into button tool bar add step over button tool bar add step out button jpanel content pane new jpanel content pane set layout new border layout get content pane add tool bar border layout north get content pane add content pane border layout center desk new jdesktop pane desk set prefer size new dimens 600 300 desk set minimum size new dimens 150 50 desk add consol new jsintern consol java script consol context new context window thi context set prefer size new dimens 600 120 context set minimum size new dimens 50 50 split1 new jsplit pane jsplit pane vertic split desk context split1 set on touch expand true swing gui set resiz weight split1 0 66 content pane add split1 border layout center statu bar new jlabel statu bar set text thread content pane add statu bar border layout south dlg new jfile chooser javax swing filechoos file filter filter new javax swing filechoos file filter public boolean accept file f if f is directori return true string n f get name int i n last index of if i 0 i n length 1 string ext n substr i 1 to lower case if ext equal js return true return fals public string get descript return java script file js dlg add choosabl file filter filter add window listen new window adapt public void window close window event e exit 
new javax swing filechoos file filter public boolean accept file f if f is directori return true string n f get name int i n last index of if i 0 i n length 1 string ext n substr i 1 to lower case if ext equal js return true return fals 
public string get descript return java script file js 
dlg add choosabl file filter filter add window listen new window adapt public void window close window event e exit 
run the link exit action privat void exit if exit action null swing util invok later exit action dim set return valu dim exit 
return the link file window for the given url file window get file window string url if url null url equal stdin return null return file window file window get url 
return a short version of the given url static string get short name string url int last slash url last index of if last slash 0 last slash url last index of string short name url if last slash 0 last slash 1 url length short name url substr last slash 1 return short name 
close the given link file window void remov window file window w file window remov w get url jmenu window menu get window menu int count window menu get item count jmenu item last item window menu get item count 1 string name get short name w get url for int i 5 i count i jmenu item item window menu get item i if item null continu separ string text item get text 1 d foo js 2 d bar js int po text index of if text substr po 1 equal name window menu remov item cascad 0 tile 1 2 consol 3 4 if count 6 remov the final separ window menu remov 4 els int j i 4 for i count 1 i jmenu item thi item window menu get item i if thi item null 1 d foo js 2 d bar js text thi item get text if text equal more window break els po text index of thi item set text char 0 j text substr po 1 thi item set mnemon 0 j j if count 6 0 last item item if last item get text equal more window window menu remov last item break window menu revalid 
show the line at which execut in the given stack frame just stop void show stop line dim stack frame frame string sourc name frame get url if sourc name null sourc name equal stdin if consol is visibl consol show els int line number frame get line number file window w get file window sourc name if w null set file posit w line number els dim sourc info si frame sourc info creat file window si line number 
creat and show a new link file window for the given sourc void creat file window dim sourc info sourc info int line boolean activ true string url sourc info url file window w new file window thi sourc info file window put url w if line 1 if current window null current window set posit 1 try w set posit w text area get line start offset line 1 catch bad locat except exc try w set posit w text area get line start offset 0 catch bad locat except ee w set posit 1 desk add w if line 1 current window w menubar add file url w set visibl true if activ try w set maximum true w set select true w move to front catch except exc 
move the current posit in the given link file window to the given line privat void set file posit file window w int line boolean activ true jtext area ta w text area try if line 1 w set posit 1 if current window w current window null els int loc ta get line start offset line 1 if current window null current window w current window set posit 1 w set posit loc current window w catch bad locat except exc fix me if activ if w is icon desk get desktop manag deiconifi frame w desk get desktop manag activ frame w try w show w to front requir for correct frame layer jdk 1 4 1 w set select true catch except exc 
handl script interrupt void enter interrupt impl dim stack frame last frame string thread titl string alert messag statu bar set text thread thread titl show stop line last frame if alert messag null messag dialog wrapper show messag dialog thi alert messag except in script joption pane error messag updat enabl true dim context data context data last frame context data jcombo box ctx context context vector tool tip context tool tip context disabl updat int frame count context data frame count ctx remov all item workaround for jdk 1 4 bug that cach select valu even after remov all item is call ctx set select item null tool tip remov all element for int i 0 i frame count i dim stack frame frame context data get frame i string url frame get url int line number frame get line number string short name url if url length 20 short name url substr url length 17 string locat short name line line number ctx insert item at locat i locat url line line number tool tip add element locat context enabl updat ctx set select index 0 ctx set minimum size new dimens 50 ctx get minimum size height 
return the window menu privat jmenu get window menu return menubar get menu 3 
displai a link jfile chooser and return the select filenam privat string choos file string titl dlg set dialog titl titl file cwd null string dir system get properti user dir if dir null cwd new file dir if cwd null dlg set current directori cwd int return val dlg show open dialog thi if return val jfile chooser approv option try string result dlg get select file get canon path cwd dlg get select file get parent file properti prop system get properti prop put user dir cwd get path system set properti prop return result catch ioexcept ignor catch secur except ignor return null 
return the current select intern frame privat jintern frame get select frame jintern frame frame desk get all frame for int i 0 i frame length i if frame i is show return frame i return frame frame length 1 
enabl or disabl the menu and tool bar with respect to the state of script execut privat void updat enabl boolean interrupt menubar get jmenu bar updat enabl interrupt for int ci 0 cc tool bar get compon count ci cc ci boolean enabl button if ci 0 break enabl button interrupt els enabl button interrupt tool bar get compon ci set enabl enabl button if interrupt tool bar set enabl true rais the debugg window int state get extend state if state frame iconifi set extend state frame normal to front context enabl els if current window null current window set posit 1 context disabl 
call link jsplit pane set resiz weight via reflect for compat sinc jdk lt 1 3 doe not have thi method static void set resiz weight jsplit pane pane doubl weight try method m jsplit pane class get method set resiz weight new class doubl class m invok pane new object new doubl weight catch no such method except exc catch illeg access except exc catch java lang reflect invoc target except exc 
read the file with the given name and return it content as a string privat string read file string file name string text try reader r new file reader file name try text kit read reader r final r close catch ioexcept ex messag dialog wrapper show messag dialog thi ex get messag error read file name joption pane error messag text null return text 
call when the sourc text for a script ha been updat public void updat sourc text dim sourc info sourc info run proxi proxi new run proxi thi run proxi updat sourc text proxi sourc info sourc info swing util invok later proxi 
call when the interrupt loop ha been enter public void enter interrupt dim stack frame last frame string thread titl string alert messag if swing util is event dispatch thread enter interrupt impl last frame thread titl alert messag els run proxi proxi new run proxi thi run proxi enter interrupt proxi last frame last frame proxi thread titl thread titl proxi alert messag alert messag swing util invok later proxi 
return whether the current thread is the gui event thread public boolean is gui event thread return swing util is event dispatch thread 
process the next gui event public void dispatch next gui event throw interrupt except event queue queue awt event queue if queue null queue toolkit get default toolkit get system event queue awt event queue queue awtev event queue get next event if event instanceof activ event activ event event dispatch els object sourc event get sourc if sourc instanceof compon compon comp compon sourc comp dispatch event event els if sourc instanceof menu compon menu compon sourc dispatch event event 
perform an action from the menu or toolbar public void action perform action event e string cmd e get action command int return valu 1 if cmd equal cut cmd equal copi cmd equal past jintern frame f get select frame if f null f instanceof action listen action listen f action perform e els if cmd equal step over return valu dim step over els if cmd equal step into return valu dim step into els if cmd equal step out return valu dim step out els if cmd equal go return valu dim go els if cmd equal break dim set break els if cmd equal exit exit els if cmd equal open string file name choos file select a file to compil if file name null string text read file file name if text null run proxi proxi new run proxi thi run proxi open file proxi file name file name proxi text text new thread proxi start els if cmd equal load string file name choos file select a file to execut if file name null string text read file file name if text null run proxi proxi new run proxi thi run proxi load file proxi file name file name proxi text text new thread proxi start els if cmd equal more window more window dlg new more window thi file window window file dlg show dialog thi els if cmd equal consol if consol is icon desk get desktop manag deiconifi frame consol consol show desk get desktop manag activ frame consol consol consol text area request focu els if cmd equal cut els if cmd equal copi els if cmd equal past els if cmd equal go to function find function dlg new find function thi go to function function dlg show dialog thi els if cmd equal tile jintern frame frame desk get all frame int count frame length int row col row col int math sqrt count if row col count col if row col count row dimens size desk get size int w size width col int h size height row int x 0 int y 0 for int i 0 i row i for int j 0 j col j int index i col j if index frame length break jintern frame f frame index try f set icon fals f set maximum fals catch except exc desk get desktop manag set bound for frame f x y w h x w y h x 0 els if cmd equal cascad jintern frame frame desk get all frame int count frame length int x y w h x y 0 h desk get height int d h count if d 30 d 30 for int i count 1 i 0 i x d y d jintern frame f frame i try f set icon fals f set maximum fals catch except exc dimens dimen f get prefer size w dimen width h dimen height desk get desktop manag set bound for frame f x y w h els object obj get file window cmd if obj null file window w file window obj try if w is icon w set icon fals w set visibl true w move to front w set select true catch except exc if return valu 1 updat enabl fals dim set return valu return valu 
show a messag dialog wrap the code msg code at 60 column public static void show messag dialog compon parent string msg string titl int flag if msg length 60 string buffer buf new string buffer int len msg length int j 0 int i for i 0 i len i j char c msg char at i buf append c if charact is whitespac c int remaind len i int k for k i 1 k len k if charact is whitespac msg char at k break if k len int next word len k i if j next word len 60 buf append n j 0 msg buf to string joption pane show messag dialog parent msg titl flag 
creat a new eval text area public eval text area swing gui debug gui thi debug gui debug gui histori new java util vector document doc get document doc add document listen thi add kei listen thi set line wrap true set font new font monospac 0 12 append output mark doc get length 
select a subrang of the text public void select int start int end request focu super select start end 
call when enter is press privat synchron void return press document doc get document int len doc get length segment segment new segment try doc get text output mark len output mark segment catch javax swing text bad locat except ignor ignor print stack trace string text segment to string if debug gui dim string is compil unit text if text trim length 0 histori add element text histori index histori size append n string result debug gui dim eval text if result length 0 append result append n append output mark doc get length els append n 
write output into the text area public synchron void write string str insert str output mark int len str length output mark len select output mark output mark 
call when a kei is press public void kei press kei event e int code e get kei code if code kei event vk back space code kei event vk left if output mark get caret posit e consum els if code kei event vk home int caret po get caret posit if caret po output mark e consum els if caret po output mark if e is control down if e is shift down move caret posit output mark els set caret posit output mark e consum els if code kei event vk enter return press e consum els if code kei event vk up histori index if histori index 0 if histori index histori size histori index histori size 1 if histori index 0 string str string histori element at histori index int len get document get length replac rang str output mark len int caret po output mark str length select caret po caret po els histori index els histori index e consum els if code kei event vk down int caret po output mark if histori size 0 histori index if histori index 0 histori index 0 int len get document get length if histori index histori size string str string histori element at histori index replac rang str output mark len caret po output mark str length els histori index histori size replac rang output mark len select caret po caret po e consum 
call when a kei is type public void kei type kei event e int kei char e get kei char if kei char 0x8 kei event vk back space if output mark get caret posit e consum els if get caret posit output mark set caret posit output mark 
call when a kei is releas public synchron void kei releas kei event e 
call when text wa insert into the text area public synchron void insert updat document event e int len e get length int off e get offset if output mark off output mark len 
call when text wa remov from the text area public synchron void remov updat document event e int len e get length int off e get offset if output mark off if output mark off len output mark len els output mark off 
attempt to clean up the damang done by link updat compon tree ui public synchron void post updat ui request focu set caret get caret select output mark output mark 
call when text ha chang in the text area public synchron void chang updat document event e 
creat a new eval window public eval window string name swing gui debug gui super name true fals true true eval text area new eval text area debug gui eval text area set row 24 eval text area set column 80 jscroll pane scroller new jscroll pane eval text area set content pane scroller scroller set prefer size new dimens 600 400 pack set visibl true 
set whether the text area is enabl public void set enabl boolean b super set enabl b eval text area set enabl b 
perform an action on the text area public void action perform action event e string cmd e get action command if cmd equal cut eval text area cut els if cmd equal copi eval text area copi els if cmd equal past eval text area past 
creat a new jsintern consol public jsintern consol string name super name true fals true true consol text area new consol text area null consol text area set row 24 consol text area set column 80 jscroll pane scroller new jscroll pane consol text area set content pane scroller pack add intern frame listen new intern frame adapt public void intern frame activ intern frame event e hack if consol text area ha focu consol text area get caret set visibl fals consol text area get caret set visibl true 
add intern frame listen new intern frame adapt public void intern frame activ intern frame event e hack if consol text area ha focu consol text area get caret set visibl fals consol text area get caret set visibl true 
return the input stream of the consol text area public input stream get in return consol text area get in 
return the output stream of the consol text area public print stream get out return consol text area get out 
return the error stream of the consol text area public print stream get err return consol text area get err 
perform an action on the text area public void action perform action event e string cmd e get action command if cmd equal cut consol text area cut els if cmd equal copi consol text area copi els if cmd equal past consol text area past 
creat a new file popup menu public file popup menu file text area w thi w w jmenu item item add item new jmenu item set breakpoint item add action listen w add item new jmenu item clear breakpoint item add action listen w add item new jmenu item run item add action listen w 
displai the menu at the given coordin public void show jcompon comp int x int y thi x x thi y y super show comp x y 
creat a new file text area public file text area file window w thi w w popup new file popup menu thi popup add popup menu listen thi add mous listen thi add kei listen thi set font new font monospac 0 12 
move the select to the given offset public void select int po if po 0 try int line get line of offset po rectangl rect model to view po if rect null select po po els try rectangl nrect model to view get line start offset line 1 if nrect null rect nrect catch except exc jviewport vp jviewport get parent rectangl view rect vp get view rect if view rect y view rect height rect y need to scroll up select po po els need to scroll down rect y view rect height rect height 2 scroll rect to visibl rect select po po catch bad locat except exc select po po exc print stack trace 
check if the popup menu should be shown privat void check popup mous event e if e is popup trigger popup show thi e get x e get y 
call when a mous button is press public void mous press mous event e check popup e 
call when the mous is click public void mous click mous event e check popup e request focu get caret set visibl true 
call when the mous enter the compon public void mous enter mous event e 
call when the mous exit the compon public void mous exit mous event e 
call when a mous button is releas public void mous releas mous event e check popup e 
call befor the popup menu will becom visibl public void popup menu will becom visibl popup menu event e 
call befor the popup menu will becom invis public void popup menu will becom invis popup menu event e 
call when the popup menu is cancel public void popup menu cancel popup menu event e 
perform an action public void action perform action event e int po view to model new point popup x popup y popup set visibl fals string cmd e get action command int line 1 try line get line of offset po catch except exc if cmd equal set breakpoint w set break point line 1 els if cmd equal clear breakpoint w clear break point line 1 els if cmd equal run w load 
call when a kei is press public void kei press kei event e switch e get kei code case kei event vk back space case kei event vk enter case kei event vk delet e consum break 
call when a kei is type public void kei type kei event e e consum 
call when a kei is releas public void kei releas kei event e e consum 
creat a new more window more window jframe frame hashtabl file window string titl string label text super frame titl true thi file window file window button cancel button new jbutton cancel set button new jbutton select cancel button add action listen thi set button add action listen thi get root pane set default button set button dim part of the dialog list new jlist new default list model default list model model default list model list get model model clear model fire interv remov model 0 size enumer e file window kei while e ha more element string data e next element to string model add element data list set select index 0 model fire interv ad model 0 data length set button set enabl true list set select mode list select model singl interv select list add mous listen new mous handler jscroll pane list scroller new jscroll pane list list scroller set prefer size new dimens 320 240 xxx must do the follow too or els the scroller think xxx it s taller than it is list scroller set minimum size new dimens 250 80 list scroller set align x left align creat a contain so that we can add a titl around the scroll pane can t add a titl directli to the scroll pane becaus it background would be white lai out the label and scroll pane from top to button jpanel list pane new jpanel list pane set layout new box layout list pane box layout y axi jlabel label new jlabel label text label set label for list list pane add label list pane add box creat rigid area new dimens 0 5 list pane add list scroller list pane set border border factori creat empti border 10 10 10 10 lai out the button from left to right jpanel button pane new jpanel button pane set layout new box layout button pane box layout x axi button pane set border border factori creat empti border 0 10 10 10 button pane add box creat horizont glue button pane add cancel button button pane add box creat rigid area new dimens 10 0 button pane add set button put everyth togeth us the content pane s border layout contain content pane get content pane content pane add list pane border layout center content pane add button pane border layout south pack add kei listen new kei adapt public void kei press kei event ke int code ke get kei code if code kei event vk escap ke consum valu null set visibl fals 
add kei listen new kei adapt public void kei press kei event ke int code ke get kei code if code kei event vk escap ke consum valu null set visibl fals 
show the dialog public string show dialog compon comp valu null set locat rel to comp set visibl true return valu 
set the select valu privat void set valu string new valu valu new valu list set select valu valu true 
perform an action public void action perform action event e string cmd e get action command if cmd equal cancel set visibl fals valu null els if cmd equal select valu string list get select valu set visibl fals jintern frame w jintern frame file window get valu if w null try w show w set select true catch except exc 
privat class mous handler extend mous adapt public void mous click mous event e if e get click count 2 set button do click 
creat a new find function public find function swing gui debug gui string titl string label text super debug gui titl true thi debug gui debug gui cancel button new jbutton cancel set button new jbutton select cancel button add action listen thi set button add action listen thi get root pane set default button set button list new jlist new default list model default list model model default list model list get model model clear string a debug gui dim function name java util arrai sort a for int i 0 i a length i model add element a i list set select index 0 set button set enabl a length 0 list set select mode list select model singl interv select list add mous listen new mous handler jscroll pane list scroller new jscroll pane list list scroller set prefer size new dimens 320 240 list scroller set minimum size new dimens 250 80 list scroller set align x left align creat a contain so that we can add a titl around the scroll pane can t add a titl directli to the scroll pane becaus it background would be white lai out the label and scroll pane from top to button jpanel list pane new jpanel list pane set layout new box layout list pane box layout y axi jlabel label new jlabel label text label set label for list list pane add label list pane add box creat rigid area new dimens 0 5 list pane add list scroller list pane set border border factori creat empti border 10 10 10 10 lai out the button from left to right jpanel button pane new jpanel button pane set layout new box layout button pane box layout x axi button pane set border border factori creat empti border 0 10 10 10 button pane add box creat horizont glue button pane add cancel button button pane add box creat rigid area new dimens 10 0 button pane add set button put everyth togeth us the content pane s border layout contain content pane get content pane content pane add list pane border layout center content pane add button pane border layout south pack add kei listen new kei adapt public void kei press kei event ke int code ke get kei code if code kei event vk escap ke consum valu null set visibl fals 
add kei listen new kei adapt public void kei press kei event ke int code ke get kei code if code kei event vk escap ke consum valu null set visibl fals 
show the dialog public string show dialog compon comp valu null set locat rel to comp set visibl true return valu 
set the last function select privat void set valu string new valu valu new valu list set select valu valu true 
perform an action public void action perform action event e string cmd e get action command if cmd equal cancel set visibl fals valu null els if cmd equal select if list get select index 0 return try valu string list get select valu catch arrai index out of bound except exc return set visibl fals dim function sourc item debug gui dim function sourc by name valu if item null dim sourc info si item sourc info string url si url int line number item first line file window w debug gui get file window url if w null debug gui creat file window si line number w debug gui get file window url w set posit 1 int start w get posit line number 1 int end w get posit line number 1 w text area select start w text area set caret posit start w text area move caret posit end try w show debug gui request focu w request focu w text area request focu catch except exc 
class mous handler extend mous adapt public void mous click mous event e if e get click count 2 set button do click 
creat a new file header public file header file window file window thi file window file window add mous listen thi updat 
updat the gutter public void updat file text area text area file window text area font font text area get font set font font font metric metric get font metric font int h metric get height int line count text area get line count 1 string dummi integ to string line count if dummi length 2 dummi 99 dimens d new dimens d width metric string width dummi 16 d height line count h 100 set prefer size d set size d 
paint the compon public void paint graphic g super paint g file text area text area file window text area font font text area get font g set font font font metric metric get font metric font rectangl clip g get clip bound g set color get background g fill rect clip x clip y clip width clip height int left get x int ascent metric get max ascent int h metric get height int line count text area get line count 1 string dummi integ to string line count if dummi length 2 dummi 99 int max width metric string width dummi int start line clip y h int end line clip y clip height h 1 int width get width if end line line count end line line count for int i start line i end line i string text int po 2 try po text area get line start offset i catch bad locat except ignor boolean is break point file window is break point i 1 text integ to string i 1 int w metric string width text int y i h g set color color blue g draw string text 0 y ascent int x width ascent if is break point g set color new color 0x80 0x00 0x00 int dy y ascent 9 g fill oval x dy 9 9 g draw oval x dy 8 8 g draw oval x dy 9 9 if po file window current po polygon arrow new polygon int dx x y ascent 10 int dy y arrow add point dx dy 3 arrow add point dx 5 dy 3 for x dx 5 x dx 10 x y arrow add point x y for x dx 9 x dx 5 x y arrow add point x y arrow add point dx 5 dy 7 arrow add point dx dy 7 g set color color yellow g fill polygon arrow g set color color black g draw polygon arrow 
call when the mous enter the compon public void mous enter mous event e 
call when a mous button is press public void mous press mous event e font font file window text area get font font metric metric get font metric font int h metric get height press line e get y h 
call when the mous is click public void mous click mous event e 
call when the mous exit the compon public void mous exit mous event e 
call when a mous button is releas public void mous releas mous event e if e get compon thi e get modifi mous event button1 mask 0 int x e get x int y e get y font font file window text area get font font metric metric get font metric font int h metric get height int line y h if line press line file window toggl break point line 1 els press line 1 
load the file void load string url get url if url null run proxi proxi new run proxi debug gui run proxi load file proxi file name url proxi text sourc info sourc new thread proxi start 
return the offset posit for the given line public int get posit int line int result 1 try result text area get line start offset line catch javax swing text bad locat except exc return result 
return whether the given line ha a breakpoint public boolean is break point int line return sourc info breakabl line line sourc info breakpoint line 
toggl the breakpoint on the given line public void toggl break point int line if is break point line set break point line els clear break point line 
set a breakpoint on the given line public void set break point int line if sourc info breakabl line line boolean chang sourc info breakpoint line true if chang file header repaint 
clear a breakpoint from the given line public void clear break point int line if sourc info breakabl line line boolean chang sourc info breakpoint line fals if chang file header repaint 
creat a new file window public file window swing gui debug gui dim sourc info sourc info super swing gui get short name sourc info url true true true true thi debug gui debug gui thi sourc info sourc info updat tool tip current po 1 text area new file text area thi text area set row 24 text area set column 80 p new jscroll pane file header new file header thi p set viewport view text area p set row header view file header set content pane p pack updat text sourc info text area select 0 
updat the tool tip content privat void updat tool tip in case file name is veri long try to set tool tip on frame compon c get compon 1 thi will work at least for metal l f if c null c instanceof jcompon jcompon c set tool tip text get url 
return the url of the sourc public string get url return sourc info url 
call when the text of the script ha chang public void updat text dim sourc info sourc info thi sourc info sourc info string new text sourc info sourc if text area get text equal new text text area set text new text int po 0 if current po 1 po current po text area select po file header updat file header repaint 
set the cursor posit public void set posit int po text area select po current po po file header repaint 
select a rang of charact public void select int start int end int doc end text area get document get length text area select doc end doc end text area select start end 
dispos thi file window public void dispos debug gui remov window thi super dispos 
perform an action public void action perform action event e string cmd e get action command if cmd equal cut text area cut els if cmd equal copi text area copi els if cmd equal past text area past 
creat a new my tabl model public my tabl model swing gui debug gui thi debug gui debug gui express new vector valu new vector express add element valu add element 
return the number of column in the tabl 2 public int get column count return 2 
return the number of row in the tabl public int get row count return express size 
return the name of the given column public string get column name int column switch column case 0 return express case 1 return valu return null 
return whether the given cell is edit public boolean is cell edit int row int column return true 
return the valu in the given cell public object get valu at int row int column switch column case 0 return express element at row case 1 return valu element at row return 
set the valu in the given cell public void set valu at object valu int row int column switch column case 0 string expr valu to string express set element at expr row string result if expr length 0 result debug gui dim eval expr if result null result valu set element at result row updat model if row 1 express size express add element valu add element fire tabl row insert row 1 row 1 break case 1 just reset column 2 ignor edit fire tabl data chang 
re evalu the express in the tabl void updat model for int i 0 i express size i object valu express element at i string expr valu to string string result if expr length 0 result debug gui dim eval expr if result null result els result result result replac n valu set element at result i fire tabl data chang 
creat a new evalu public evalu swing gui debug gui super new my tabl model debug gui tabl model my tabl model get model 
creat a new variabl model public variabl model 
creat a new variabl model public variabl model dim debugg object scope thi debugg debugg thi root new variabl node scope thi 
return the root node of the tree public object get root if debugg null return null return root 
return the number of children of the given node public int get child count object node obj if debugg null return 0 variabl node node variabl node node obj return children node length 
return a child of the given node public object get child object node obj int i if debugg null return null variabl node node variabl node node obj return children node i 
return whether the given node is a leaf node public boolean is leaf object node obj if debugg null return true variabl node node variabl node node obj return children node length 0 
return the index of a node under it parent public int get index of child object parent obj object child obj if debugg null return 1 variabl node parent variabl node parent obj variabl node child variabl node child obj variabl node children children parent for int i 0 i children length i if children i child return i return 1 
return whether the given cell is edit public boolean is cell edit object node int column return column 0 
set the valu at the given cell public void set valu at object valu object node int column 
public void set valu at object valu object node int column add a tree model listen to thi tree public void add tree model listen tree model listen l 
public void add tree model listen tree model listen l remov a tree model listen from thi tree public void remov tree model listen tree model listen l 
public void remov tree model listen tree model listen l public void valu for path chang tree path path object new valu 
return the number of column public int get column count return c name length 
return the name of the given column public string get column name int column return c name column 
return the type of valu store in the given column public class get column class int column return c type column 
return the valu at the given cell public object get valu at object node obj int column if debugg null return null variabl node node variabl node node obj switch column case 0 name return node to string case 1 valu string result try result debugg object to string get valu node catch runtim except exc result exc get messag string buffer buf new string buffer int len result length for int i 0 i len i char ch result char at i if charact is isocontrol ch ch buf append ch return buf to string return null 
return an arrai of the children of the given node privat variabl node children variabl node node if node children null return node children variabl node children object valu get valu node object id debugg get object id valu if id length 0 children childless els arrai sort id new compar public int compar object l object r if l instanceof string if r instanceof integ return 1 return string l compar to ignor case string r els if r instanceof string return 1 int lint integ l int valu int rint integ r int valu return lint rint children new variabl node id length for int i 0 i id length i children i new variabl node valu id i node children children return children 
arrai sort id new compar public int compar object l object r if l instanceof string if r instanceof integ return 1 return string l compar to ignor case string r els if r instanceof string return 1 int lint integ l int valu int rint integ r int valu return lint rint 
return the valu of the given node public object get valu variabl node node try return debugg get object properti node object node id catch except exc return undefin 
creat a new variabl node public variabl node object object object id thi object object thi id id 
return a string represent of thi node public string to string return id instanceof string string id integ id int valu 
creat a new my tree tabl public my tree tabl variabl model model super model 
initi a tree for thi tree tabl public jtree reset tree tree tabl model tree tabl model tree new tree tabl cell render tree tabl model instal a tabl model repres the visibl row in the tree super set model new tree tabl model adapt tree tabl model tree forc the jtabl and jtree to share their row select model list to tree select model wrapper select wrapper new list to tree select model wrapper tree set select model select wrapper set select model select wrapper get list select model make the tree and tabl row height the same if tree get row height 1 metal look better like thi set row height 18 instal the tree editor render and editor set default render tree tabl model class tree set default editor tree tabl model class new tree tabl cell editor set show grid true set intercel space new dimens 1 1 tree set root visibl fals tree set show root handl true default tree cell render r default tree cell render tree get cell render r set open icon null r set close icon null r set leaf icon null return tree 
return whether the cell under the coordin of the mous in the link event object is edit public boolean is cell edit event object e if e instanceof mous event mous event me mous event e if the modifi ar not 0 or the left mous button tree mai try and toggl the select and tabl will then try and toggl result in the select remain the same to avoid thi we onli dispatch when the modifi ar 0 or the left mous button if me get modifi 0 me get modifi input event button1 mask 1024 0 me get modifi input event shift mask input event ctrl mask input event alt mask input event button2 mask input event button3 mask 64 shift down mask 128 ctrl down mask 512 alt down mask 2048 button2 down mask 4096 button3 down mask 0 int row row at point me get point for int counter get column count 1 counter 0 counter if tree tabl model class get column class counter mous event new me new mous event my tree tabl thi tree me get id me get when me get modifi me get x get cell rect row counter true x me get y me get click count me is popup trigger my tree tabl thi tree dispatch event new me break if me get click count 3 return true return fals if e null return true return fals 
creat a new context window public context window final swing gui debug gui thi debug gui debug gui enabl fals jpanel left new jpanel jtool bar t1 new jtool bar t1 set name variabl t1 set layout new grid layout t1 add left jpanel p1 new jpanel p1 set layout new grid layout jpanel p2 new jpanel p2 set layout new grid layout p1 add t1 jlabel label new jlabel context context new jcombo box context set light weight popup enabl fals tool tip new java util vector label set border context get border context add action listen thi context set action command context switch grid bag layout layout new grid bag layout left set layout layout grid bag constraint lc new grid bag constraint lc inset left 5 lc anchor grid bag constraint west lc ipadx 5 layout set constraint label lc left add label grid bag constraint c new grid bag constraint c gridwidth grid bag constraint remaind c fill grid bag constraint horizont c anchor grid bag constraint west layout set constraint context c left add context tab new jtab pane swing constant bottom tab set prefer size new dimens 500 300 thi tabl new my tree tabl new variabl model jscroll pane jsp new jscroll pane thi tabl jsp get viewport set view size new dimens 5 2 tab add thi jsp local tabl new my tree tabl new variabl model local tabl set auto resiz mode jtabl auto resiz all column local tabl set prefer size null jsp new jscroll pane local tabl tab add local jsp c weightx c weighti 1 c gridheight grid bag constraint remaind c fill grid bag constraint both c anchor grid bag constraint west layout set constraint tab c left add tab evalu new evalu debug gui cmd line new eval text area debug gui cmd line request focu tabl model evalu tabl model jsp new jscroll pane evalu jtool bar t2 new jtool bar t2 set name evalu tabs2 new jtab pane swing constant bottom tabs2 add watch jsp tabs2 add evalu new jscroll pane cmd line tabs2 set prefer size new dimens 500 300 t2 set layout new grid layout t2 add tabs2 p2 add t2 evalu set auto resiz mode jtabl auto resiz all column split new jsplit pane jsplit pane horizont split p1 p2 split set on touch expand true swing gui set resiz weight split 0 5 set layout new border layout add split border layout center final jtool bar final t1 t1 final jtool bar final t2 t2 final jpanel final p1 p1 final jpanel final p2 p2 final jsplit pane final split split final jpanel final thi thi compon listen clisten new compon listen boolean t1dock true boolean t2dock true void check compon comp compon thi parent final thi get parent if thi parent null return compon parent final t1 get parent boolean left dock true boolean right dock true boolean adjust vertic split fals if parent null if parent final p1 while parent instanceof jframe parent parent get parent jframe frame jframe parent debug gui add top level variabl frame we need the follow hack becaus we want an undock toolbar to be resiz we ar us jtoolbar as a contain of a jcombo box without thi jcombo box s popup can get left float when the toolbar is re dock we make the frame resiz and then remov jtoolbar s window listen and insert on of our own that first ensur the jcombo box s popup window is close and then call jtoolbar s window listen if frame is resiz frame set resiz true frame set default close oper window constant do noth on close final event listen l frame get listen window listen class frame remov window listen window listen l 0 frame add window listen new window adapt public void window close window event e context hide popup window listen l 0 window close e adjust vertic split true left dock fals els left dock true parent final t2 get parent if parent null if parent final p2 while parent instanceof jframe parent parent get parent jframe frame jframe parent debug gui add top level evalu frame frame set resiz true right dock fals els right dock true if left dock t2dock right dock t2dock no chang return t1dock left dock t2dock right dock jsplit pane split jsplit pane thi parent if left dock if right dock final split set divid locat 0 5 els final split set divid locat 1 0 if adjust vertic split split set divid locat 0 66 els if right dock final split set divid locat 0 0 split set divid locat 0 66 els both undock split set divid locat 1 0 public void compon hidden compon event e check e get compon public void compon move compon event e check e get compon public void compon resiz compon event e check e get compon public void compon shown compon event e check e get compon p1 add contain listen new contain listen public void compon ad contain event e compon thi parent final thi get parent jsplit pane split jsplit pane thi parent if e get child final t1 if final t2 get parent final p2 both dock final split set divid locat 0 5 els left dock onli final split set divid locat 1 0 split set divid locat 0 66 public void compon remov contain event e compon thi parent final thi get parent jsplit pane split jsplit pane thi parent if e get child final t1 if final t2 get parent final p2 right dock onli final split set divid locat 0 0 split set divid locat 0 66 els both undock split set divid locat 1 0 t1 add compon listen clisten t2 add compon listen clisten disabl 
boolean t2dock true void check compon comp compon thi parent final thi get parent if thi parent null return compon parent final t1 get parent boolean left dock true boolean right dock true boolean adjust vertic split fals if parent null if parent final p1 while parent instanceof jframe parent parent get parent jframe frame jframe parent debug gui add top level variabl frame we need the follow hack becaus we want an undock toolbar to be resiz we ar us jtoolbar as a contain of a jcombo box without thi jcombo box s popup can get left float when the toolbar is re dock we make the frame resiz and then remov jtoolbar s window listen and insert on of our own that first ensur the jcombo box s popup window is close and then call jtoolbar s window listen if frame is resiz frame set resiz true frame set default close oper window constant do noth on close final event listen l frame get listen window listen class frame remov window listen window listen l 0 frame add window listen new window adapt public void window close window event e context hide popup window listen l 0 window close e adjust vertic split true left dock fals els left dock true parent final t2 get parent if parent null if parent final p2 while parent instanceof jframe parent parent get parent jframe frame jframe parent debug gui add top level evalu frame frame set resiz true right dock fals els right dock true if left dock t2dock right dock t2dock no chang return t1dock left dock t2dock right dock jsplit pane split jsplit pane thi parent if left dock if right dock final split set divid locat 0 5 els final split set divid locat 1 0 if adjust vertic split split set divid locat 0 66 els if right dock final split set divid locat 0 0 split set divid locat 0 66 els both undock split set divid locat 1 0 
frame remov window listen window listen l 0 frame add window listen new window adapt public void window close window event e context hide popup window listen l 0 window close e 
public void compon hidden compon event e check e get compon 
check e get compon public void compon move compon event e check e get compon 
check e get compon public void compon resiz compon event e check e get compon 
check e get compon public void compon shown compon event e check e get compon 
p1 add contain listen new contain listen public void compon ad contain event e compon thi parent final thi get parent jsplit pane split jsplit pane thi parent if e get child final t1 if final t2 get parent final p2 both dock final split set divid locat 0 5 els left dock onli final split set divid locat 1 0 split set divid locat 0 66 
public void compon remov contain event e compon thi parent final thi get parent jsplit pane split jsplit pane thi parent if e get child final t1 if final t2 get parent final p2 right dock onli final split set divid locat 0 0 split set divid locat 0 66 els both undock split set divid locat 1 0 
disabl the compon public void disabl context set enabl fals thi tabl set enabl fals local tabl set enabl fals evalu set enabl fals cmd line set enabl fals 
enabl the compon public void enabl context set enabl true thi tabl set enabl true local tabl set enabl true evalu set enabl true cmd line set enabl true 
disabl updat of the compon public void disabl updat enabl fals 
enabl updat of the compon public void enabl updat enabl true 
perform an action public void action perform action event e if enabl return if e get action command equal context switch dim context data context data debug gui dim current context data if context data null return int frame index context get select index context set tool tip text tool tip element at frame index to string int frame count context data frame count if frame index frame count return dim stack frame frame context data get frame frame index object scope frame scope object thi obj frame thi obj thi tabl reset tree new variabl model debug gui dim thi obj variabl model scope model if scope thi obj scope model new variabl model debug gui dim scope els scope model new variabl model local tabl reset tree scope model debug gui dim context switch frame index debug gui show stop line frame tabl model updat model 
creat a new menubar menubar swing gui debug gui super thi debug gui debug gui string file item open run exit string file cmd open load exit char file short cut 0 n 0 x int file acceler kei event vk o kei event vk n 0 kei event vk q string edit item cut copi past go to function char edit short cut t c p f string debug item break go step into step over step out char debug short cut b g i o t string plaf item metal window motif char plaf short cut m w f int debug acceler kei event vk paus kei event vk f5 kei event vk f11 kei event vk f7 kei event vk f8 0 0 jmenu file menu new jmenu file file menu set mnemon f jmenu edit menu new jmenu edit edit menu set mnemon e jmenu plaf menu new jmenu platform plaf menu set mnemon p jmenu debug menu new jmenu debug debug menu set mnemon d window menu new jmenu window window menu set mnemon w for int i 0 i file item length i if file item i length 0 file menu add separ els jmenu item item new jmenu item file item i file short cut i item set action command file cmd i item add action listen thi file menu add item if file acceler i 0 kei stroke k kei stroke get kei stroke file acceler i event ctrl mask item set acceler k for int i 0 i edit item length i jmenu item item new jmenu item edit item i edit short cut i item add action listen thi edit menu add item for int i 0 i plaf item length i jmenu item item new jmenu item plaf item i plaf short cut i item add action listen thi plaf menu add item for int i 0 i debug item length i jmenu item item new jmenu item debug item i debug short cut i item add action listen thi if debug acceler i 0 kei stroke k kei stroke get kei stroke debug acceler i 0 item set acceler k if i 0 interrupt onli item add item els run onli item add item debug menu add item break on except new jcheck box menu item break on except break on except set mnemon x break on except add action listen thi break on except set select fals debug menu add break on except break on enter new jcheck box menu item break on function enter break on enter set mnemon e break on enter add action listen thi break on enter set select fals debug menu add break on enter break on return new jcheck box menu item break on function return break on return set mnemon r break on return add action listen thi break on return set select fals debug menu add break on return add file menu add edit menu add plaf menu add debug menu jmenu item item window menu add item new jmenu item cascad a item add action listen thi window menu add item new jmenu item tile t item add action listen thi window menu add separ window menu add item new jmenu item consol c item add action listen thi add window menu updat enabl fals 
return the break on except menu item public jcheck box menu item get break on except return break on except 
return the break on enter menu item public jcheck box menu item get break on enter return break on enter 
return the break on return menu item public jcheck box menu item get break on return return break on return 
return the debug menu public jmenu get debug menu return get menu 2 
perform an action public void action perform action event e string cmd e get action command string plaf name null if cmd equal metal plaf name javax swing plaf metal metal look and feel els if cmd equal window plaf name com sun java swing plaf window window look and feel els if cmd equal motif plaf name com sun java swing plaf motif motif look and feel els object sourc e get sourc if sourc break on except debug gui dim set break on except break on except is select els if sourc break on enter debug gui dim set break on enter break on enter is select els if sourc break on return debug gui dim set break on return break on return is select els debug gui action perform e return try uimanag set look and feel plaf name swing util updat compon tree ui debug gui swing util updat compon tree ui debug gui dlg catch except ignor ignor print stack trace 
add a file to the window menu public void add file string url int count window menu get item count jmenu item item if count 4 window menu add separ count jmenu item last item window menu get item count 1 boolean ha more win fals int max win 5 if last item null last item get text equal more window ha more win true max win if ha more win count 4 5 window menu add item new jmenu item more window m item set action command more window item add action listen thi return els if count 4 max win if ha more win count window menu remov last item string short name swing gui get short name url window menu add item new jmenu item char 0 count 4 short name 0 count 4 if ha more win window menu add last item els return item set action command url item add action listen thi 
updat the enabled of menu item public void updat enabl boolean interrupt for int i 0 i interrupt onli item size i jmenu item item jmenu item interrupt onli item element at i item set enabl interrupt for int i 0 i run onli item size i jmenu item item jmenu item run onli item element at i item set enabl interrupt 
creat a new run proxi public run proxi swing gui debug gui int type thi debug gui debug gui thi type type 
run thi runnabl public void run switch type case open file try debug gui dim compil script file name text catch runtim except ex messag dialog wrapper show messag dialog debug gui ex get messag error compil file name joption pane error messag break case load file try debug gui dim eval script file name text catch runtim except ex messag dialog wrapper show messag dialog debug gui ex get messag run error for file name joption pane error messag break case updat sourc text string file name sourc info url file window w debug gui get file window file name if w null w updat text sourc info w show els if file name equal stdin debug gui creat file window sourc info 1 break case enter interrupt debug gui enter interrupt impl last frame thread titl alert messag break default throw new illeg argument except string valu of type 
creat a new test case object param pass true if the test case pass otherwis fals param name label associ with the test case param descript string show what got test usual java script code param expect string represent of the expect result param actual string represent of the actual result param reason reason for test failur see com netscap javascript qa driver test driver see com netscap javascript qa driver test environ public test case string pass string name string descript string expect string actual string reason thi pass pass thi name name thi descript descript thi expect expect thi actual actual thi reason reason 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string expect return int 
the zero paramet constructor when scriptabl object defin class is call with thi class it will construct matrix prototyp us thi constructor public matrix 
the java constructor also us to defin the java script constructor public matrix int dimens if dimens 0 throw context report runtim error dimens of matrix must be greater than zero dim dimens v new vector 
return the name of thi java script class matrix public string get class name return matrix 
defin the dim properti by return true if name is equal to dim p defin no other properti i e return fals for all other name param name the name of the properti param start the object where lookup began public boolean ha string name scriptabl start return name equal dim 
defin all numer properti by return true param index the index of the properti param start the object where lookup began public boolean ha int index scriptabl start return true 
get the name properti p handl the dim properti and return not found for all other name param name the properti name param start the object where the lookup began public object get string name scriptabl start if name equal dim return new integ dim return not found 
get the index properti p look up the element in the associ vector and return it if it exist if it doesn t exist creat it p param index the index of the integr properti param start the object where the lookup began public object get int index scriptabl start if index v size v set size index 1 object result v element at index if result null return result if dim 2 matrix m new matrix dim 1 m set parent scope get parent scope m set prototyp get prototyp result m els context cx context get current context scriptabl scope scriptabl object get top level scope start result cx new arrai scope 0 v set element at result index return result 
set a name properti we do noth here so all properti ar effect read onli public void put string name scriptabl start object valu 
set an index properti we do noth here so all properti ar effect read onli public void put int index scriptabl start object valu 
remov a name properti thi method shouldn t even be call sinc we defin all properti as perman public void delet string id 
remov an index properti thi method shouldn t even be call sinc we defin all properti as perman public void delet int index 
get prototyp public scriptabl get prototyp return prototyp 
set prototyp public void set prototyp scriptabl prototyp thi prototyp prototyp 
get parent public scriptabl get parent scope return parent 
set parent public void set parent scope scriptabl parent thi parent parent 
get properti we return an empti arrai sinc we defin all properti to be dontenum public object get id return new object 0 
default valu us the conveni method from context that take care of call to string etc public object get default valu class type hint return object matrix 
instanceof oper we mimick the normal java script instanceof semant return true if code thi code appear in code valu code s prototyp chain public boolean ha instanc scriptabl valu scriptabl proto valu get prototyp while proto null if proto equal thi return true proto proto get prototyp return fals 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
member box ctor public nativ java constructor member box ctor thi ctor ctor 
public object call context cx scriptabl scope scriptabl thi obj object arg return nativ java class construct specif cx scope arg ctor 
public string get function name string sig java member live connect signatur ctor arg type return init concat sig 
public string to string return java constructor ctor get name 
static void init scriptabl scope boolean seal nativ call obj new nativ call obj export as jsclass max prototyp id scope seal 
nativ call 
nativ call nativ function function scriptabl scope object arg thi function function set parent scope scope leav prototyp null thi origin arg arg null script runtim empti arg arg initi valu of argument int param and var count function get param and var count int param count function get param count if param and var count 0 for int i 0 i param count i string name function get param or var name i object val i arg length arg i undefin instanc defin properti name val perman initi argument properti but onli if it wa not overriden by the paramet with the same name if super ha argument thi defin properti argument new argument thi perman if param and var count 0 for int i param count i param and var count i string name function get param or var name i if super ha name thi defin properti name undefin instanc perman 
public string get class name return call 
protect int find prototyp id string s return s equal constructor id constructor 0 
protect void init prototyp id int id string s int ariti if id id constructor ariti 1 s constructor els throw new illeg argument except string valu of id init prototyp method call tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag call tag return super exec id call f cx scope thi obj arg int id f method id if id id constructor if thi obj null throw context report runtim error1 msg onli from new call script runtim check deprec cx call nativ call result new nativ call result set prototyp get object prototyp scope return result throw new illeg argument except string valu of id 
public string float float public string ambigu boolean arg return boolean 
public string ambigu boolean arg return boolean object 
public string ambigu doubl arg return doubl object 
public string expect return boolean 
public abstract class secur proxi extend secur control protect abstract void call process file secur context cx scriptabl scope string filenam 
public lazili load ctor scriptabl object scope string ctor name string class name boolean seal thi class name class name thi ctor name ctor name thi seal seal if getter null method method function object get method list get class getter function object find singl method method get properti setter function object find singl method method set properti scope defin properti ctor name thi getter setter scriptabl object dontenum 
public object get properti scriptabl object obj synchron obj if is replac boolean remov on error fals class cl kit class or null class name if cl null remov on error true els try scriptabl object defin class obj cl seal is replac true catch invoc target except ex throwabl target ex get target except if target instanceof runtim except throw runtim except target remov on error true catch rhino except ex remov on error true catch instanti except ex remov on error true catch illeg access except ex remov on error true catch secur except ex treat secur except as absenc of object thei can be due to the follow reason java lang runtim permiss creat class loader remov on error true catch linkag error ex no depend class remov on error true if remov on error obj delet ctor name return scriptabl not found get just ad object return obj get ctor name obj 
public object set properti scriptabl object obj object val synchron obj is replac true return val 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl 
public string ambigu string arg return string 
xmlwith scope xmllib impl lib scriptabl parent xmlobject prototyp super parent prototyp thi lib lib 
void init as dot queri xmlobject prototyp xmlobject get prototyp xmlwith scope also handl the xxx dot queri for xml basic dot queri is a for in with statement and in the follow 3 statement we setup to signal it s dot queri the index and the object be loop over the xw set prototyp is the scope of the object which is is a element of the lh xmllist curr index 0 dq prototyp prototyp if prototyp instanceof xmllist xmllist xl xmllist prototyp if xl length 0 set prototyp scriptabl xl get 0 null alwai return the outer most type of xml l valu of xml to left of dot queri xml list new xmllist lib 
protect object updat dot queri boolean valu return null to continu loop xmlobject seed dq prototyp xmllist xml l xml list object result if seed instanceof xmllist we re a list so keep test each element of the list if the result on the top of stack is true then that element is ad to our result list if fals we try the next element xmllist org xml l xmllist seed int idx curr index if valu xml l add to list org xml l get idx null more element to test if idx org xml l length ye set our new index get the next element and reset the express to run with thi object as the with selector curr index idx set prototyp scriptabl org xml l get idx null continu loop return null els if we re not a xmllist then there s no loop just return dqprototyp if the result is true if valu xml l add to list seed return xml l 
public static xmllib extract from scope or null scriptabl scope scriptabl object so script runtim get librari scope or null scope if so null if librrai is not yet initi return null return null ensur lazili initi of real xml librari instanc which is done on first access to xml properti scriptabl object get properti so xml return xmllib so get associ valu xml lib kei 
public static xmllib extract from scope scriptabl scope xmllib lib extract from scope or null scope if lib null return lib string msg script runtim get message0 msg xml not avail throw context report runtim error msg 
protect final xmllib bind to scope scriptabl scope scriptabl object so script runtim get librari scope or null scope if so null standard librari should be initi at thi point throw new illeg state except return xmllib so associ valu xml lib kei thi 
public abstract boolean is xmlname context cx object name 
public abstract boolean is xmlname context cx object name public abstract ref name ref context cx object name scriptabl scope int member type flag 
scriptabl scope int member type flag public abstract ref name ref context cx object namespac object name scriptabl scope int member type flag 
escap the reserv charact in a valu of an attribut and surround it by param valu unescap text return the escap text 
escap the reserv charact in a valu of a text node param valu unescap text return the escap text 
construct namespac for default xml statement public abstract object to default xml namespac context cx object uri valu 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
static final long serial version uid 8743165779676009808l public evalu except string detail super detail 
creat an except with the specifi detail messag error intern to the java script engin will simpli throw a runtim except param detail the error messag param sourc name the name of the sourc repons for the error param line number the line number of the sourc public evalu except string detail string sourc name int line number thi detail sourc name line number null 0 
creat an except with the specifi detail messag error intern to the java script engin will simpli throw a runtim except param detail the error messag param sourc name the name of the sourc repons for the error param line number the line number of the sourc param column number the column number of the sourc mai be zero if unknown param line sourc the sourc of the line contain the error mai be null if unknown public evalu except string detail string sourc name int line number string line sourc int column number super detail record error origin sourc name line number line sourc column number 
deprec us link rhino except sourc name from the super class public string get sourc name return sourc name 
deprec us link rhino except line number from the super class public int get line number return line number 
deprec us link rhino except column number from the super class public int get column number return column number 
deprec us link rhino except line sourc from the super class public string get line sourc return line sourc 
public string float float public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl object 
public string ambigu doubl arg return doubl 
public string ambigu char arg return char 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string expect return string 
public static void init context cx scriptabl scope boolean seal nativ reg exp proto new nativ reg exp proto re recompil compil re null fals proto activ prototyp map max prototyp id proto set parent scope scope proto set prototyp get object prototyp scope nativ reg exp ctor ctor new nativ reg exp ctor bug 324006 ecma 262 15 10 6 1 sai the initi valu of reg exp prototyp constructor is the builtin reg exp constructor proto put constructor proto ctor script runtim set function proto and parent ctor scope ctor set immun prototyp properti proto if seal proto seal object ctor seal object defin properti scope reg exp ctor scriptabl object dontenum 
nativ reg exp scriptabl scope object regexp compil thi re recompil regexp compil thi last index 0 script runtim set object proto and parent thi scope 
public string get class name return reg exp 
public object call context cx scriptabl scope scriptabl thi obj object arg return exec sub cx scope arg match 
public scriptabl construct context cx scriptabl scope object arg return scriptabl exec sub cx scope arg match 
scriptabl compil context cx scriptabl scope object arg if arg length 0 arg 0 instanceof nativ reg exp if arg length 1 arg 1 undefin instanc report error throw script runtim type error0 msg bad regexp compil nativ reg exp that obj nativ reg exp arg 0 thi re that obj re thi last index that obj last index return thi string s arg length 0 script runtim to string arg 0 string global arg length 1 arg 1 undefin instanc script runtim to string arg 1 null thi re recompil compil re s global fals thi last index 0 return thi 
public string to string string buffer buf new string buffer buf append if re sourc length 0 buf append re sourc els see bugzilla 226045 buf append buf append if re flag jsreg glob 0 buf append g if re flag jsreg fold 0 buf append i if re flag jsreg multilin 0 buf append m return buf to string 
nativ reg exp 
nativ reg exp privat static reg exp impl get impl context cx return reg exp impl script runtim get reg exp proxi cx 
privat object exec sub context cx scriptabl scope obj object arg int match type reg exp impl re impl get impl cx string str if arg length 0 str re impl input if str null report error msg no re input for to string els str script runtim to string arg 0 doubl d re flag jsreg glob 0 last index 0 object rval if d 0 str length d last index 0 rval null els int indexp int d rval execut reg exp cx scope obj re impl str indexp match type if re flag jsreg glob 0 last index rval null rval undefin instanc 0 indexp 0 return rval 
static object compil re string str string global boolean flat recompil regexp new recompil regexp sourc str to char arrai int length str length int flag 0 if global null for int i 0 i global length i char c global char at i if c g flag jsreg glob els if c i flag jsreg fold els if c m flag jsreg multilin els report error msg invalid re flag string valu of c regexp flag flag compil state state new compil state regexp sourc length flag if flat length 0 if debug system out println flat str state result new renod reop flat state result chr state cpbegin 0 state result length length state result flat index 0 state prog length 5 els if pars disjunct state return null regexp program new byte state prog length 1 if state class count 0 regexp class list new rechar set state class count regexp class count state class count int end pc emit rebytecod state regexp 0 state result regexp program end pc reop end if debug system out println prog length end pc for int i 0 i end pc i system out print regexp program i if i end pc 1 system out print system out println regexp paren count state paren count if re start with liter init anchor ch accordingli switch regexp program 0 case reop ucflat1 case reop ucflat1i regexp anchor ch char get index regexp program 1 break case reop flat1 case reop flat1i regexp anchor ch char regexp program 1 0x ff break case reop flat case reop flati int k get index regexp program 1 regexp anchor ch regexp sourc k break if debug if regexp anchor ch 0 system out println anchor ch char regexp anchor ch return regexp 
static boolean is digit char c return 0 c c 9 
privat static boolean is word char c return charact is letter c is digit c c 
privat static boolean is line term char c return script runtim is jsline termin c 
privat static boolean is rewhit space int c return c u0020 c u0009 c n c r c 0x2028 c 0x2029 c u000c c u000b c u00a0 charact get type char c charact space separ 
privat static char upcas char ch if ch 128 if a ch ch z return char ch a a return ch char cu charact to upper case ch if ch 128 cu 128 return ch return cu 
privat static char downcas char ch if ch 128 if a ch ch z return char ch a a return ch char cl charact to lower case ch if ch 128 cl 128 return ch return cl 
privat static int to asciihex digit int c if c 0 return 1 if c 9 return c 0 c 0x20 if a c c f return c a 10 return 1 
privat static boolean pars disjunct compil state state if pars altern state return fals char sourc state cpbegin int index state cp if index sourc length sourc index renod alt result state cp alt result new renod reop alt alt result kid state result if pars disjunct state return fals alt result kid2 state result state result alt result alt next jump end jump end state prog length 9 return true 
privat static boolean pars altern compil state state renod head term null renod tail term null char sourc state cpbegin while true if state cp state cpend sourc state cp state paren nest 0 sourc state cp if head term null state result new renod reop empti els state result head term return true if pars term state return fals if head term null head term state result els if tail term null head term next state result tail term state result while tail term next null tail term tail term next els tail term next state result tail term tail term next while tail term next null tail term tail term next 
calcul the total size of the bitmap requir for a class express privat static boolean calcul bitmap size compil state state renod target char src int index int end char rang start 0 char c int n int digit int n digit int i int max 0 boolean in rang fals target bmsize 0 if index end return true if src index index while index end int local max 0 n digit 2 switch src index case index c src index switch c case b local max 0x8 break case f local max 0x c break case n local max 0x a break case r local max 0x d break case t local max 0x9 break case v local max 0x b break case c if index 1 end charact is letter src index 1 local max char src index 0x1f els local max break case u n digit 2 fall thru case x n 0 for i 0 i n digit index end i c src index n kit x digit to int c n if n 0 back off to accept the origin as a liter index i 1 n break local max n break case d if in rang report error msg bad rang return fals local max 9 break case d case s case s case w case w if in rang report error msg bad rang return fals target bmsize 65535 return true case 0 case 1 case 2 case 3 case 4 case 5 case 6 case 7 thi is a non ecma extens decim escap in thi case octal ar suppos to be an error insid class rang but support here for backward compat n c 0 c src index if 0 c c 7 index n 8 n c 0 c src index if 0 c c 7 index i 8 n c 0 if i 0377 n i els index local max n break default local max c break break default local max src index break if in rang if rang start local max report error msg bad rang return fals in rang fals els if index end 1 if src index index in rang true rang start char local max continu if state flag jsreg fold 0 char cu upcas char local max char cd downcas char local max local max cu cd cu cd if local max max max local max target bmsize max return true 
privat static void do flat compil state state char c state result new renod reop flat state result chr c state result length 1 state result flat index 1 state prog length 3 
privat static int get decim valu char c compil state state int max valu string overflow messag id boolean overflow fals int start state cp char src state cpbegin int valu c 0 for state cp state cpend state cp c src state cp if is digit c break if overflow int digit c 0 if valu max valu digit 10 valu valu 10 digit els overflow true valu max valu if overflow report error overflow messag id string valu of src start state cp start return valu 
privat static boolean pars term compil state state char src state cpbegin char c src state cp int n digit 2 int paren base count state paren count int num tmp renod term int term start int ocp state cp switch c assert and atom case state result new renod reop bol state prog length return true case state result new renod reop eol state prog length return true case if state cp state cpend c src state cp switch c assert escap case b state result new renod reop wbdry state prog length return true case b state result new renod reop wnonbdri state prog length return true decim escap case 0 under strict ecma 3 we interpret 0 as nul and don t accept octal howev xxx and sinc rhino doesn t have a strict mode we ll just behav the old wai for compat reason see http bugzilla mozilla org show bug cgi id 141078 octal escap num 0 while state cp state cpend c src state cp if c 0 c 7 state cp tmp 8 num c 0 if tmp 0377 break num tmp els break c char num do flat state c break case 1 case 2 case 3 case 4 case 5 case 6 case 7 case 8 case 9 term start state cp 1 num get decim valu c state 0x ffff msg overlarg backref n 9 and count of parenthes then treat as octal instead if num 9 num state paren count state cp term start num 0 while state cp state cpend c src state cp if c 0 c 7 state cp tmp 8 num c 0 if tmp 0377 break num tmp els break c char num do flat state c break otherwis it s a back refer state result new renod reop backref state result paren index num 1 state prog length 3 break control escap case f c 0x c do flat state c break case n c 0x a do flat state c break case r c 0x d do flat state c break case t c 0x9 do flat state c break case v c 0x b do flat state c break control letter case c if state cp 1 state cpend charact is letter src state cp 1 c char src state cp 0x1f els back off to accept the origin as a liter state cp c do flat state c break unicod escap sequenc case u n digit 2 fall thru hex escap sequenc case x int n 0 int i for i 0 i n digit state cp state cpend i int digit c src state cp n kit x digit to int c n if n 0 back off to accept the origin u or x as a liter state cp i 2 n src state cp break c char n do flat state c break charact class escap case d state result new renod reop digit state prog length break case d state result new renod reop nondigit state prog length break case s state result new renod reop space state prog length break case s state result new renod reop nonspac state prog length break case w state result new renod reop alnum state prog length break case w state result new renod reop nonalnum state prog length break ident escap default state result new renod reop flat state result chr c state result length 1 state result flat index state cp 1 state prog length 3 break break els a trail is an error report error msg trail backslash return fals case renod result null term start state cp if state cp 1 state cpend src state cp c src state cp 1 c c state cp 2 if c result new renod reop assert assert next asserttest state prog length 4 els if c result new renod reop assert not assertnot next assertnottest state prog length 4 els result new renod reop lparen lparen index rparen index state prog length 6 result paren index state paren count state paren nest if pars disjunct state return fals if state cp state cpend src state cp report error msg unterm paren return fals state cp state paren nest if result null result kid state result state result result break case report error msg re unmatch right paren return fals case state result new renod reop class term start state cp state result start index term start while true if state cp state cpend report error msg unterm class return fals if src state cp state cp els if src state cp state result kidlen state cp term start break state cp state result index state class count call calcul bitmap size now as we want ani error it find to be report dure the pars phase not at execut if calcul bitmap size state state result src term start state cp return fals state prog length 3 class index break case state result new renod reop dot state prog length break case case case report error msg bad quant string valu of src state cp 1 return fals default state result new renod reop flat state result chr c state result length 1 state result flat index state cp 1 state prog length 3 break term state result if state cp state cpend return true boolean ha q fals switch src state cp case state result new renod reop quant state result min 1 state result max 1 plu parencount parenindex next endchild state prog length 8 ha q true break case state result new renod reop quant state result min 0 state result max 1 star parencount parenindex next endchild state prog length 8 ha q true break case state result new renod reop quant state result min 0 state result max 1 opt parencount parenindex next endchild state prog length 8 ha q true break case balanc int min 0 int max 1 int left curl state cp for perl etc compat if quntifi doe not match d d exactli back off from it be a quantifi and chew it up as a liter atom next time instead c src state cp if is digit c state cp min get decim valu c state 0x ffff msg overlarg min c src state cp if c c src state cp if is digit c state cp max get decim valu c state 0x ffff msg overlarg max c src state cp if min max report error msg max lt min string valu of src state cp return fals els max min balanc if c state result new renod reop quant state result min min state result max max quant min max parencount parenindex next endchild state prog length 12 ha q true if ha q state cp left curl break if ha q return true state cp state result kid term state result paren index paren base count state result paren count state paren count paren base count if state cp state cpend src state cp state cp state result greedi fals els state result greedi true return true 
privat static void resolv forward jump byte arrai int from int pc if from pc throw kit code bug add index arrai from pc from 
privat static int get offset byte arrai int pc return get index arrai pc 
privat static int add index byte arrai int pc int index if index 0 throw kit code bug if index 0x ffff throw context report runtim error too complex regexp arrai pc byte index 8 arrai pc 1 byte index return pc 2 
privat static int get index byte arrai int pc return arrai pc 0x ff 8 arrai pc 1 0x ff 
privat static int emit rebytecod compil state state recompil re int pc renod t renod next alt int next alt fixup next term fixup byte program re program while t null program pc t op switch t op case reop empti pc break case reop alt next alt t kid2 next alt fixup pc address of next altern pc offset len pc emit rebytecod state re pc t kid program pc reop jump next term fixup pc address of follow term pc offset len resolv forward jump program next alt fixup pc pc emit rebytecod state re pc next alt program pc reop jump next alt fixup pc pc offset len resolv forward jump program next term fixup pc resolv forward jump program next alt fixup pc break case reop flat consecut flat s if possibl if t flat index 1 while t next null t next op reop flat t flat index t length t next flat index t length t next length t next t next next if t flat index 1 t length 1 if state flag jsreg fold 0 program pc 1 reop flati els program pc 1 reop flat pc add index program pc t flat index pc add index program pc t length els if t chr 256 if state flag jsreg fold 0 program pc 1 reop flat1i els program pc 1 reop flat1 program pc byte t chr els if state flag jsreg fold 0 program pc 1 reop ucflat1i els program pc 1 reop ucflat1 pc add index program pc t chr break case reop lparen pc add index program pc t paren index pc emit rebytecod state re pc t kid program pc reop rparen pc add index program pc t paren index break case reop backref pc add index program pc t paren index break case reop assert next term fixup pc pc offset len pc emit rebytecod state re pc t kid program pc reop asserttest resolv forward jump program next term fixup pc break case reop assert not next term fixup pc pc offset len pc emit rebytecod state re pc t kid program pc reop assertnottest resolv forward jump program next term fixup pc break case reop quant if t min 0 t max 1 program pc 1 t greedi reop star reop minimalstar els if t min 0 t max 1 program pc 1 t greedi reop opt reop minimalopt els if t min 1 t max 1 program pc 1 t greedi reop plu reop minimalplu els if t greedi program pc 1 reop minimalqu pc add index program pc t min max can be 1 which add index doe not accept pc add index program pc t max 1 pc add index program pc t paren count pc add index program pc t paren index next term fixup pc pc offset len pc emit rebytecod state re pc t kid program pc reop endchild resolv forward jump program next term fixup pc break case reop class pc add index program pc t index re class list t index new rechar set t bmsize t start index t kidlen break default break t t next return pc 
privat static void push prog state reglob data g data int min int max reback track data back track last to save int continu pc int continu op g data state stack top new reprog state g data state stack top min max g data cp back track last to save continu pc continu op 
privat static reprog state pop prog state reglob data g data reprog state state g data state stack top g data state stack top state previou return state 
privat static void push back track state reglob data g data byte op int target g data back track stack top new reback track data g data op target 
privat static boolean flat nmatcher reglob data g data int match char int length char char int end if g data cp length end return fals for int i 0 i length i if g data regexp sourc match char i char g data cp i return fals g data cp length return true 
privat static boolean flat nimatch reglob data g data int match char int length char char int end if g data cp length end return fals for int i 0 i length i if upcas g data regexp sourc match char i upcas char g data cp i return fals g data cp length return true 
privat static boolean backref matcher reglob data g data int paren index char char int end int len int i int paren content g data paren index paren index if paren content 1 return true len g data paren length paren index if g data cp len end return fals if g data regexp flag jsreg fold 0 for i 0 i len i if upcas char paren content i upcas char g data cp i return fals els for i 0 i len i if char paren content i char g data cp i return fals g data cp len return true 
add a singl charact to the rechar set privat static void add charact to char set rechar set cs char c int byte index int c 8 if c cs length throw new runtim except cs bit byte index 1 c 0x7 
add a charact rang c1 to c2 inclus to the rechar set privat static void add charact rang to char set rechar set cs char c1 char c2 int i int byte index1 int c1 8 int byte index2 int c2 8 if c2 cs length c1 c2 throw new runtim except c1 0x7 c2 0x7 if byte index1 byte index2 cs bit byte index1 int 0x ff 7 c2 c1 c1 els cs bit byte index1 0x ff c1 for i byte index1 1 i byte index2 i cs bit i byte 0x ff cs bit byte index2 int 0x ff 7 c2 
compil the sourc of the class into a rechar set privat static void process char set reglob data g data rechar set char set synchron char set if char set convert process char set impl g data char set char set convert true 
privat static void process char set impl reglob data g data rechar set char set int src char set start index int end src char set strlength char rang start 0 thi ch int byte length char c int n int n digit int i boolean in rang fals char set sens true byte length char set length 8 1 char set bit new byte byte length if src end return if g data regexp sourc src char set sens fals src while src end n digit 2 switch g data regexp sourc src case src c g data regexp sourc src switch c case b thi ch 0x8 break case f thi ch 0x c break case n thi ch 0x a break case r thi ch 0x d break case t thi ch 0x9 break case v thi ch 0x b break case c if src 1 end is word g data regexp sourc src 1 thi ch char g data regexp sourc src 0x1f els src thi ch break case u n digit 2 fall thru case x n 0 for i 0 i n digit src end i c g data regexp sourc src int digit to asciihex digit c if digit 0 back off to accept the origin as a liter src i 1 n break n n 4 digit thi ch char n break case 0 case 1 case 2 case 3 case 4 case 5 case 6 case 7 thi is a non ecma extens decim escap in thi case octal ar suppos to be an error insid class rang but support here for backward compat n c 0 c g data regexp sourc src if 0 c c 7 src n 8 n c 0 c g data regexp sourc src if 0 c c 7 src i 8 n c 0 if i 0377 n i els src thi ch char n break case d add charact rang to char set char set 0 9 continu don t need rang process case d add charact rang to char set char set char 0 char 0 1 add charact rang to char set char set char 9 1 char char set length continu case s for i int char set length i 0 i if is rewhit space i add charact to char set char set char i continu case s for i int char set length i 0 i if is rewhit space i add charact to char set char set char i continu case w for i int char set length i 0 i if is word char i add charact to char set char set char i continu case w for i int char set length i 0 i if is word char i add charact to char set char set char i continu default thi ch c break break default thi ch g data regexp sourc src break if in rang if g data regexp flag jsreg fold 0 add charact rang to char set char set upcas rang start upcas thi ch add charact rang to char set char set downcas rang start downcas thi ch els add charact rang to char set char set rang start thi ch in rang fals els if g data regexp flag jsreg fold 0 add charact to char set char set upcas thi ch add charact to char set char set downcas thi ch els add charact to char set char set thi ch if src end 1 if g data regexp sourc src src in rang true rang start thi ch 
privat static boolean class matcher reglob data g data rechar set char set char ch if char set convert process char set g data char set int byte index ch 8 if char set sens if char set length 0 ch char set length char set bit byte index 1 ch 0x7 0 return fals els if char set length 0 ch char set length char set bit byte index 1 ch 0x7 0 return fals return true 
privat static boolean execut rebytecod reglob data g data char char int end int pc 0 byte program g data regexp program int current continu op int current continu pc boolean result fals current continu pc 0 current continu op reop end if debug system out println input new string char start at g data cp int op program pc for if debug system out println test at g data cp op op switch op case reop empti result true break case reop bol if g data cp 0 if g data multilin g data regexp flag jsreg multilin 0 if is line term char g data cp 1 result fals break els result fals break result true break case reop eol if g data cp end if g data multilin g data regexp flag jsreg multilin 0 if is line term char g data cp result fals break els result fals break result true break case reop wbdry result g data cp 0 is word char g data cp 1 g data cp end is word char g data cp break case reop wnonbdri result g data cp 0 is word char g data cp 1 g data cp end is word char g data cp break case reop dot result g data cp end is line term char g data cp if result g data cp break case reop digit result g data cp end is digit char g data cp if result g data cp break case reop nondigit result g data cp end is digit char g data cp if result g data cp break case reop space result g data cp end is rewhit space char g data cp if result g data cp break case reop nonspac result g data cp end is rewhit space char g data cp if result g data cp break case reop alnum result g data cp end is word char g data cp if result g data cp break case reop nonalnum result g data cp end is word char g data cp if result g data cp break case reop flat int offset get index program pc pc index len int length get index program pc pc index len result flat nmatcher g data offset length char end break case reop flati int offset get index program pc pc index len int length get index program pc pc index len result flat nimatch g data offset length char end break case reop flat1 char match ch char program pc 0x ff result g data cp end char g data cp match ch if result g data cp break case reop flat1i char match ch char program pc 0x ff result g data cp end upcas char g data cp upcas match ch if result g data cp break case reop ucflat1 char match ch char get index program pc pc index len result g data cp end char g data cp match ch if result g data cp break case reop ucflat1i char match ch char get index program pc pc index len result g data cp end upcas char g data cp upcas match ch if result g data cp break case reop alt int nextpc byte nextop push prog state g data 0 0 null current continu pc current continu op nextpc pc get offset program pc nextop program nextpc push back track state g data nextop nextpc pc index len op program pc continu case reop jump int offset reprog state state pop prog state g data current continu pc state continu pc current continu op state continu op offset get offset program pc pc offset op program pc continu case reop lparen int paren index get index program pc pc index len g data set paren paren index g data cp 0 op program pc continu case reop rparen int cap index int paren index get index program pc pc index len cap index g data paren index paren index g data set paren paren index cap index g data cp cap index if paren index g data last paren g data last paren paren index op program pc continu case reop backref int paren index get index program pc pc index len result backref matcher g data paren index char end break case reop class int index get index program pc pc index len if g data cp end if class matcher g data g data regexp class list index char g data cp g data cp result true break result fals break case reop assert case reop assert not byte test op push prog state g data 0 0 g data back track stack top current continu pc current continu op if op reop assert test op reop asserttest els test op reop assertnottest push back track state g data test op pc get offset program pc pc index len op program pc continu case reop asserttest case reop assertnottest reprog state state pop prog state g data g data cp state index g data back track stack top state back track current continu pc state continu pc current continu op state continu op if result if op reop asserttest result true els result fals els if op reop asserttest do noth els result true break case reop star case reop plu case reop opt case reop quant case reop minimalstar case reop minimalplu case reop minimalopt case reop minimalqu int min max boolean greedi fals switch op case reop star greedi true fallthrough case reop minimalstar min 0 max 1 break case reop plu greedi true fallthrough case reop minimalplu min 1 max 1 break case reop opt greedi true fallthrough case reop minimalopt min 0 max 1 break case reop quant greedi true fallthrough case reop minimalqu min get offset program pc pc index len see comment in emit rebytecod for 1 reason max get offset program pc 1 pc index len break default throw kit code bug push prog state g data min max null current continu pc current continu op if greedi current continu op reop repeat current continu pc pc push back track state g data reop repeat pc step over parencount parenindex next pc 3 index len op program pc els if min 0 current continu op reop minimalrepeat current continu pc pc parencount parenindex next pc 3 index len op program pc els push back track state g data reop minimalrepeat pc pop prog state g data pc 2 index len parencount parenindex pc pc get offset program pc op program pc continu case reop endchild us the current continu pc current continu pc op current continu op continu case reop repeat reprog state state pop prog state g data if result there s been a failur see if we have enough children if state min 0 result true current continu pc state continu pc current continu op state continu op pc 2 index len parencount parenindex pc pc get offset program pc break els if state min 0 g data cp state index match an empti string that ll get us nowher result fals current continu pc state continu pc current continu op state continu op pc 2 index len pc pc get offset program pc break int new min state min new max state max if new min 0 new min if new max 1 new max if new max 0 result true current continu pc state continu pc current continu op state continu op pc 2 index len pc pc get offset program pc break push prog state g data new min new max null state continu pc state continu op current continu op reop repeat current continu pc pc push back track state g data reop repeat pc int paren count get index program pc pc index len int paren index get index program pc pc 2 index len op program pc for int k 0 k paren count k g data set paren paren index k 1 0 continu case reop minimalrepeat reprog state state pop prog state g data if result non greedi failur try to consum anoth child if state max 1 state max 0 push prog state g data state min state max null state continu pc state continu op current continu op reop minimalrepeat current continu pc pc int paren count get index program pc pc index len int paren index get index program pc pc 2 index len for int k 0 k paren count k g data set paren paren index k 1 0 op program pc continu els don t need to adjust pc sinc we re go to pop current continu pc state continu pc current continu op state continu op break els if state min 0 g data cp state index match an empti string that ll get us nowher result fals current continu pc state continu pc current continu op state continu op break int new min state min new max state max if new min 0 new min if new max 1 new max push prog state g data new min new max null state continu pc state continu op if new min 0 current continu op reop minimalrepeat current continu pc pc int paren count get index program pc pc index len int paren index get index program pc pc 2 index len for int k 0 k paren count k g data set paren paren index k 1 0 op program pc els current continu pc state continu pc current continu op state continu op push back track state g data reop minimalrepeat pc pop prog state g data pc 2 index len pc pc get offset program pc op program pc continu case reop end return true default throw kit code bug if the match fail and there s a backtrack option take it otherwis thi is a complet and utter failur if result reback track data back track data g data back track stack top if back track data null g data back track stack top back track data previou g data last paren back track data last paren xxx if back track data will no longer be us then there is no need to clone back track data paren if back track data paren null g data paren long back track data paren clone g data cp back track data cp g data state stack top back track data state stack top current continu op g data state stack top continu op current continu pc g data state stack top continu pc pc back track data continu pc op back track data continu op continu els return fals op program pc 
privat static boolean match reg exp reglob data g data recompil re char char int start int end boolean multilin if re paren count 0 g data paren new long re paren count els g data paren null g data back track stack top null g data state stack top null g data multilin multilin g data regexp re g data last paren 0 int anchor ch g data regexp anchor ch have to includ the posit beyond the last charact in order to detect end of input line condit for int i start i end i if the first node is a liter match step the index into the string until that match is made or fail if it can t be found at all if anchor ch 0 for if i end return fals char match ch char i if match ch anchor ch g data regexp flag jsreg fold 0 upcas match ch upcas char anchor ch break i g data cp i for int j 0 j re paren count j g data set paren j 1 0 boolean result execut rebytecod g data char end g data back track stack top null g data state stack top null if result g data skip i start return true return fals 
object execut reg exp context cx scriptabl scope obj reg exp impl re string str int indexp int match type reglob data g data new reglob data int start indexp 0 char char arrai str to char arrai int end char arrai length if start end start end call the recurs matcher to do the real work boolean match match reg exp g data re char arrai start end re multilin if match if match type prefix return null return undefin instanc int index g data cp int i index indexp 0 i int matchlen i start g data skip int ep index index matchlen object result scriptabl obj if match type test test for a match and updat cx reg exp impl don t alloc an arrai object do return true result boolean true obj null els the arrai return on match ha element 0 bound to the match string element 1 through re paren count bound to the paren match an index properti tell the length of the left context and an input properti refer to the input string scriptabl scope get top level scope scope obj result script runtim new object cx scope arrai null obj scriptabl result string matchstr new string char arrai index matchlen obj put 0 obj matchstr if re paren count 0 re paren null re last paren sub string empti sub string els sub string parsub null int num re paren new sub string re paren count for num 0 num re paren count num int cap index g data paren index num string parstr if cap index 1 int cap length g data paren length num parsub new sub string char arrai cap index cap length re paren num parsub if match type test continu parstr parsub to string obj put num 1 obj parstr els if match type test obj put num 1 obj undefin instanc re last paren parsub if match type test defin the index and input properti last for better for in loop order so thei come after the element obj put index obj new integ start g data skip obj put input obj str if re last match null re last match new sub string re left context new sub string re right context new sub string re last match char arrai char arrai re last match index index re last match length matchlen re left context char arrai char arrai if cx get languag version context version 1 2 js1 2 emul perl4 0 1 8 patch level 36 for global regexp us in scalar context and unintention for the string match list psuedo context on hi there bye the follow would result languag while g print s g perl4 036 hi there hihitherehi thereby perl5 hi hi there hihitherehi thereby js1 2 hi there hihitherethereby insofar as js1 2 alwai defin as left context from the last match for global regexp it wa more consist than perl4 re left context index start re left context length g data skip els for js1 3 and ecmav2 emul perl5 exactli js1 3 hi hi there hihitherehi thereby re left context index 0 re left context length start g data skip re right context char arrai char arrai re right context index ep re right context length end ep return result 
int get flag return re flag 
privat static void report error string messag id string arg string msg script runtim get message1 messag id arg throw script runtim construct error syntax error msg 
max instanc id 5 protect int get max instanc id return max instanc id 
protect int find instanc id info string s int id gener last updat 2001 05 24 12 01 22 gmt 02 00 l0 id 0 string x null int c int s length s length if s length 6 c s char at 0 if c g x global id id global els if c s x sourc id id sourc els if s length 9 c s char at 0 if c l x last index id id last index els if c m x multilin id id multilin els if s length 10 x ignor case id id ignor case if x null x s x equal s id 0 gener string id map if id 0 return super find instanc id info s int attr switch id case id last index attr perman dontenum break case id sourc case id global case id ignor case case id multilin attr perman readonli dontenum break default throw new illeg state except return instanc id info attr id 
protect string get instanc id name int id switch id case id last index return last index case id sourc return sourc case id global return global case id ignor case return ignor case case id multilin return multilin return super get instanc id name id 
protect object get instanc id valu int id switch id case id last index return script runtim wrap number last index case id sourc return new string re sourc case id global return script runtim wrap boolean re flag jsreg glob 0 case id ignor case return script runtim wrap boolean re flag jsreg fold 0 case id multilin return script runtim wrap boolean re flag jsreg multilin 0 return super get instanc id valu id 
protect void set instanc id valu int id object valu if id id last index last index script runtim to number valu return super set instanc id valu id valu 
protect void init prototyp id int id string s int ariti switch id case id compil ariti 1 s compil break case id to string ariti 0 s to string break case id to sourc ariti 0 s to sourc break case id exec ariti 1 s exec break case id test ariti 1 s test break case id prefix ariti 1 s prefix break default throw new illeg argument except string valu of id init prototyp method regexp tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag regexp tag return super exec id call f cx scope thi obj arg int id f method id switch id case id compil return real thi thi obj f compil cx scope arg case id to string case id to sourc return real thi thi obj f to string case id exec return real thi thi obj f exec sub cx scope arg match case id test object x real thi thi obj f exec sub cx scope arg test return boolean true equal x boolean true boolean fals case id prefix return real thi thi obj f exec sub cx scope arg prefix throw new illeg argument except string valu of id 
privat static nativ reg exp real thi scriptabl thi obj id function object f if thi obj instanceof nativ reg exp throw incompat call error f return nativ reg exp thi obj 
string id map protect int find prototyp id string s int id gener last updat 2004 03 17 13 54 21 cet l0 id 0 string x null int c l switch s length case 4 c s char at 0 if c e x exec id id exec els if c t x test id id test break l case 6 x prefix id id prefix break l case 7 x compil id id compil break l case 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string break l if x null x s x equal s id 0 gener return id 
class renod renod byte op thi op op 
compil state char sourc int length int flag thi cpbegin sourc thi cp 0 thi cpend length thi flag flag thi paren count 0 thi class count 0 thi prog length 0 
reprog state reprog state previou int min int max int index reback track data back track int continu pc int continu op thi previou previou thi min min thi max max thi index index thi continu op continu op thi continu pc continu pc thi back track back track 
reback track data reglob data g data int op int pc previou g data back track stack top continu op op continu pc pc last paren g data last paren if g data paren null paren long g data paren clone cp g data cp state stack top g data state stack top 
get start of parenthesi captur content 1 for empti int paren index int i return int paren i 
get length of parenthesi captur content int paren length int i return int paren i 32 
void set paren int i int index int length paren i long index 0xffffffff l long length 32 
rechar set int length int start index int strlength thi length length thi start index start index thi strlength strlength 
privat quit action quit action public global 
public global context cx init cx 
set the action to call from quit public void init quit action quit action quit action if quit action null throw new illeg argument except quit action is null if thi quit action null throw new illeg argument except the method is onc call thi quit action quit action 
public void init context factori factori factori call new context action public object run context cx init cx return null 
factori call new context action public object run context cx init cx return null 
public void init context cx defin some global function particular to the shell note that these function ar not part of ecma init standard object cx seal std lib string name defin class deseri help load load class print quit read file read url run command seal serial spawn sync toint32 version defin function properti name global class scriptabl object dontenum set up environ in the global scope to provid access to the system environ variabl environ defin class thi environ environ new environ thi defin properti environ environ scriptabl object dontenum histori nativ arrai cx new arrai thi 0 defin properti histori histori scriptabl object dontenum initi true 
print a help messag thi method is defin as a java script function public static void help context cx scriptabl thi obj object arg function fun obj print stream out get instanc fun obj get out out println tool error report get messag msg help 
print the string valu of it argument thi method is defin as a java script function note that it argument ar of the vararg form which allow it to handl an arbitrari number of argument suppli to the java script function public static object print context cx scriptabl thi obj object arg function fun obj print stream out get instanc fun obj get out for int i 0 i arg length i if i 0 out print convert the arbitrari java script valu into a string form string s context to string arg i out print s out println return context get undefin valu 
call embed specif quit action pass it argument as int32 exit code thi method is defin as a java script function public static void quit context cx scriptabl thi obj object arg function fun obj global global get instanc fun obj if global quit action null int exit code arg length 0 0 script runtim to int32 arg 0 global quit action quit cx exit code 
get and set the languag version thi method is defin as a java script function public static doubl version context cx scriptabl thi obj object arg function fun obj doubl result doubl cx get languag version if arg length 0 doubl d context to number arg 0 cx set languag version int d return result 
load and execut a set of java script sourc file thi method is defin as a java script function public static void load context cx scriptabl thi obj object arg function fun obj for int i 0 i arg length i main process file cx thi obj context to string arg i 
load a java class that defin a java script object us the convent outlin in scriptabl object defin class p thi method is defin as a java script function except illeg access except if access is not avail to a reflect class member except instanti except if unabl to instanti the name class except invoc target except if an except is thrown dure execut of method of the name class except class definit except if the format of the class caus thi except in scriptabl object defin class see org mozilla javascript scriptabl object defin class public static void defin class context cx scriptabl thi obj object arg function fun obj throw illeg access except instanti except invoc target except class clazz get class arg scriptabl object defin class thi obj clazz 
load and execut a script compil to a class file p thi method is defin as a java script function when call as a java script function a singl argument is expect thi argument should be the name of a class that implement the script interfac as will ani script compil by jsc except illeg access except if access is not avail to the class except instanti except if unabl to instanti the name class except invoc target except if an except is thrown dure execut of method of the name class see org mozilla javascript scriptabl object defin class public static void load class context cx scriptabl thi obj object arg function fun obj throw illeg access except instanti except invoc target except class clazz get class arg if script class is assign from clazz throw report runtim error msg must implement script script script script clazz new instanc script exec cx thi obj 
privat static class get class object arg throw illeg access except instanti except invoc target except if arg length 0 throw report runtim error msg expect string arg object arg0 arg 0 if arg0 instanceof wrapper object wrap wrapper arg0 unwrap if wrap instanceof class return class wrap string class name context to string arg 0 try return class for name class name catch class not found except cnfe throw report runtim error msg class not found class name 
public static void serial context cx scriptabl thi obj object arg function fun obj throw ioexcept if arg length 2 throw context report runtim error expect an object to serial and a filenam to write the serial to object obj arg 0 string filenam context to string arg 1 file output stream fo new file output stream filenam scriptabl scope scriptabl object get top level scope thi obj scriptabl output stream out new scriptabl output stream fo scope out write object obj out close 
public static object deseri context cx scriptabl thi obj object arg function fun obj throw ioexcept class not found except if arg length 1 throw context report runtim error expect a filenam to read the serial from string filenam context to string arg 0 file input stream fi new file input stream filenam scriptabl scope scriptabl object get top level scope thi obj object input stream in new scriptabl input stream fi scope object deseri in read object in close return context to object deseri scope 
the spawn function run a given function or script in a differ thread js function g a 7 js a 3 3 js spawn g thread thread 1 5 main js a 3 public static object spawn context cx scriptabl thi obj object arg function fun obj scriptabl scope fun obj get parent scope runner runner if arg length 0 arg 0 instanceof function object new arg null if arg length 1 arg 1 instanceof scriptabl new arg cx get element scriptabl arg 1 if new arg null new arg script runtim empti arg runner new runner scope function arg 0 new arg els if arg length 0 arg 0 instanceof script runner new runner scope script arg 0 els throw report runtim error msg spawn arg runner factori cx get factori thread thread new thread runner thread start return thread 
the sync function creat a synchron function in the sens of a java synchron method from an exist function the new function synchron on the code thi code object of it invoc js var o f sync function x print entri packag java lang thread sleep x 1000 print exit js spawn function o f 5 thread thread 0 5 main entri js spawn function o f 5 thread thread 1 5 main js exit entri exit public static object sync context cx scriptabl thi obj object arg function fun obj if arg length 1 arg 0 instanceof function return new synchron function arg 0 els throw report runtim error msg sync arg 
execut the specifi command with the given argument and option as a separ process and return the exit statu of the process p usag pre run command command run command command arg1 arg n run command command arg1 arg n option pre all except the last argument to run command ar convert to string and denot command name and it argument if the last argument is a java script object it is an option object otherwis it is convert to string denot the last argument and option object assum to be empti te follow properti of the option object ar process ul li tt arg tt provid an arrai of addit command argument li tt env tt explicit environ object all it enumerat properti defin the correspond environ variabl name li tt input tt the process input if it is not java io input stream it is convert to string and sent to the process as it input if not specifi no input is provid to the process li tt output tt the process output instead of java lang system out if it is not instanc of java io output stream the process output is read convert to a string append to the output properti valu convert to string and put as the new valu of the output properti li tt err tt the process error output instead of java lang system err if it is not instanc of java io output stream the process error output is read convert to a string append to the err properti valu convert to string and put as the new valu of the err properti ul public static object run command context cx scriptabl thi obj object arg function fun obj throw ioexcept int l arg length if l 0 l 1 arg 0 instanceof scriptabl throw report runtim error msg run command bad arg input stream in null output stream out null err null byte arrai output stream out byte null err byte null object out obj null err obj null string environ null scriptabl param null object add arg null if arg l 1 instanceof scriptabl param scriptabl arg l 1 l object env obj scriptabl object get properti param env if env obj scriptabl not found if env obj null environ new string 0 els if env obj instanceof scriptabl throw report runtim error msg run command bad env scriptabl env hash scriptabl env obj object id scriptabl object get properti id env hash environ new string id length for int i 0 i id length i object kei obj id i val string kei if kei obj instanceof string kei string kei obj val scriptabl object get properti env hash kei els int ikei number kei obj int valu kei integ to string ikei val scriptabl object get properti env hash ikei if val scriptabl object not found val undefin instanc environ i kei script runtim to string val object in obj scriptabl object get properti param input if in obj scriptabl not found in to input stream in obj out obj scriptabl object get properti param output if out obj scriptabl not found out to output stream out obj if out null out byte new byte arrai output stream out out byte err obj scriptabl object get properti param err if err obj scriptabl not found err to output stream err obj if err null err byte new byte arrai output stream err err byte object add arg obj scriptabl object get properti param arg if add arg obj scriptabl not found scriptabl s context to object add arg obj get top level scope thi obj add arg cx get element s global global get instanc fun obj if out null out global null global get out system out if err null err global null global get err system err if no explicit input stream do not send ani input to process in particular do not us system in to avoid deadlock when wait for user input to send to process which is alreadi termin as it is not alwai possibl to interrupt read method string cmd new string add arg null l l add arg length for int i 0 i l i cmd i script runtim to string arg i if add arg null for int i 0 i add arg length i cmd l i script runtim to string add arg i int exit code run process cmd environ in out err if out byte null string s script runtim to string out obj out byte to string scriptabl object put properti param output s if err byte null string s script runtim to string err obj err byte to string scriptabl object put properti param err s return new integ exit code 
the seal function seal all suppli argument public static void seal context cx scriptabl thi obj object arg function fun obj for int i 0 i arg length i object arg arg i if arg instanceof scriptabl object arg undefin instanc if arg instanceof scriptabl arg undefin instanc throw report runtim error msg shell seal not object els throw report runtim error msg shell seal not scriptabl for int i 0 i arg length i object arg arg i scriptabl object arg seal object 
the read file read the given file context and convert it to a string us the specifi charact code or default charact code if explicit code argument is not given p usag pre read file file path read file file path char code pre the first form convert file s context to string us the default charact code public static object read file context cx scriptabl thi obj object arg function fun obj throw ioexcept if arg length 0 throw report runtim error msg shell read file bad arg string path script runtim to string arg 0 string char code null if arg length 2 char code script runtim to string arg 1 return read url path char code true 
the read url open connect to the given url read all it data and convert them to a string us the specifi charact code or default charact code if explicit code argument is not given p usag pre read url url read url url char code pre the first form convert file s context to string us the default char code public static object read url context cx scriptabl thi obj object arg function fun obj throw ioexcept if arg length 0 throw report runtim error msg shell read url bad arg string url script runtim to string arg 0 string char code null if arg length 2 char code script runtim to string arg 1 return read url url char code fals 
convert the argumnet to int32 number public static object toint32 context cx scriptabl thi obj object arg function fun obj object arg arg length 0 arg 0 undefin instanc if arg instanceof integ return arg return script runtim wrap int script runtim to int32 arg 
public input stream get in return in stream null system in in stream 
public void set in input stream in in stream in 
public print stream get out return out stream null system out out stream 
public void set out print stream out out stream out 
public print stream get err return err stream null system err err stream 
public void set err print stream err err stream err 
public void set seal std lib boolean valu seal std lib valu 
privat static global get instanc function function scriptabl scope function get parent scope if scope instanceof global throw report runtim error msg bad shell function scope string valu of scope return global scope 
if ani of in out err is null the correspond process stream will be close immedi otherwis it will be close as soon as all data will be read from written to process privat static int run process string cmd string environ input stream in output stream out output stream err throw ioexcept process p if environ null p runtim get runtim exec cmd els p runtim get runtim exec cmd environ pipe thread in thread null err thread null try input stream err process null try if err null err process p get error stream els p get error stream close input stream out process null try if out null out process p get input stream els p get input stream close output stream in process null try if in null in process p get output stream els p get output stream close if out null read process output on thi thread if err null err thread new pipe thread true err process err err thread start if in null in thread new pipe thread fals in in process in thread start pipe true out process out els if in null no output read process input on thi thread if err null err thread new pipe thread true err process err err thread start pipe fals in in process in close els if err null no output or input read process err on thi thread pipe true err process err err process close err process null wait for process complet for try p wait for break catch interrupt except ex return p exit valu final pipe will close stream as well but for reliabl duplic it in ani case if in process null in process close final if out process null out process close final if err process null err process close final p destroi if in thread null for try in thread join break catch interrupt except ex if err thread null for try err thread join break catch interrupt except ex 
static void pipe boolean from process input stream from output stream to throw ioexcept try final int size 4096 byte buffer new byte size for int n if from process n from read buffer 0 size els try n from read buffer 0 size catch ioexcept ex ignor except as it can be caus by close pipe break if n 0 break if from process to write buffer 0 n to flush els try to write buffer 0 n to flush catch ioexcept ex ignor except as it can be caus by close pipe break final try if from process from close els to close catch ioexcept ex ignor error on close on window jvm mai throw invalid refrenc except if process termin too fast 
privat static input stream to input stream object valu throw ioexcept input stream is null string s null if valu instanceof wrapper object unwrap wrapper valu unwrap if unwrap instanceof input stream is input stream unwrap els if unwrap instanceof byte is new byte arrai input stream byte unwrap els if unwrap instanceof reader s read reader reader unwrap els if unwrap instanceof char s new string char unwrap if is null if s null s script runtim to string valu is new byte arrai input stream s get byte return is 
privat static output stream to output stream object valu output stream os null if valu instanceof wrapper object unwrap wrapper valu unwrap if unwrap instanceof output stream os output stream unwrap return os 
privat static string read url string file path string char code boolean url is file throw ioexcept int chunk length input stream is null try if url is file url url obj new url file path urlconnect uc url obj open connect is uc get input stream chunk length uc get content length if chunk length 0 chunk length 1024 if char code null string type uc get content type if type null char code get char code from type type els file f new file file path long length f length chunk length int length if chunk length length throw new ioexcept too big file size length if chunk length 0 return is new file input stream f reader r if char code null r new input stream reader is els r new input stream reader is char code return read reader r chunk length final if is null is close 
privat static string get char code from type string type int i type index of if i 0 int end type length i while i end type char at i i string charset charset if charset region match true 0 type i charset length i charset length while i end type char at i i if i end type char at i i while i end type char at i i if i end i is at the start of non empti char code spec while type char at end 1 end return type substr i end return null 
privat static string read reader reader reader throw ioexcept return read reader reader 4096 
privat static string read reader reader reader int initi buffer size throw ioexcept char buffer new char initi buffer size int offset 0 for int n reader read buffer offset buffer length offset if n 0 break offset n if offset buffer length char tmp new char buffer length 2 system arraycopi buffer 0 tmp 0 offset buffer tmp return new string buffer 0 offset 
static runtim except report runtim error string msg id string messag tool error report get messag msg id return context report runtim error messag 
static runtim except report runtim error string msg id string msg arg string messag tool error report get messag msg id msg arg return context report runtim error messag 
runner scriptabl scope function func object arg thi scope scope f func thi arg arg 
runner scriptabl scope script script thi scope scope s script 
public void run factori call thi 
public object run context cx if f null return f call cx scope scope arg els return s exec cx scope 
pipe thread boolean from process input stream from output stream to set daemon true thi from process from process thi from from thi to to 
public void run try global pipe from process from to catch ioexcept ex throw context throw as script runtim ex ex 
static final long serial version uid 924022554283675333l public string get class name return java arrai 
public static nativ java arrai wrap scriptabl scope object arrai return new nativ java arrai scope arrai 
public object unwrap return arrai 
public nativ java arrai scriptabl scope object arrai super scope null script runtim object class class cl arrai get class if cl is arrai throw new runtim except arrai expect thi arrai arrai thi length arrai get length arrai thi cl cl get compon type 
public boolean ha string id scriptabl start return id equal length super ha id start 
public boolean ha int index scriptabl start return 0 index index length 
public object get string id scriptabl start if id equal length return new integ length object result super get id start if result not found scriptabl object ha properti get prototyp id throw context report runtim error2 msg java member not found arrai get class get name id return result 
public object get int index scriptabl start if 0 index index length context cx context get context object obj arrai get arrai index return cx get wrap factori wrap cx thi obj cl return undefin instanc 
public void put string id scriptabl start object valu ignor assign to length it s readonli if id equal length super put id start valu 
public void put int index scriptabl start object valu if 0 index index length arrai set arrai index context js to java valu cl return super put index start valu 
public object get default valu class hint if hint null hint script runtim string class return arrai to string if hint script runtim boolean class return boolean true if hint script runtim number class return script runtim na nobj return thi 
public object get id object result new object length int i length while i 0 result i new integ i return result 
public boolean ha instanc scriptabl valu if valu instanceof wrapper return fals object instanc wrapper valu unwrap return cl is instanc instanc 
public scriptabl get prototyp if prototyp null prototyp scriptabl object get class prototyp thi get parent scope arrai return prototyp 
public class slot 006 extend live connect test public slot 006 super 
super public static void main string arg slot 006 test new slot 006 test start 
public void execut test object test matrix get data arrai for int i 0 i test matrix length i jsobject js object get jsstring object test matrix i for int j 0 j string object test matrix i 1 length j get slot js object j object test matrix i 
public jsobject get jsstring object data return jsobject data 0 
data in thi test contain of java script string object java object with the same string valu return the data arrai public object get data arrai object item0 global eval new string pass new string pass object data arrai item0 return data arrai 
us jsobject get slot to get an index member of a jsobject in thi test the expect class of all object is jsobject xxx propbabl need to add a bunch of unicod charact here param js string the jsobject with index member param slot the index properti to retriev param data object arrai contain the string represent of the expect result of js arrai get slot slot and the jsobjectconstructor of the expect result which allow us to verifi the valu and type of the result object public void get slot jsobject js string int slot object data string except jsobject constructor null class e class null class a class null string result null string e result null try e result new charact string data 1 char at slot to string result string js string get slot slot if result null e class class for name java lang string a class result get class catch except e except js string get slot slot threw e to string file except except e print stack trace final if result null add test case js string get slot slot to string return result e result equal result true e result equal result except els check the string valu of the result add test case js string get slot slot return result e result to string equal result true e result equal result to string except check the class of the result all should be java lang string add test case e class equal a class true e class equal a class except 
search for class cach object in the given scope the method first call link scriptabl object get top level scope scriptabl scope to get the top most scope and then tri to locat associ class cach object in the prototyp chain of the top scope param scope scope to search for class cach object return previous associ class cach object or a new instanc of class cach if no class cach object wa found see associ scriptabl object top scope public static class cach get scriptabl scope class cach cach cach class cach scriptabl object get top scope valu scope akei if cach null xxx warn somehow about wrong cach usag cach new class cach return cach 
associ class cach object with the given top level scope the class cach object can onli be associ with the given scope onc param top scope scope to associ thi class cach object with return true if no prevou class cach object were embed into the scope and thi class cach were successfulli associ or fals otherwis see get scriptabl scope public boolean associ scriptabl object top scope if top scope get parent scope null can onli associ cach with top level scope throw new illeg argument except if thi top scope associ valu akei thi scope top scope return true return fals 
empti cach of gener java class and java reflect inform public synchron void clear cach class tabl new hashtabl java adapt gener class new hashtabl interfac adapt cach null 
check if gener java class and java reflect inform is cach public final boolean is cach enabl return cach is enabl 
set whether to cach some valu p by default the engin will cach the result of tt class get method tt and similar call thi can speed execut dramat but increas the memori footprint also with cach enabl refer mai be held to object past the lifetim of ani real usag p if cach is enabl and thi method is call with a code fals code argument the cach will be empti p cach is enabl by default param enabl if true cach is enabl see clear cach public synchron void set cach enabl boolean enabl if enabl cach is enabl return if enabl clear cach cach is enabl enabl 
deprec the method alwai return fals see set invok optim enabl boolean enabl public boolean is invok optim enabl return fals 
deprec the method doe noth invok optim is no longer us by rhino on modern jdk like 1 4 or 1 5 the disadvatag of the optim like incres memori usag or longer initi time overweight small speed increas that can be gain us gener proxi class to replac reflect public synchron void set invok optim enabl boolean enabl 
intern engin method to return serial number for gener class to ensur name uniqu public final synchron int new class serial number return gener class serial 
object get interfac adapt class cl object result hashtabl cach interfac adapt cach if cach null result null els result cach get cl return result 
synchron void cach interfac adapt class cl object iadapt if cach is enabl if interfac adapt cach null interfac adapt cach new hashtabl interfac adapt cach put cl iadapt 
creat a new ref drv param arg the argument pass to the main method public ref drv string arg super arg set suffix js 
ref drv expect the follow option pre e full path to the java script execut d directori in which test ar instal h path to helper function file jsref js o directori in which log file will be written s list of suit that should be execut pre public static void main string arg ref drv d new ref drv arg d start 
process command line option see com netscap javascript qa driver rhino drv process option public boolean process option int length arg length if arg 0 start with xxx need to verifi that we at least get valid d and h option for int i 0 i arg length i if arg i equal d p d thi test directori arg i end with file separ new file arg i new file arg i file separ p d thi test directori if thi test directori is directori p error thi test directori get absolut path is not a test directori return fals els continu if arg i equal s p s file new string 20 for int j i k 0 j arg length j if arg j start with break file k arg j if arg i equal h p h thi helper string new string arg i thi helper function new file helper string if thi helper function is file p error thi helper function get absolut path file not found return fals p h thi helper function if arg i equal c p c thi code coverag new boolean arg i boolean valu if arg i equal o p o output directori new file arg i file separ if output directori exist output directori is directori p error output directori get absolut path is not a directori return fals if arg i equal p thi opt level integ pars int arg i if arg i equal db thi debug level integ pars int arg i thi opt level 0 if arg i equal e thi execut arg i if arg i equal t string tinderbox arg i if tinderbox equal true tinderbox equal 1 thi tinderbox true els thi tinderbox fals return true els switch arg length case 0 p error specifi locat of java script test return fals case 1 p error specifi locat of java script helper function file return fals case 2 thi test directori arg 0 end with file separ new file arg 0 new file arg 0 file separ thi helper function new file arg 1 if thi test directori is directori p error thi test directori get absolut path is not a directori return fals if thi helper function is file p error thi helper function get absolut path file not found return fals return true default p could not understand argument return fals 
for each test file in each test suit creat a new ref env run the test pars it result and close the ref env public synchron void execut suit test suit suit test environ context test file file p execut suit try for int i 0 i suit size i synchron suit file test file suit element at i if get system inform 0 start with mac context new mac ref env file suit thi mac ref env context run test els context new ref env file suit thi ref env context run test write file result file suit output directori write case result file suit output directori context close context null if file pass suit pass fals catch except e e print stack trace write suit result suit output directori write suit summari suit output directori 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public class data type 016 extend live connect test public data type 016 super 
public static void main string arg data type 016 test new data type 016 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public boolean check byte string v doubl max new doubl byte max valu doubl valu doubl min new doubl byte min valu doubl valu doubl valu new doubl v doubl valu if valu min valu max return true return fals 
public boolean check integ string v doubl max new doubl integ max valu doubl valu doubl min new doubl integ min valu doubl valu doubl valu new doubl v doubl valu if valu min valu max return true return fals 
public boolean check short string v doubl max new doubl short max valu doubl valu doubl min new doubl short min valu doubl valu doubl valu new doubl v doubl valu if valu min valu max return true return fals 
public boolean check float string v doubl max new doubl float max valu doubl valu doubl min new doubl float min valu doubl valu doubl valu new doubl v doubl valu if valu min valu max return true return fals 
public boolean check long string v doubl max new doubl long max valu doubl valu doubl min new doubl long min valu doubl valu doubl valu new doubl v doubl valu if valu min valu max return true return fals 
public boolean check doubl string v doubl max new doubl doubl max valu doubl valu doubl min new doubl doubl min valu doubl valu doubl valu new doubl v doubl valu if valu min valu max return true return fals 
public void execut test for int i 0 i js val length i do setter test dt static set doubl js val i dt static get doubl dt pub static doubl number new doubl js val i number new doubl data type class pub static doubl true do setter test dt static set byte js val i dt static get byte dt pub static byte number new byte new doubl js val i byte valu number new byte data type class pub static byte check byte js val i do setter test dt static set short js val i dt static get short dt pub static short number new short new doubl js val i short valu number new short data type class pub static short check short js val i do setter test dt static set integ js val i dt static get integ dt pub static int number new integ new doubl js val i int valu number new integ data type class pub static int check integ js val i do setter test dt static set float js val i dt static get float dt pub static float number new float new doubl js val i float valu number new float data type class pub static float true do setter test dt static set long js val i dt static get long dt pub static long number new long new doubl js val i long valu number new long data type class pub static long check long js val i 
thi test call a java setter method from java script it verifi that the setter wa call properli in two wai by check the return valu of the getter method and by check the valu of the public field that wa set param setter java method that take an argument and set a valu param js valu java script valu that is pass to the setter param getter java method that return the valu set by setter param field java field that setter chang param e result expect result which should be of some number type param in rang whether or not the valu is in rang for the particular type if not expect a jsexcedept public void do setter test string setter string js valu string getter string field number e result number field valu boolean in rang string set method setter js valu string get method getter doubl expect result in rang new doubl e result doubl valu new doubl field valu doubl valu doubl getter result null object field result null string set result no except string expect set result set result try expect set result in rang no except class for name netscap javascript jsexcept get name from java script call the setter will throw except if in rang global eval set method catch except e set result e get class get name file except e to string final add test case set method expect set result set result file except try from java script call the getter getter result doubl global eval get method from java sript access the field field result doubl global eval field catch except e e print stack trace file except e to string field result e get class get name final add test case valu getter result expect expect result set method expect result equal getter result true expect result equal getter result file except add test case valu field result expect expect result set method expect result equal field result true expect result equal field result file except 
nativ java packag boolean intern usag string packag name class loader class loader thi packag name packag name thi class loader class loader 
deprec nativ java packag is an intern class do not us it directli public nativ java packag string packag name class loader class loader thi fals packag name class loader 
deprec nativ java packag is an intern class do not us it directli public nativ java packag string packag name thi fals packag name context get current context get applic class loader 
public string get class name return java packag 
public boolean ha string id scriptabl start return true 
public boolean ha int index scriptabl start return fals 
public void put string id scriptabl start object valu can t add properti to java packag sorri 
public void put int index scriptabl start object valu throw context report runtim error0 msg pkg int 
public object get string id scriptabl start return get pkg properti id start true 
public object get int index scriptabl start return not found 
need to look for a class by that name void forc packag string name scriptabl scope nativ java packag pkg int end name index of if end 1 end name length string id name substr 0 end object cach super get id thi if cach null cach instanceof nativ java packag pkg nativ java packag cach els string new packag packag name length 0 id packag name id pkg new nativ java packag true new packag class loader script runtim set object proto and parent pkg scope super put id thi pkg if end name length pkg forc packag name substr end 1 scope 
synchron object get pkg properti string name scriptabl start boolean creat pkg object cach super get name start if cach not found return cach string class name packag name length 0 name packag name name context cx context get context class shutter shutter cx get class shutter scriptabl new valu null if shutter null shutter visibl to script class name class cl null if class loader null cl kit class or null class loader class name els cl kit class or null class name if cl null new valu new nativ java class get top level scope thi cl new valu set prototyp get prototyp if new valu null creat pkg nativ java packag pkg pkg new nativ java packag true class name class loader script runtim set object proto and parent pkg get parent scope new valu pkg if new valu null make it avail for fast lookup and share of lazili reflect constructor and static member super put name start new valu return new valu 
public object get default valu class ignor return to string 
public string to string return java packag packag name 
public class live connect drv extend test driver public live connect drv string arg super arg set suffix class 
set suffix class public static void main string arg live connect drv d new live connect drv arg d start 
public boolean process option int length arg length if arg 0 start with xxx need to verifi that we at least get valid d and h option for int i 0 i arg length i if arg i equal d thi test directori arg i end with file separ new file arg i new file arg i file separ if thi test directori is directori p error thi test directori get absolut path is not a directori return fals els continu if arg i equal s file new string 20 for int j i k 0 j arg length j if arg j start with break file k arg j if arg i equal h thi helper function new file arg i if thi helper function is file p error thi helper function get absolut path file not found return fals if arg i equal o string odir arg i output directori new file odir end with file separ odir odir file separ output directori mkdir if output directori exist output directori is directori p error output directori get absolut path could not creat directori return fals if arg i equal p opt level integ pars int arg i if arg i equal db debug level integ pars int arg i opt level 0 if arg i equal e execut arg i return true els switch arg length case 0 p error specifi locat of java script test return fals case 1 p error specifi locat of java script helper function file return fals case 2 thi test directori arg 0 end with file separ new file arg 0 new file arg 0 file separ thi helper function new file arg 1 if thi test directori is directori p error thi test directori get absolut path is not a directori return fals if thi helper function is file p error thi helper function get absolut path file not found return fals return true default p could not understand argument return fals 
public synchron void execut suit test suit suit p live connect drv execut suit suit name test environ context test file file if execut null gener helper file for int i 0 i suit size i synchron suit file test file suit element at i p file name if execut null context new live connect env file suit thi els context new live rhino env file suit thi synchron context context run test the follow two line ar us by the other test driver but ar not us by live connect drv sinc each live connec test write it result to these log file write file result file suit output directori write case result file suit output directori context close context null if file pass suit pass fals write suit result suit output directori write suit summari suit output directori 
public void gener helper file try thi helper function new file output directori helper js p helper function file is helper function file output stream fo new file output stream helper function fo write var output directori output directori get byte fo write var output file argument 1 get byte fo write var test class name argument 0 get byte fo write var test class eval test class name get byte fo write var testclass new test class get byte fo write testclass run get byte fo write quit get byte fo close catch except e p gener helper file threw e to string e print stack trace 
for each class file in the suit directori creat a test file object for live connect the test class name need to be the name of the class and the file path need to be the full packag name prepend with the java script keyword packag and without the class suffix public void get case test suit suit enabl privileg file dir new file suit file path string file dir list xxx hardcod packag name need to fix thi string filenam packag com netscap javascript qa liveconnect suit name for int i 0 i file length i if file i end with get suffix test file item new test file file i filenam file i substr 0 file i length get suffix length p item file path suit add element item 
public argument nativ call activ thi activ activ scriptabl parent activ get parent scope set parent scope parent set prototyp scriptabl object get object prototyp parent arg activ origin arg length obj new integ arg length nativ function f activ function calle obj f int version f get languag version if version context version 1 3 version context version default caller obj null els caller obj not found 
public string get class name return argument 
public boolean ha int index scriptabl start if 0 index index arg length if arg index not found return true return super ha index start 
public object get int index scriptabl start if 0 index index arg length object valu arg index if valu not found if share with activ index nativ function f activ function string arg name f get param or var name index valu activ get arg name activ if valu not found kit code bug return valu return super get index start 
privat boolean share with activ int index nativ function f activ function int defin count f get param count if index defin count check if argument is not hidden by later argument with the same name as hidden argument ar not share with activ if index defin count 1 string arg name f get param or var name index for int i index 1 i defin count i if arg name equal f get param or var name i return fals return true return fals 
public void put int index scriptabl start object valu if 0 index index arg length if arg index not found if share with activ index string arg name arg name activ function get param or var name index activ put arg name activ valu return synchron thi if arg index not found if arg activ origin arg arg object arg clone arg index valu return super put index start valu 
public void delet int index if 0 index index arg length synchron thi if arg index not found if arg activ origin arg arg object arg clone arg index not found return super delet index 
max instanc id 3 protect int get max instanc id return max instanc id 
protect int find instanc id info string s int id gener last updat 2002 04 09 20 46 33 cest l0 id 0 string x null int c if s length 6 c s char at 5 if c e x calle id id calle els if c h x length id id length els if c r x caller id id caller if x null x s x equal s id 0 gener if id 0 return super find instanc id info s int attr switch id case id calle case id caller case id length attr dontenum break default throw new illeg state except return instanc id info attr id 
protect string get instanc id name int id switch id case id calle return calle case id length return length case id caller return caller return null 
protect object get instanc id valu int id switch id case id calle return calle obj case id length return length obj case id caller object valu caller obj if valu uniqu tag null valu valu null els if valu null nativ call caller activ parent activ call if caller null valu caller get argument caller els valu null return valu return super get instanc id valu id 
protect void set instanc id valu int id object valu switch id case id calle calle obj valu return case id length length obj valu return case id caller caller obj valu null valu uniqu tag null valu return super set instanc id valu id valu 
object get id boolean get all object id super get id get all if get all arg length 0 boolean present null int extra count arg length for int i 0 i id length i object id id i if id instanceof integ int index integ id int valu if 0 index index arg length if present null present new boolean arg length if present index present index true extra count if extra count 0 object tmp new object extra count id length system arraycopi id 0 tmp extra count id length id tmp int offset 0 for int i 0 i arg length i if present null present i id offset new integ i offset if offset extra count kit code bug return id 
public class jsobject eval given a jsobject and some java script code have the object evalu the java script code public static object eval jsobject obj string code obj eval code return null 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public int ambigu char arg return char 
public int ambigu short arg return short 
public int ambigu int arg return int 
public int ambigu long arg return long 
public int ambigu string arg return string 
public int ambigu object arg return object 
public int ambigu boolean arg return boolean object 
return boolean object public int expect return boolean object 
public static void main string arg throw except context cx context enter try scriptabl scope cx init standard object scriptabl object defin class scope counter class scriptabl test counter cx new object scope counter object count scriptabl object get properti test counter count system out println count count count scriptabl object get properti test counter count system out println count count scriptabl object call method test counter reset count new object 0 system out println reset count count scriptabl object get properti test counter count system out println count count final context exit 
construct a class file writer for a class param class name the name of the class to write includ full packag qualif param super class name the name of the superclass of the class to write includ full packag qualif param sourc file name the name of the sourc file to us for produc debug inform or null if debug inform is not desir public class file writer string class name string super class name string sourc file name gener class name class name it constant pool new constant pool thi it thi class index it constant pool add class class name it super class index it constant pool add class super class name if sourc file name null it sourc file name index it constant pool add utf8 sourc file name it flag acc public 
public final string get class name return gener class name 
add an interfac implement by thi class thi method mai be call multipl time for class that implement multipl interfac param interfac name a name of an interfac implement by the class be written includ full packag qualif public void add interfac string interfac name short interfac index it constant pool add class interfac name it interfac add new short interfac index 
set the class s flag flag must be a set of the follow flag bitwis or d togeth acc public acc privat acc protect acc final acc abstract todo check that thi is the appropri set param flag the set of class flag to set public void set flag short flag it flag flag 
static string get slash form string name return name replac 
convert java class name in dot notat into lname with dot replac by slash form suitabl for us as jvm type signatur public static string class name to signatur string name int name length name length int colon po 1 name length char buf new char colon po 1 buf 0 l buf colon po name get char 0 name length buf 1 for int i 1 i colon po i if buf i buf i return new string buf 0 colon po 1 
add a field to the class param field name the name of the field param type the type of the field us param flag the attribut of the field such as acc public etc bitwis or d togeth public void add field string field name string type short flag short field name index it constant pool add utf8 field name short type index it constant pool add utf8 type it field add new class file field field name index type index flag 
add a field to the class param field name the name of the field param type the type of the field us param flag the attribut of the field such as acc public etc bitwis or d togeth param valu an initi integr valu public void add field string field name string type short flag int valu short field name index it constant pool add utf8 field name short type index it constant pool add utf8 type class file field field new class file field field name index type index flag field set attribut it constant pool add utf8 constant valu short 0 short 0 it constant pool add constant valu it field add field 
add a field to the class param field name the name of the field param type the type of the field us param flag the attribut of the field such as acc public etc bitwis or d togeth param valu an initi long valu public void add field string field name string type short flag long valu short field name index it constant pool add utf8 field name short type index it constant pool add utf8 type class file field field new class file field field name index type index flag field set attribut it constant pool add utf8 constant valu short 0 short 2 it constant pool add constant valu it field add field 
add a field to the class param field name the name of the field param type the type of the field us param flag the attribut of the field such as acc public etc bitwis or d togeth param valu an initi doubl valu public void add field string field name string type short flag doubl valu short field name index it constant pool add utf8 field name short type index it constant pool add utf8 type class file field field new class file field field name index type index flag field set attribut it constant pool add utf8 constant valu short 0 short 2 it constant pool add constant valu it field add field 
add inform about java variabl to us when gener the local variabl tabl param name variabl name param type variabl type as bytecod descriptor string param start pc the start bytecod pc where thi variabl is live or 1 if it doe not have a java regist param regist the java regist number of variabl or 1 if it doe not have a java regist public void add variabl descriptor string name string type int start pc int regist int name index it constant pool add utf8 name int descriptor index it constant pool add utf8 type int chunk name index descriptor index start pc regist if it var descriptor null it var descriptor new obj arrai it var descriptor add chunk 
add a method and begin ad code thi method must be call befor other method for ad code except tabl etc can be invok param method name the name of the method param type a string repres the type param flag the attribut of the field such as acc public etc bitwis or d togeth public void start method string method name string type short flag short method name index it constant pool add utf8 method name short type index it constant pool add utf8 type it current method new class file method method name index type index flag it method add it current method 
complet gener of the method after thi method is call no more code can be ad to the method begun with code start method code param max local the maximum number of local variabl slot a k a java regist us by the method param var the arrai of the variabl for the method or null if none public void stop method short max local if it current method null throw new illeg state except no method to stop fix label goto it max local max local int line number tabl length 0 if it line number tabl null 6 byte for the attribut header 2 byte for the line number count 4 byte for each entri line number tabl length 6 2 it line number tabl top 4 int variabl tabl length 0 if it var descriptor null 6 byte for the attribut header 2 byte for the variabl count 10 byte for each entri variabl tabl length 6 2 it var descriptor size 10 int attr length 2 attribut name index 4 attribut length 2 max stack 2 max local 4 code length it code buffer top 2 except tabl length it except tabl top 8 2 attribut count line number tabl length variabl tabl length byte code attribut new byte attr length int index 0 int code attr index it constant pool add utf8 code index put int16 code attr index code attribut index attr length 6 discount the attribut header index put int32 attr length code attribut index index put int16 it max stack code attribut index index put int16 it max local code attribut index index put int32 it code buffer top code attribut index system arraycopi it code buffer 0 code attribut index it code buffer top index it code buffer top if it except tabl top 0 index put int16 it except tabl top code attribut index for int i 0 i it except tabl top i except tabl entri et it except tabl i short start pc short get label pc et it start label short end pc short get label pc et it end label short handler pc short get label pc et it handler label short catch type et it catch type if start pc 1 throw new illeg state except start label not defin if end pc 1 throw new illeg state except end label not defin if handler pc 1 throw new illeg state except handler label not defin index put int16 start pc code attribut index index put int16 end pc code attribut index index put int16 handler pc code attribut index index put int16 catch type code attribut index els write 0 as except tabl length index put int16 0 code attribut index int attribut count 0 if it line number tabl null attribut count if it var descriptor null attribut count index put int16 attribut count code attribut index if it line number tabl null int line number tabl attr index it constant pool add utf8 line number tabl index put int16 line number tabl attr index code attribut index int tabl attr length 2 it line number tabl top 4 index put int32 tabl attr length code attribut index index put int16 it line number tabl top code attribut index for int i 0 i it line number tabl top i index put int32 it line number tabl i code attribut index if it var descriptor null int variabl tabl attr index it constant pool add utf8 local variabl tabl index put int16 variabl tabl attr index code attribut index int var count it var descriptor size int tabl attr length 2 var count 10 index put int32 tabl attr length code attribut index index put int16 var count code attribut index for int i 0 i var count i int chunk int it var descriptor get i int name index chunk 0 int descriptor index chunk 1 int start pc chunk 2 int regist chunk 3 int length it code buffer top start pc index put int16 start pc code attribut index index put int16 length code attribut index index put int16 name index code attribut index index put int16 descriptor index code attribut index index put int16 regist code attribut index it current method set code attribut code attribut it except tabl null it except tabl top 0 it line number tabl top 0 it code buffer top 0 it current method null it max stack 0 it stack top 0 it label tabl top 0 it fixup tabl top 0 it var descriptor null 
add the singl byte opcod to the current method param the op code the opcod of the bytecod public void add int the op code if opcod count the op code 0 throw new illeg argument except unexpect operand int new stack it stack top stack chang the op code if new stack 0 short max valu new stack bad stack new stack if debugcod system out println add bytecod str the op code add to code buffer the op code it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after bytecod str the op code stack it stack top 
add a singl operand opcod to the current method param the op code the opcod of the bytecod param the operand the operand of the bytecod public void add int the op code int the operand if debugcod system out println add bytecod str the op code integ to hex string the operand int new stack it stack top stack chang the op code if new stack 0 short max valu new stack bad stack new stack switch the op code case byte code goto fallthru case byte code ifeq case byte code ifn case byte code iflt case byte code ifg case byte code ifgt case byte code ifl case byte code if icmpeq case byte code if icmpn case byte code if icmplt case byte code if icmpg case byte code if icmpgt case byte code if icmpl case byte code if acmpeq case byte code if acmpn case byte code jsr case byte code ifnul case byte code ifnonnul if the operand 0x80000000 0x80000000 if the operand 0 the operand 65535 throw new illeg argument except bad label for branch int branch pc it code buffer top add to code buffer the op code if the operand 0x80000000 0x80000000 hard displac add to code int16 the operand els a label int target pc get label pc the operand if debuglabel int the label the operand 0x7fffffff system out println fix branch to the label at target pc from branch pc if target pc 1 int offset target pc branch pc add to code int16 offset els add label fixup the operand branch pc 1 add to code int16 0 break case byte code bipush if byte the operand the operand throw new illeg argument except out of rang byte add to code buffer the op code add to code buffer byte the operand break case byte code sipush if short the operand the operand throw new illeg argument except out of rang short add to code buffer the op code add to code int16 the operand break case byte code newarrai if 0 the operand the operand 256 throw new illeg argument except out of rang index add to code buffer the op code add to code buffer the operand break case byte code getfield case byte code putfield if 0 the operand the operand 65536 throw new illeg argument except out of rang field add to code buffer the op code add to code int16 the operand break case byte code ldc case byte code ldc w case byte code ldc2 w if 0 the operand the operand 65536 throw new illeg argument except out of rang index if the operand 256 the op code byte code ldc w the op code byte code ldc2 w if the op code byte code ldc add to code buffer byte code ldc w els add to code buffer the op code add to code int16 the operand els add to code buffer the op code add to code buffer the operand break case byte code ret case byte code iload case byte code lload case byte code fload case byte code dload case byte code aload case byte code istor case byte code lstore case byte code fstore case byte code dstore case byte code astor if 0 the operand the operand 65536 throw new illeg argument except out of rang variabl if the operand 256 add to code buffer byte code wide add to code buffer the op code add to code int16 the operand els add to code buffer the op code add to code buffer the operand break default throw new illeg argument except unexpect opcod for 1 operand it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after bytecod str the op code stack it stack top 
gener the load constant bytecod for the given integ param k the constant public void add load constant int k add byte code ldc it constant pool add constant k 
gener the load constant bytecod for the given long param k the constant public void add load constant long k add byte code ldc2 w it constant pool add constant k 
gener the load constant bytecod for the given float param k the constant public void add load constant float k add byte code ldc it constant pool add constant k 
gener the load constant bytecod for the given doubl param k the constant public void add load constant doubl k add byte code ldc2 w it constant pool add constant k 
gener the load constant bytecod for the given string param k the constant public void add load constant string k add byte code ldc it constant pool add constant k 
add the given two operand bytecod to the current method param the op code the opcod of the bytecod param the operand1 the first operand of the bytecod param the operand2 the second operand of the bytecod public void add int the op code int the operand1 int the operand2 if debugcod system out println add bytecod str the op code integ to hex string the operand1 integ to hex string the operand2 int new stack it stack top stack chang the op code if new stack 0 short max valu new stack bad stack new stack if the op code byte code iinc if 0 the operand1 the operand1 65536 throw new illeg argument except out of rang variabl if 0 the operand2 the operand2 65536 throw new illeg argument except out of rang increment if the operand1 255 the operand2 128 the operand2 127 add to code buffer byte code wide add to code buffer byte code iinc add to code int16 the operand1 add to code int16 the operand2 els add to code buffer byte code wide add to code buffer byte code iinc add to code buffer the operand1 add to code buffer the operand2 els if the op code byte code multianewarrai if 0 the operand1 the operand1 65536 throw new illeg argument except out of rang index if 0 the operand2 the operand2 256 throw new illeg argument except out of rang dimens add to code buffer byte code multianewarrai add to code int16 the operand1 add to code buffer the operand2 els throw new illeg argument except unexpect opcod for 2 operand it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after bytecod str the op code stack it stack top 
public void add int the op code string class name if debugcod system out println add bytecod str the op code class name int new stack it stack top stack chang the op code if new stack 0 short max valu new stack bad stack new stack switch the op code case byte code new case byte code anewarrai case byte code checkcast case byte code instanceof short class index it constant pool add class class name add to code buffer the op code add to code int16 class index break default throw new illeg argument except bad opcod for class refer it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after bytecod str the op code stack it stack top 
public void add int the op code string class name string field name string field type if debugcod system out println add bytecod str the op code class name field name field type int new stack it stack top stack chang the op code char field type char field type char at 0 int field size field type char j field type char d 2 1 switch the op code case byte code getfield case byte code getstat new stack field size break case byte code putstat case byte code putfield new stack field size break default throw new illeg argument except bad opcod for field refer if new stack 0 short max valu new stack bad stack new stack short field ref index it constant pool add field ref class name field name field type add to code buffer the op code add to code int16 field ref index it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after bytecod str the op code stack it stack top 
public void add invok int the op code string class name string method name string method type if debugcod system out println add bytecod str the op code class name method name method type int paramet info size of paramet method type int paramet count paramet info 16 int stack diff short paramet info int new stack it stack top stack diff new stack stack chang the op code adjust for thi if new stack 0 short max valu new stack bad stack new stack switch the op code case byte code invokevirtu case byte code invokespeci case byte code invokestat case byte code invokeinterfac add to code buffer the op code if the op code byte code invokeinterfac short if method ref index it constant pool add interfac method ref class name method name method type add to code int16 if method ref index add to code buffer paramet count 1 add to code buffer 0 els short method ref index it constant pool add method ref class name method name method type add to code int16 method ref index break default throw new illeg argument except bad opcod for method refer it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after bytecod str the op code stack it stack top 
gener code to load the given integ on stack param k the constant public void add push int k if byte k k if k 1 add byte code iconst m1 els if 0 k k 5 add byte byte code iconst 0 k els add byte code bipush byte k els if short k k add byte code sipush short k els add load constant k 
public void add push boolean k add k byte code iconst 1 byte code iconst 0 
gener code to load the given long on stack param k the constant public void add push long k int ik int k if ik k add push ik add byte code i2l els add load constant k 
gener code to load the given doubl on stack param k the constant public void add push doubl k if k 0 0 zero add byte code dconst 0 if 1 0 k 0 neg zero add byte code dneg els if k 1 0 k 1 0 add byte code dconst 1 if k 0 add byte code dneg els add load constant k 
gener the code to leav on stack the given string even if the string encod exe the class file limit for singl string constant param k the constant public void add push string k int length k length int limit it constant pool get utf encod limit k 0 length if limit length add load constant k return split string into pici fit the utf limit and gener code for string buffer sb new string buffer length sb append load constant piec 1 sb append load constant piec n sb to string final string sb java lang string buffer add byte code new sb add byte code dup add push length add invok byte code invokespeci sb init i v int cursor 0 for add byte code dup string s k substr cursor limit add load constant s add invok byte code invokevirtu sb append ljava lang string ljava lang string buffer add byte code pop if limit length break cursor limit limit it constant pool get utf encod limit k limit length add invok byte code invokevirtu sb to string ljava lang string 
check if k fit limit on string constant size impos by class file format param k the string constant public boolean is under string size limit string k return it constant pool is under utf encod limit k 
store integ from stack top into the given local param local number of local regist public void add istor int local xop byte code istor 0 byte code istor local 
store long from stack top into the given local param local number of local regist public void add lstore int local xop byte code lstore 0 byte code lstore local 
store float from stack top into the given local param local number of local regist public void add fstore int local xop byte code fstore 0 byte code fstore local 
store doubl from stack top into the given local param local number of local regist public void add dstore int local xop byte code dstore 0 byte code dstore local 
store object from stack top into the given local param local number of local regist public void add astor int local xop byte code astor 0 byte code astor local 
load integ from the given local into stack param local number of local regist public void add iload int local xop byte code iload 0 byte code iload local 
load long from the given local into stack param local number of local regist public void add lload int local xop byte code lload 0 byte code lload local 
load float from the given local into stack param local number of local regist public void add fload int local xop byte code fload 0 byte code fload local 
load doubl from the given local into stack param local number of local regist public void add dload int local xop byte code dload 0 byte code dload local 
load object from the given local into stack param local number of local regist public void add aload int local xop byte code aload 0 byte code aload local 
load thi into stack public void add load thi add byte code aload 0 
privat void xop int short op int op int local switch local case 0 add short op break case 1 add short op 1 break case 2 add short op 2 break case 3 add short op 3 break default add op local 
public int add tabl switch int low int high if debugcod system out println add bytecod str byte code tableswitch low high if low high throw new illeg argument except bad bound low high int new stack it stack top stack chang byte code tableswitch if new stack 0 short max valu new stack bad stack new stack int entri count high low 1 int pad size 3 it code buffer top 3 it code buffer top 4 int n add reserv code space 1 pad size 4 1 2 entri count int switch start n it code buffer n byte byte code tableswitch while pad size 0 it code buffer n 0 pad size n 4 skip default offset n put int32 low it code buffer n put int32 high it code buffer n it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after bytecod str byte code tableswitch stack it stack top return switch start 
public final void mark tabl switch default int switch start set tabl switch jump switch start 1 it code buffer top 
public final void mark tabl switch case int switch start int case index set tabl switch jump switch start case index it code buffer top 
public final void mark tabl switch case int switch start int case index int stack top if 0 stack top stack top it max stack throw new illeg argument except bad stack index stack top it stack top short stack top set tabl switch jump switch start case index it code buffer top 
public void set tabl switch jump int switch start int case index int jump target if 0 jump target jump target it code buffer top throw new illeg argument except bad jump target jump target if case index 1 throw new illeg argument except bad case index case index int pad size 3 switch start 3 switch start 4 int case offset if case index 0 default label case offset switch start 1 pad size els case offset switch start 1 pad size 4 3 case index if 0 switch start switch start it code buffer top 4 4 pad size 1 throw new illeg argument except switch start is outsid a possibl rang of tableswitch in alreadi gener code if 0x ff it code buffer switch start byte code tableswitch throw new illeg argument except switch start is not offset of tableswitch statement if 0 case offset case offset 4 it code buffer top case index 1 doe not guarante that case offset 0 due to a possibl overflow throw new illeg argument except too big case index case index alert perhap check against case bound put int32 jump target switch start it code buffer case offset 
public int acquir label int top it label tabl top if it label tabl null top it label tabl length if it label tabl null it label tabl new int min label tabl size els int tmp new int it label tabl length 2 system arraycopi it label tabl 0 tmp 0 top it label tabl tmp it label tabl top top 1 it label tabl top 1 return top 0x80000000 
public void mark label int label if label 0 throw new illeg argument except bad label no biscuit label 0x7fffffff if label it label tabl top throw new illeg argument except bad label if it label tabl label 1 throw new illeg state except can onli mark label onc it label tabl label it code buffer top 
public void mark label int label short stack top mark label label it stack top stack top 
public void mark handler int the label it stack top 1 mark label the label 
privat int get label pc int label if label 0 throw new illeg argument except bad label no biscuit label 0x7fffffff if label it label tabl top throw new illeg argument except bad label return it label tabl label 
privat void add label fixup int label int fixup site if label 0 throw new illeg argument except bad label no biscuit label 0x7fffffff if label it label tabl top throw new illeg argument except bad label int top it fixup tabl top if it fixup tabl null top it fixup tabl length if it fixup tabl null it fixup tabl new long min fixup tabl size els long tmp new long it fixup tabl length 2 system arraycopi it fixup tabl 0 tmp 0 top it fixup tabl tmp it fixup tabl top top 1 it fixup tabl top long label 32 fixup site 
privat void fix label goto byte code buffer it code buffer for int i 0 i it fixup tabl top i long fixup it fixup tabl i int label int fixup 32 int fixup site int fixup int pc it label tabl label if pc 1 unloc label throw new runtim except 1 to get delta from instruct start int offset pc fixup site 1 if short offset offset throw new runtim except program too complex too big jump offset code buffer fixup site byte offset 8 code buffer fixup site 1 byte offset it fixup tabl top 0 
get the current offset into the code of the current method return an integ repres the offset public int get current code offset return it code buffer top 
public short get stack top return it stack top 
public void adjust stack top int delta int new stack it stack top delta if new stack 0 short max valu new stack bad stack new stack it stack top short new stack if new stack it max stack it max stack short new stack if debugstack system out println after adjust stack top delta stack it stack top 
privat void add to code buffer int b int n add reserv code space 1 it code buffer n byte b 
privat void add to code int16 int valu int n add reserv code space 2 put int16 valu it code buffer n 
privat int add reserv code space int size if it current method null throw new illeg argument except no method to add to int old top it code buffer top int new top old top size if new top it code buffer length int new size it code buffer length 2 if new top new size new size new top byte tmp new byte new size system arraycopi it code buffer 0 tmp 0 old top it code buffer tmp it code buffer top new top return old top 
public void add except handler int start label int end label int handler label string catch class name if start label 0x80000000 0x80000000 throw new illeg argument except bad start label if end label 0x80000000 0x80000000 throw new illeg argument except bad end label if handler label 0x80000000 0x80000000 throw new illeg argument except bad handler label if catch class name is null us 0 for the catch type index which mean catch everyth even when the verifi ha let you throw someth other than a throwabl short catch type index catch class name null 0 it constant pool add class catch class name except tabl entri new entri new except tabl entri start label end label handler label catch type index int n it except tabl top if n 0 it except tabl new except tabl entri except tabl size els if n it except tabl length except tabl entri tmp new except tabl entri n 2 system arraycopi it except tabl 0 tmp 0 n it except tabl tmp it except tabl n new entri it except tabl top n 1 
public void add line number entri short line number if it current method null throw new illeg argument except no method to stop int n it line number tabl top if n 0 it line number tabl new int line number tabl size els if n it line number tabl length int tmp new int n 2 system arraycopi it line number tabl 0 tmp 0 n it line number tabl tmp it line number tabl n it code buffer top 16 line number it line number tabl top n 1 
write the class file to the output stream param o stream the stream to write to throw ioexcept if write to the stream produc an except public void write output stream o stream throw ioexcept byte arrai to byte arrai o stream write arrai 
privat int get write size int size 0 if it sourc file name index 0 it constant pool add utf8 sourc file size 8 write long file header constant size it constant pool get write size size 2 write short it flag size 2 write short it thi class index size 2 write short it super class index size 2 write short it interfac size size 2 it interfac size size 2 write short it field size for int i 0 i it field size i size class file field it field get i get write size size 2 write short it method size for int i 0 i it method size i size class file method it method get i get write size if it sourc file name index 0 size 2 write short 1 attribut count size 2 write short sourc file attribut name index size 4 write int 2 size 2 write short it sourc file name index els size 2 out write short 0 no attribut return size 
get the class file as arrai of bytesto the output stream public byte to byte arrai int data size get write size byte data new byte data size int offset 0 short sourc file attribut name index 0 if it sourc file name index 0 sourc file attribut name index it constant pool add utf8 sourc file offset put int64 file header constant data offset offset it constant pool write data offset offset put int16 it flag data offset offset put int16 it thi class index data offset offset put int16 it super class index data offset offset put int16 it interfac size data offset for int i 0 i it interfac size i int interfac index short it interfac get i short valu offset put int16 interfac index data offset offset put int16 it field size data offset for int i 0 i it field size i class file field field class file field it field get i offset field write data offset offset put int16 it method size data offset for int i 0 i it method size i class file method method class file method it method get i offset method write data offset if it sourc file name index 0 offset put int16 1 data offset attribut count offset put int16 sourc file attribut name index data offset offset put int32 2 data offset offset put int16 it sourc file name index data offset els offset put int16 0 data offset no attribut if offset data size check get write size is consist with write throw new runtim except return data 
static int put int64 long valu byte arrai int offset offset put int32 int valu 32 arrai offset return put int32 int valu arrai offset 
privat static void bad stack int valu string s if valu 0 s stack underflow valu els s too big stack valu throw new illeg state except s 
privat static int size of paramet string p string int length p string length int right parenthesi p string last index of if 3 length minim signatur take at least 3 char v p string char at 0 1 right parenthesi right parenthesi 1 length boolean ok true int index 1 int stack diff 0 int count 0 string loop while index right parenthesi switch p string char at index default ok fals break string loop case j case d stack diff fall thru case b case s case c case i case z case f stack diff count index continu case index int c p string char at index while c index c p string char at index switch c default ok fals break string loop case j case d case b case s case c case i case z case f stack diff count index continu case l fall thru fall thru case l stack diff count index int semicolon p string index of index if index 1 semicolon semicolon right parenthesi ok fals break string loop index semicolon 1 continu if ok switch p string char at right parenthesi 1 default ok fals break case j case d stack diff fall thru case b case s case c case i case z case f case l case stack diff fall thru case v break if ok return count 16 0x ffff stack diff throw new illeg argument except bad paramet signatur p string 
static int put int16 int valu byte arrai int offset arrai offset 0 byte valu 8 arrai offset 1 byte valu return offset 2 
static int put int32 int valu byte arrai int offset arrai offset 0 byte valu 24 arrai offset 1 byte valu 16 arrai offset 2 byte valu 8 arrai offset 3 byte valu return offset 4 
number of operand accompani the opcod static int opcod count int opcod switch opcod case byte code aaload case byte code aastor case byte code aconst null case byte code aload 0 case byte code aload 1 case byte code aload 2 case byte code aload 3 case byte code areturn case byte code arraylength case byte code astor 0 case byte code astor 1 case byte code astor 2 case byte code astor 3 case byte code athrow case byte code baload case byte code bastor case byte code breakpoint case byte code caload case byte code castor case byte code d2f case byte code d2i case byte code d2l case byte code dadd case byte code daload case byte code dastor case byte code dcmpg case byte code dcmpl case byte code dconst 0 case byte code dconst 1 case byte code ddiv case byte code dload 0 case byte code dload 1 case byte code dload 2 case byte code dload 3 case byte code dmul case byte code dneg case byte code drem case byte code dreturn case byte code dstore 0 case byte code dstore 1 case byte code dstore 2 case byte code dstore 3 case byte code dsub case byte code dup case byte code dup2 case byte code dup2 x1 case byte code dup2 x2 case byte code dup x1 case byte code dup x2 case byte code f2d case byte code f2i case byte code f2l case byte code fadd case byte code faload case byte code fastor case byte code fcmpg case byte code fcmpl case byte code fconst 0 case byte code fconst 1 case byte code fconst 2 case byte code fdiv case byte code fload 0 case byte code fload 1 case byte code fload 2 case byte code fload 3 case byte code fmul case byte code fneg case byte code frem case byte code freturn case byte code fstore 0 case byte code fstore 1 case byte code fstore 2 case byte code fstore 3 case byte code fsub case byte code i2b case byte code i2c case byte code i2d case byte code i2f case byte code i2l case byte code i2 case byte code iadd case byte code iaload case byte code iand case byte code iastor case byte code iconst 0 case byte code iconst 1 case byte code iconst 2 case byte code iconst 3 case byte code iconst 4 case byte code iconst 5 case byte code iconst m1 case byte code idiv case byte code iload 0 case byte code iload 1 case byte code iload 2 case byte code iload 3 case byte code impdep1 case byte code impdep2 case byte code imul case byte code ineg case byte code ior case byte code irem case byte code ireturn case byte code ishl case byte code ishr case byte code istor 0 case byte code istor 1 case byte code istor 2 case byte code istor 3 case byte code isub case byte code iushr case byte code ixor case byte code l2d case byte code l2f case byte code l2i case byte code ladd case byte code laload case byte code land case byte code lastor case byte code lcmp case byte code lconst 0 case byte code lconst 1 case byte code ldiv case byte code lload 0 case byte code lload 1 case byte code lload 2 case byte code lload 3 case byte code lmul case byte code lneg case byte code lor case byte code lrem case byte code lreturn case byte code lshl case byte code lshr case byte code lstore 0 case byte code lstore 1 case byte code lstore 2 case byte code lstore 3 case byte code lsub case byte code lushr case byte code lxor case byte code monitorent case byte code monitorexit case byte code nop case byte code pop case byte code pop2 case byte code return case byte code saload case byte code sastor case byte code swap case byte code wide return 0 case byte code aload case byte code anewarrai case byte code astor case byte code bipush case byte code checkcast case byte code dload case byte code dstore case byte code fload case byte code fstore case byte code getfield case byte code getstat case byte code goto case byte code goto w case byte code ifeq case byte code ifg case byte code ifgt case byte code ifl case byte code iflt case byte code ifn case byte code ifnonnul case byte code ifnul case byte code if acmpeq case byte code if acmpn case byte code if icmpeq case byte code if icmpg case byte code if icmpgt case byte code if icmpl case byte code if icmplt case byte code if icmpn case byte code iload case byte code instanceof case byte code invokeinterfac case byte code invokespeci case byte code invokestat case byte code invokevirtu case byte code istor case byte code jsr case byte code jsr w case byte code ldc case byte code ldc2 w case byte code ldc w case byte code lload case byte code lstore case byte code new case byte code newarrai case byte code putfield case byte code putstat case byte code ret case byte code sipush return 1 case byte code iinc case byte code multianewarrai return 2 case byte code lookupswitch case byte code tableswitch return 1 throw new illeg argument except bad opcod opcod 
the effect on the operand stack of a given opcod static int stack chang int opcod for invok account onli for pop thi unless static ignor paramet and return type switch opcod case byte code dastor case byte code lastor return 4 case byte code aastor case byte code bastor case byte code castor case byte code dcmpg case byte code dcmpl case byte code fastor case byte code iastor case byte code lcmp case byte code sastor return 3 case byte code dadd case byte code ddiv case byte code dmul case byte code drem case byte code dreturn case byte code dstore case byte code dstore 0 case byte code dstore 1 case byte code dstore 2 case byte code dstore 3 case byte code dsub case byte code if acmpeq case byte code if acmpn case byte code if icmpeq case byte code if icmpg case byte code if icmpgt case byte code if icmpl case byte code if icmplt case byte code if icmpn case byte code ladd case byte code land case byte code ldiv case byte code lmul case byte code lor case byte code lrem case byte code lreturn case byte code lstore case byte code lstore 0 case byte code lstore 1 case byte code lstore 2 case byte code lstore 3 case byte code lsub case byte code lxor case byte code pop2 return 2 case byte code aaload case byte code areturn case byte code astor case byte code astor 0 case byte code astor 1 case byte code astor 2 case byte code astor 3 case byte code athrow case byte code baload case byte code caload case byte code d2f case byte code d2i case byte code fadd case byte code faload case byte code fcmpg case byte code fcmpl case byte code fdiv case byte code fmul case byte code frem case byte code freturn case byte code fstore case byte code fstore 0 case byte code fstore 1 case byte code fstore 2 case byte code fstore 3 case byte code fsub case byte code getfield case byte code iadd case byte code iaload case byte code iand case byte code idiv case byte code ifeq case byte code ifg case byte code ifgt case byte code ifl case byte code iflt case byte code ifn case byte code ifnonnul case byte code ifnul case byte code imul case byte code invokeinterfac case byte code invokespeci but need to account for case byte code invokevirtu pop thi unless static case byte code ior case byte code irem case byte code ireturn case byte code ishl case byte code ishr case byte code istor case byte code istor 0 case byte code istor 1 case byte code istor 2 case byte code istor 3 case byte code isub case byte code iushr case byte code ixor case byte code l2f case byte code l2i case byte code lookupswitch case byte code lshl case byte code lshr case byte code lushr case byte code monitorent case byte code monitorexit case byte code pop case byte code putfield case byte code saload case byte code tableswitch return 1 case byte code anewarrai case byte code arraylength case byte code breakpoint case byte code checkcast case byte code d2l case byte code daload case byte code dneg case byte code f2i case byte code fneg case byte code getstat case byte code goto case byte code goto w case byte code i2b case byte code i2c case byte code i2f case byte code i2 case byte code iinc case byte code impdep1 case byte code impdep2 case byte code ineg case byte code instanceof case byte code invokestat case byte code l2d case byte code laload case byte code lneg case byte code newarrai case byte code nop case byte code putstat case byte code ret case byte code return case byte code swap case byte code wide return 0 case byte code aconst null case byte code aload case byte code aload 0 case byte code aload 1 case byte code aload 2 case byte code aload 3 case byte code bipush case byte code dup case byte code dup x1 case byte code dup x2 case byte code f2d case byte code f2l case byte code fconst 0 case byte code fconst 1 case byte code fconst 2 case byte code fload case byte code fload 0 case byte code fload 1 case byte code fload 2 case byte code fload 3 case byte code i2d case byte code i2l case byte code iconst 0 case byte code iconst 1 case byte code iconst 2 case byte code iconst 3 case byte code iconst 4 case byte code iconst 5 case byte code iconst m1 case byte code iload case byte code iload 0 case byte code iload 1 case byte code iload 2 case byte code iload 3 case byte code jsr case byte code jsr w case byte code ldc case byte code ldc w case byte code multianewarrai case byte code new case byte code sipush return 1 case byte code dconst 0 case byte code dconst 1 case byte code dload case byte code dload 0 case byte code dload 1 case byte code dload 2 case byte code dload 3 case byte code dup2 case byte code dup2 x1 case byte code dup2 x2 case byte code lconst 0 case byte code lconst 1 case byte code ldc2 w case byte code lload case byte code lload 0 case byte code lload 1 case byte code lload 2 case byte code lload 3 return 2 throw new illeg argument except bad opcod opcod 
privat static string bytecod str int code if debugstack debugcod switch code case byte code nop return nop case byte code aconst null return aconst null case byte code iconst m1 return iconst m1 case byte code iconst 0 return iconst 0 case byte code iconst 1 return iconst 1 case byte code iconst 2 return iconst 2 case byte code iconst 3 return iconst 3 case byte code iconst 4 return iconst 4 case byte code iconst 5 return iconst 5 case byte code lconst 0 return lconst 0 case byte code lconst 1 return lconst 1 case byte code fconst 0 return fconst 0 case byte code fconst 1 return fconst 1 case byte code fconst 2 return fconst 2 case byte code dconst 0 return dconst 0 case byte code dconst 1 return dconst 1 case byte code bipush return bipush case byte code sipush return sipush case byte code ldc return ldc case byte code ldc w return ldc w case byte code ldc2 w return ldc2 w case byte code iload return iload case byte code lload return lload case byte code fload return fload case byte code dload return dload case byte code aload return aload case byte code iload 0 return iload 0 case byte code iload 1 return iload 1 case byte code iload 2 return iload 2 case byte code iload 3 return iload 3 case byte code lload 0 return lload 0 case byte code lload 1 return lload 1 case byte code lload 2 return lload 2 case byte code lload 3 return lload 3 case byte code fload 0 return fload 0 case byte code fload 1 return fload 1 case byte code fload 2 return fload 2 case byte code fload 3 return fload 3 case byte code dload 0 return dload 0 case byte code dload 1 return dload 1 case byte code dload 2 return dload 2 case byte code dload 3 return dload 3 case byte code aload 0 return aload 0 case byte code aload 1 return aload 1 case byte code aload 2 return aload 2 case byte code aload 3 return aload 3 case byte code iaload return iaload case byte code laload return laload case byte code faload return faload case byte code daload return daload case byte code aaload return aaload case byte code baload return baload case byte code caload return caload case byte code saload return saload case byte code istor return istor case byte code lstore return lstore case byte code fstore return fstore case byte code dstore return dstore case byte code astor return astor case byte code istor 0 return istor 0 case byte code istor 1 return istor 1 case byte code istor 2 return istor 2 case byte code istor 3 return istor 3 case byte code lstore 0 return lstore 0 case byte code lstore 1 return lstore 1 case byte code lstore 2 return lstore 2 case byte code lstore 3 return lstore 3 case byte code fstore 0 return fstore 0 case byte code fstore 1 return fstore 1 case byte code fstore 2 return fstore 2 case byte code fstore 3 return fstore 3 case byte code dstore 0 return dstore 0 case byte code dstore 1 return dstore 1 case byte code dstore 2 return dstore 2 case byte code dstore 3 return dstore 3 case byte code astor 0 return astor 0 case byte code astor 1 return astor 1 case byte code astor 2 return astor 2 case byte code astor 3 return astor 3 case byte code iastor return iastor case byte code lastor return lastor case byte code fastor return fastor case byte code dastor return dastor case byte code aastor return aastor case byte code bastor return bastor case byte code castor return castor case byte code sastor return sastor case byte code pop return pop case byte code pop2 return pop2 case byte code dup return dup case byte code dup x1 return dup x1 case byte code dup x2 return dup x2 case byte code dup2 return dup2 case byte code dup2 x1 return dup2 x1 case byte code dup2 x2 return dup2 x2 case byte code swap return swap case byte code iadd return iadd case byte code ladd return ladd case byte code fadd return fadd case byte code dadd return dadd case byte code isub return isub case byte code lsub return lsub case byte code fsub return fsub case byte code dsub return dsub case byte code imul return imul case byte code lmul return lmul case byte code fmul return fmul case byte code dmul return dmul case byte code idiv return idiv case byte code ldiv return ldiv case byte code fdiv return fdiv case byte code ddiv return ddiv case byte code irem return irem case byte code lrem return lrem case byte code frem return frem case byte code drem return drem case byte code ineg return ineg case byte code lneg return lneg case byte code fneg return fneg case byte code dneg return dneg case byte code ishl return ishl case byte code lshl return lshl case byte code ishr return ishr case byte code lshr return lshr case byte code iushr return iushr case byte code lushr return lushr case byte code iand return iand case byte code land return land case byte code ior return ior case byte code lor return lor case byte code ixor return ixor case byte code lxor return lxor case byte code iinc return iinc case byte code i2l return i2l case byte code i2f return i2f case byte code i2d return i2d case byte code l2i return l2i case byte code l2f return l2f case byte code l2d return l2d case byte code f2i return f2i case byte code f2l return f2l case byte code f2d return f2d case byte code d2i return d2i case byte code d2l return d2l case byte code d2f return d2f case byte code i2b return i2b case byte code i2c return i2c case byte code i2 return i2 case byte code lcmp return lcmp case byte code fcmpl return fcmpl case byte code fcmpg return fcmpg case byte code dcmpl return dcmpl case byte code dcmpg return dcmpg case byte code ifeq return ifeq case byte code ifn return ifn case byte code iflt return iflt case byte code ifg return ifg case byte code ifgt return ifgt case byte code ifl return ifl case byte code if icmpeq return if icmpeq case byte code if icmpn return if icmpn case byte code if icmplt return if icmplt case byte code if icmpg return if icmpg case byte code if icmpgt return if icmpgt case byte code if icmpl return if icmpl case byte code if acmpeq return if acmpeq case byte code if acmpn return if acmpn case byte code goto return goto case byte code jsr return jsr case byte code ret return ret case byte code tableswitch return tableswitch case byte code lookupswitch return lookupswitch case byte code ireturn return ireturn case byte code lreturn return lreturn case byte code freturn return freturn case byte code dreturn return dreturn case byte code areturn return areturn case byte code return return return case byte code getstat return getstat case byte code putstat return putstat case byte code getfield return getfield case byte code putfield return putfield case byte code invokevirtu return invokevirtu case byte code invokespeci return invokespeci case byte code invokestat return invokestat case byte code invokeinterfac return invokeinterfac case byte code new return new case byte code newarrai return newarrai case byte code anewarrai return anewarrai case byte code arraylength return arraylength case byte code athrow return athrow case byte code checkcast return checkcast case byte code instanceof return instanceof case byte code monitorent return monitorent case byte code monitorexit return monitorexit case byte code wide return wide case byte code multianewarrai return multianewarrai case byte code ifnul return ifnul case byte code ifnonnul return ifnonnul case byte code goto w return goto w case byte code jsr w return jsr w case byte code breakpoint return breakpoint case byte code impdep1 return impdep1 case byte code impdep2 return impdep2 return 
final char get char buffer int minim size if minim size tmp char buffer length int new size tmp char buffer length 2 if minim size new size new size minim size tmp char buffer new char new size return tmp char buffer 
except tabl entri int start label int end label int handler label short catch type it start label start label it end label end label it handler label handler label it catch type catch type 
class file field short name index short type index short flag it name index name index it type index type index it flag flag it ha attribut fals 
void set attribut short attr1 short attr2 short attr3 int index it ha attribut true it attr1 attr1 it attr2 attr2 it attr3 attr3 it index index 
int write byte data int offset offset class file writer put int16 it flag data offset offset class file writer put int16 it name index data offset offset class file writer put int16 it type index data offset if it ha attribut write 0 attribut offset class file writer put int16 0 data offset els offset class file writer put int16 1 data offset offset class file writer put int16 it attr1 data offset offset class file writer put int16 it attr2 data offset offset class file writer put int16 it attr3 data offset offset class file writer put int16 it index data offset return offset 
int get write size int size 2 3 if it ha attribut size 2 els size 2 2 4 return size 
class file method short name index short type index short flag it name index name index it type index type index it flag flag 
void set code attribut byte code attribut it code attribut code attribut 
int write byte data int offset offset class file writer put int16 it flag data offset offset class file writer put int16 it name index data offset offset class file writer put int16 it type index data offset code attribut onli offset class file writer put int16 1 data offset system arraycopi it code attribut 0 data offset it code attribut length offset it code attribut length return offset 
int get write size return 2 4 it code attribut length 
constant pool class file writer cfw thi cfw cfw it top index 1 the zero th entri is reserv it pool new byte constant pool size it top 0 
int write byte data int offset offset class file writer put int16 short it top index data offset system arraycopi it pool 0 data offset it top offset it top return offset 
int get write size return 2 it top 
int add constant int k ensur 5 it pool it top constant integ it top class file writer put int32 k it pool it top return short it top index 
int add constant long k ensur 9 it pool it top constant long it top class file writer put int64 k it pool it top int index it top index it top index 2 return index 
int add constant float k ensur 5 it pool it top constant float int bit float float to int bit k it top class file writer put int32 bit it pool it top return it top index 
int add constant doubl k ensur 9 it pool it top constant doubl long bit doubl doubl to long bit k it top class file writer put int64 bit it pool it top int index it top index it top index 2 return index 
int add constant string k int utf8index 0x ffff add utf8 k int the index it string const hash get int utf8index 1 if the index 1 the index it top index ensur 3 it pool it top constant string it top class file writer put int16 utf8index it pool it top it string const hash put utf8index the index return the index 
boolean is under utf encod limit string s int str len s length if str len 3 max utf encod size return true els if str len max utf encod size return fals return str len get utf encod limit s 0 str len 
get maximum i such that tt start i end tt and tt s substr start i tt fit jvm utf string encod limit int get utf encod limit string s int start int end if end start 3 max utf encod size return end int limit max utf encod size for int i start i end i int c s char at i if 0 c c 0x7f limit els if c 0x7ff limit 2 els limit 3 if limit 0 return i return end 
short add utf8 string k int the index it utf8hash get k 1 if the index 1 int str len k length boolean too big string if str len max utf encod size too big string true els too big string fals ask for worst case scenario buffer when each char take 3 byte ensur 1 2 str len 3 int top it top it pool top constant utf8 top 2 skip length char char cfw get char buffer str len k get char 0 str len char 0 for int i 0 i str len i int c char i if c 0 c 0x7f it pool top byte c els if c 0x7ff it pool top byte 0x e0 c 12 it pool top byte 0x80 c 6 0x3f it pool top byte 0x80 c 0x3f els it pool top byte 0x c0 c 6 it pool top byte 0x80 c 0x3f int utf len top it top 1 2 if utf len max utf encod size too big string true els write back length it pool it top 1 byte utf len 8 it pool it top 2 byte utf len it top top the index it top index it utf8hash put k the index if too big string throw new illeg argument except too big string return short the index 
privat short add name and type string name string type short name index add utf8 name short type index add utf8 type ensur 5 it pool it top constant name and type it top class file writer put int16 name index it pool it top it top class file writer put int16 type index it pool it top return short it top index 
short add class string class name int the index it class hash get class name 1 if the index 1 string slash class name if class name index of 0 slash class file writer get slash form class name the index it class hash get slash 1 if the index 1 it class hash put class name the index if the index 1 int utf8index add utf8 slash ensur 3 it pool it top constant class it top class file writer put int16 utf8index it pool it top the index it top index it class hash put slash the index if class name slash it class hash put class name the index return short the index 
short add field ref string class name string field name string field type field or method ref ref new field or method ref class name field name field type int the index it field ref hash get ref 1 if the index 1 short nt index add name and type field name field type short class index add class class name ensur 5 it pool it top constant fieldref it top class file writer put int16 class index it pool it top it top class file writer put int16 nt index it pool it top the index it top index it field ref hash put ref the index return short the index 
short add method ref string class name string method name string method type field or method ref ref new field or method ref class name method name method type int the index it method ref hash get ref 1 if the index 1 short nt index add name and type method name method type short class index add class class name ensur 5 it pool it top constant methodref it top class file writer put int16 class index it pool it top it top class file writer put int16 nt index it pool it top the index it top index it method ref hash put ref the index return short the index 
short add interfac method ref string class name string method name string method type short nt index add name and type method name method type short class index add class class name ensur 5 it pool it top constant interfac methodref it top class file writer put int16 class index it pool it top it top class file writer put int16 nt index it pool it top return short it top index 
void ensur int how much if it top how much it pool length int new capac it pool length 2 if it top how much new capac new capac it top how much byte tmp new byte new capac system arraycopi it pool 0 tmp 0 it top it pool tmp 
field or method ref string class name string name string type thi class name class name thi name name thi type type 
public boolean equal object obj if obj instanceof field or method ref return fals field or method ref x field or method ref obj return class name equal x class name name equal x name type equal x type 
public int hash code if hash code 1 int h1 class name hash code int h2 name hash code int h3 type hash code hash code h1 h2 h3 return hash code 
static void init scriptabl scope boolean seal nativ script obj new nativ script null obj export as jsclass max prototyp id scope seal 
privat nativ script script script thi script script 
return the name of thi java script class script public string get class name return script 
public object call context cx scriptabl scope scriptabl thi obj object arg if script null return script exec cx scope return undefin instanc 
public scriptabl construct context cx scriptabl scope object arg throw context report runtim error0 msg script is not constructor 
public int get length return 0 
public int get ariti return 0 
string decompil int indent int flag if script instanceof nativ function return nativ function script decompil indent flag return super decompil indent flag 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 0 s to string break case id exec ariti 0 s exec break case id compil ariti 1 s compil break default throw new illeg argument except string valu of id init prototyp method script tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag script tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor string sourc arg length 0 script runtim to string arg 0 script script compil cx sourc nativ script nscript new nativ script script script runtim set object proto and parent nscript scope return nscript case id to string nativ script real real thi thi obj f script real script real script if real script null return return cx decompil script real script 0 case id exec throw context report runtim error1 msg cant call indirect exec case id compil nativ script real real thi thi obj f string sourc script runtim to string arg 0 real script compil cx sourc return real throw new illeg argument except string valu of id 
privat static nativ script real thi scriptabl thi obj id function object f if thi obj instanceof nativ script throw incompat call error f return nativ script thi obj 
privat static script compil context cx string sourc int linep 0 string filenam context get sourc posit from stack linep if filenam null filenam script object linep 0 1 error report report report default error report for eval cx get error report return cx compil string sourc null report filenam linep 0 null 
protect int find prototyp id string s int id gener last updat 2001 05 23 13 25 01 gmt 02 00 l0 id 0 string x null l switch s length case 4 x exec id id exec break l case 7 x compil id id compil break l case 8 x to string id id to string break l case 11 x constructor id id constructor break l if x null x s x equal s id 0 gener return id 
wrap the object p the valu return must be on of ul li java lang boolean li li java lang string li li java lang number li li org mozilla javascript scriptabl object li li the valu return by context get undefin valu li li null li ul param cx the current context for thi thread param scope the scope of the execut script param obj the object to be wrap note it can be null param static type type hint if secur restrict prevent to wrap object base on it class static type will be us instead return the wrap valu public object wrap context cx scriptabl scope object obj class static type if obj null obj undefin instanc obj instanceof scriptabl return obj if static type null static type is primit if static type void type return undefin instanc if static type charact type return new integ int charact obj char valu return obj if is java primit wrap if obj instanceof string obj instanceof number obj instanceof boolean return obj els if obj instanceof charact return string valu of charact obj char valu class cl obj get class if cl is arrai return nativ java arrai wrap scope obj return wrap as java object cx scope obj static type 
wrap an object newli creat by a constructor call param cx the current context for thi thread param scope the scope of the execut script param obj the object to be wrap return the wrap valu public scriptabl wrap new object context cx scriptabl scope object obj if obj instanceof scriptabl return scriptabl obj class cl obj get class if cl is arrai return nativ java arrai wrap scope obj return wrap as java object cx scope obj null 
wrap java object as scriptabl instanc to allow full access to it method and field from java script p link wrap context scriptabl object class and link wrap new object context scriptabl object call thi method when thei can not convert tt java object tt to java script primit valu or java script arrai p subclass can overrid the method to provid custom wrapper for java object param cx the current context for thi thread param scope the scope of the execut script param java object the object to be wrap param static type type hint if secur restrict prevent to wrap object base on it class static type will be us instead return the wrap valu which shall not be null public scriptabl wrap as java object context cx scriptabl scope object java object class static type scriptabl wrap wrap new nativ java object scope java object static type return wrap 
return code fals code if result of java method which is instanc of code string code code number code code boolean code and code charact code should be us directli as java script primit type by default the method return true to indic that instanc of code string code code number code code boolean code and code charact code should be wrap as ani other java object and script can access ani java method avail in these object us link set java primit wrap boolean to chang thi public final boolean is java primit wrap return java primit wrap 
see is java primit wrap public final void set java primit wrap boolean valu context cx context get current context if cx null cx is seal context on seal mutat java primit wrap valu 
public static final object instanc new undefin privat undefin 
public object read resolv return instanc 
static final long serial version uid 6461524852170711724l public not afunct except 
public node transform 
public final void transform script or fn node tree transform compil unit tree for int i 0 i tree get function count i function node fn tree get function node i transform fn 
privat void transform compil unit script or fn node tree loop new obj arrai loop end new obj arrai to save against upcheck if no final block ar us ha final fals transform compil unit r tree tree 
privat void transform compil unit r final script or fn node tree final node parent node node null sibl loop for node previou null if node null node parent get first child els previou node node node get next if node null break int type node get type switch type case token label case token switch case token loop loop push node loop end push node jump node target break case token with loop push node node leav node get next if leav get type token leavewith kit code bug loop end push leav break case token try node jump jump node jump node node finallytarget jump get final if finallytarget null ha final true loop push node loop end push finallytarget break case token target case token leavewith if loop end is empti loop end peek node loop end pop loop pop break case token return if we didn t support try final it wouldn t be necessari to put leavewith node here but as we do need a seri of jsr final node befor each return we need to ensur that each final block get the correct scope which could mean that some leavewith node ar necessari if ha final break skip the whole mess node unwind block null for int i loop size 1 i 0 i node n node loop get i int elemtyp n get type if elemtyp token try elemtyp token with node unwind if elemtyp token try node jump jsrnode new node jump token jsr node jsrtarget node jump n get final jsrnode target jsrtarget unwind jsrnode els unwind new node token leavewith if unwind block null unwind block new node token block node get lineno unwind block add child to back unwind if unwind block null node return node node node return expr return node get first child node replac current parent previou node unwind block if return expr null unwind block add child to back return node els node store new node token expr result return expr unwind block add child to front store return node new node token return result unwind block add child to back return node transform return express transform compil unit r tree store skip transform compil unit r to avoid infinit loop continu sibl loop break case token break case token continu node jump jump node jump node node jump jump statement jump get jump statement if jump statement null kit code bug for int i loop size if i 0 parser irfactori ensur that break continu alwai ha a jump statement associ with it which should be found throw kit code bug i node n node loop get i if n jump statement break int elemtyp n get type if elemtyp token with node leav new node token leavewith previou add befor current parent previou node leav els if elemtyp token try node jump try node node jump n node jump jsr final new node jump token jsr jsr final target try node get final previou add befor current parent previou node jsr final if type token break jump target jump statement target els jump target jump statement get continu jump set type token goto break case token call visit call node tree break case token new visit new node tree break case token var node result new node token block for node cursor node get first child cursor null move cursor to next befor creat assign get chanc to chang n next node n cursor if n get type token name kit code bug cursor cursor get next if n ha children continu node init n get first child n remov child init n set type token bindnam n new node token setnam n init node pop new node token expr void n node get lineno result add child to back pop node replac current parent previou node result break case token name case token setnam case token delprop turn name to var for faster access if possibl if tree get type token function function node tree requir activ break node name sourc if type token name name sourc node els name sourc node get first child if name sourc get type token bindnam if type token delprop break throw kit code bug string name name sourc get string if tree ha param or var name if type token name node set type token getvar els if type token setnam node set type token setvar name sourc set type token string els if type token delprop local variabl ar by definit perman node n new node token fals node replac current parent previou node n els throw kit code bug break transform compil unit r tree node 
protect void visit new node node script or fn node tree 
protect void visit call node node script or fn node tree 
privat static node add befor current node parent node previou node current node to add if previou null if current parent get first child kit code bug parent add child to front to add els if current previou get next kit code bug parent add child after to add previou return to add 
privat static node replac current node parent node previou node current node replac if previou null if current parent get first child kit code bug parent replac child current replac els if previou next current check cach prev next current is necessari due to possibl tree mutat parent replac child after previou replac els parent replac child current replac return replac 
public static doubl pub doubl represent 0 2134 public doubl doubl valu return pub doubl represent 
public int to number return pub number represent 
overrid boolean valu public boolean boolean valu return pub boolean represent 
overrid to string public string to string return pub string represent 
data type class instanc public static jsobject static get jsobject return pub static jsobject 
public jsobject get jsobject return pub jsobject 
return pub jsobject public static void static set jsobject jsobject jso pub static jsobject jso 
pub static jsobject jso public void set jsobject jsobject jso pub jsobject jso 
public jsobject creat jsobject arrai int length pub jsobject arrai new jsobject length return pub jsobject arrai 
public static jsobject static creat jsobject arrai int length pub static jsobject arrai new jsobject length return pub static jsobject arrai 
privat protect domain domain loader class loader parent protect domain domain super parent null parent get system class loader thi domain domain 
public class defin class string name byte data return super defin class name data 0 data length domain 
public void link class class cl resolv class cl 
the moment of constructor invoc context permiss protect domain static domain context access control get context if static domain null stati permiss static domain get permiss set read onli 
public void add permiss permiss throw new runtim except not implement 
public boolean impli permiss permiss if stati permiss null if stati permiss impli permiss return fals try context check permiss permiss return true catch access control except ex return fals 
public enumer element return new enumer public boolean ha more element return fals public object next element return null 
return new enumer public boolean ha more element return fals 
return new enumer public boolean ha more element return fals public object next element return null 
public string to string string buffer sb new string buffer sb append get class get name sb append sb append integ to hex string system ident hash code thi sb append context sb append context sb append static permit sb append stati permiss sb append return sb to string 
public java polici secur to trigger error on jdk 1 1 with lazi load new code sourc null java secur cert certif null 
protect void call process file secur final context cx final scriptabl scope final string filenam access control do privileg new privileg action public object run url url get url obj filenam protect domain static domain get url domain url main process file secur cx scope url to extern form static domain return null 
access control do privileg new privileg action public object run url url get url obj filenam protect domain static domain get url domain url main process file secur cx scope url to extern form static domain return null 
privat url get url obj string url url url obj try url obj new url url catch malform urlexcept ex assum as main process file secur it is file need to build it url string cur dir system get properti user dir cur dir cur dir replac if cur dir end with cur dir cur dir try url cur dir url new url file cur dir url obj new url cur dir url url catch malform urlexcept ex2 throw new runtim except can not construct file url for url ex2 get messag return url obj 
privat protect domain get url domain url url code sourc cs cs new code sourc url java secur cert certif null permiss collect pc polici get polici get permiss cs return new protect domain cs pc 
public gener class loader creat class loader class loader parent loader object secur domain protect domain domain protect domain secur domain return new loader parent loader domain 
public object get dynam secur domain object secur domain protect domain static domain protect domain secur domain return get dynam domain static domain 
privat protect domain get dynam domain protect domain static domain context permiss p new context permiss static domain protect domain context domain new protect domain null p return context domain 
public object call with domain object secur domain final context cx final callabl callabl final scriptabl scope final scriptabl thi obj final object arg protect domain static domain protect domain secur domain there is no direct wai in java to intersect permit accord stack context with addit domain the follow implement first construct protect domain that allow action onli allow by both static domain and current stack context and then construct access control for thi dynam domain if thi is too slow altern solut would be to gener class per domain with a proxi method to call to infect java stack anoth optim in case of script come from world domain that is have minim default privileg is to construct on access control context base on protect domain with least possibl privileg and simpli call access control do privileg with thi untrust context protect domain dynam domain get dynam domain static domain protect domain tmp dynam domain access control context restrict new access control context tmp privileg action action new privileg action public object run return callabl call cx scope thi obj arg return access control do privileg action restrict 
privileg action action new privileg action public object run return callabl call cx scope thi obj arg 
static void init scriptabl scope boolean seal nativ error obj new nativ error scriptabl object put properti obj name error scriptabl object put properti obj messag scriptabl object put properti obj file name scriptabl object put properti obj line number new integ 0 obj export as jsclass max prototyp id scope seal 
static nativ error make context cx scriptabl scope id function object ctor obj object arg scriptabl proto scriptabl ctor obj get prototyp ctor obj nativ error obj new nativ error obj set prototyp proto obj set parent scope scope if arg length 1 scriptabl object put properti obj messag script runtim to string arg 0 if arg length 2 scriptabl object put properti obj file name arg 1 if arg length 3 int line script runtim to int32 arg 2 scriptabl object put properti obj line number new integ line return obj 
public string get class name return error 
public string to string return js to string thi 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 0 s to string break case id to sourc ariti 0 s to sourc break default throw new illeg argument except string valu of id init prototyp method error tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag error tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor return make cx scope f arg case id to string return js to string thi obj case id to sourc return js to sourc cx scope thi obj throw new illeg argument except string valu of id 
privat static string js to string scriptabl thi obj return get string thi obj name get string thi obj messag 
privat static string js to sourc context cx scriptabl scope scriptabl thi obj emul of spider monkei behavior object name scriptabl object get properti thi obj name object messag scriptabl object get properti thi obj messag object file name scriptabl object get properti thi obj file name object line number scriptabl object get properti thi obj line number string buffer sb new string buffer sb append new if name not found name undefin instanc sb append script runtim to string name sb append if messag not found file name not found line number not found if messag not found messag sb append script runtim unev cx scope messag if file name not found line number not found sb append if file name not found file name sb append script runtim unev cx scope file name if line number not found int line script runtim to int32 line number if line 0 sb append sb append script runtim to string line sb append return sb to string 
privat static string get string scriptabl obj string id object valu scriptabl object get properti obj id if valu not found return return script runtim to string valu 
protect int find prototyp id string s int id string id map gener last updat 2004 03 17 13 35 15 cet l0 id 0 string x null int c int s length s length if s length 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string els if s length 11 x constructor id id constructor if x null x s x equal s id 0 gener return id 
privat error report chain report privat default error report 
static error report for eval error report report default error report r new default error report r for eval true r chain report report return r 
public void warn string messag string sourc uri int line string line text int line offset if chain report null chain report warn messag sourc uri line line text line offset els do noth 
public void error string messag string sourc uri int line string line text int line offset if for eval throw script runtim construct error syntax error messag sourc uri line line text line offset if chain report null chain report error messag sourc uri line line text line offset els throw runtim error messag sourc uri line line text line offset 
public evalu except runtim error string messag string sourc uri int line string line text int line offset if chain report null return chain report runtim error messag sourc uri line line text line offset els return new evalu except messag sourc uri line line text line offset 
public class data type 004 extend live connect test public data type 004 super 
public static void main string arg data type 004 test new data type 004 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class 
valu pass from java script to java ar convert as follow ul li li object that ar wrapper around java object ar unwrap li other object ar wrap with a jsobject li string number and boolean ar convert to string float and boolean object respect see netscap javascript jsobject public void execut test get jsvar with eval null netscap javascript jsobject null get jsvar with get member null netscap javascript jsobject null 
us jsobject eval to creat a java script variabl of a java script type get the valu of the variabl us jsobject get member and jsobject eval the type and valu of the object return by get member and eval should be the same add the testcas param right expr right hand side to the java script assign express param class name string represent of expect type of the result param e valu expect valu of the result public void get jsvar with eval string right expr string class name string valu string var name js var object result class expect class null try expect class class for name class name creat the variabl in the java script context global eval var var name right expr get the valu of var name from the java script context result global eval var name system out println result is result catch except e system err println set jsvar with eval threw e to string with argument right expr expect class get name valu to string e print stack trace except e to string result new object try add test case global eval var var name right expr result global eval var name result null true result null except catch except e file except e to string 
public void get jsvar with get member string right expr string class name string valu string var name js var object result class expect class null try expect class class for name class name creat the variabl in the java script context global eval var var name right expr get the valu of var name from the java script context result global get member var name catch except e system err println set jsvar with get member threw e to string with argument right expr expect class get name valu to string e print stack trace except e to string result new object try add test case global eval var var name right expr result global get member var name result null true result null except catch except e file except e to string 
public rhino drv string arg super arg set suffix js 
public static void main string arg rhino drv d new rhino drv arg d start 
public boolean process option int length arg length if arg 0 start with xxx need to verifi that we at least get valid d and h option for int i 0 i arg length i if arg i equal t string tinderbox arg i if tinderbox equal true tinderbox equal 1 test driver tinderbox true els test driver tinderbox fals if arg i equal d p d thi test directori arg i end with file separ new file arg i new file arg i file separ p d thi test directori if thi test directori is directori system err println error thi test directori get absolut path is not a test directori return fals els continu if arg i equal s p s file new string 20 for int j i k 0 j arg length j if arg j start with break file k arg j if arg i equal h p h thi helper function new file arg i if thi helper function is file system err println error thi helper function get absolut path file not found return fals if arg i equal o p o output directori new file arg i file separ if output directori exist output directori is directori system err println error output directori get absolut path is not a directori return fals if arg i equal p opt level integ pars int arg i if arg i equal db debug level integ pars int arg i opt level 0 if arg i equal e execut arg i return true els switch arg length case 0 system err println error specifi locat of java script test return fals case 1 system err println error specifi locat of java script helper function file return fals case 2 thi test directori arg 0 end with file separ new file arg 0 new file arg 0 file separ thi helper function new file arg 1 if thi test directori is directori system err println error thi test directori get absolut path is not a directori return fals if thi helper function is file system err println error thi helper function get absolut path file not found return fals return true default system err println could not understand argument return fals 
for each file in each suit creat a new rhino env public synchron void execut suit test suit suit rhino env context test file file for int i 0 i suit size i synchron suit file test file suit element at i context new rhino env file suit thi context run test write file result file suit output directori write case result file suit output directori context close context null if file pass suit pass fals write suit result suit output directori write suit summari suit output directori 
creat an except with the specifi detail messag error intern to the java script engin will simpli throw a runtim except param sourc name the name of the sourc repons for the error param line number the line number of the sourc param column number the column number of the sourc mai be zero if unknown param line sourc the sourc of the line contain the error mai be null if unknown ecma error string error name string error messag string sourc name int line number string line sourc int column number record error origin sourc name line number line sourc column number thi error name error name thi error messag error messag 
deprec ecma error error instanc should not be construct explicitli sinc thei ar gener by the engin public ecma error scriptabl nativ error string sourc name int line number int column number string line sourc thi intern error script runtim to string nativ error sourc name line number line sourc column number 
public string detail return error name error messag 
get the name of the error ecma edit 3 defin the follow error eval error rang error refer error syntax error type error and urierror addit error name mai be ad in the futur see ecma edit 3 15 11 7 9 return the name of the error public string get name return error name 
get the messag correspond to the error see ecma edit 3 15 11 7 10 return an implemen defin string describ the error public string get error messag return error messag 
deprec us link rhino except sourc name from the super class public string get sourc name return sourc name 
deprec us link rhino except line number from the super class public int get line number return line number 
deprec us link rhino except column number from the super class public int get column number return column number 
deprec us link rhino except line sourc from the super class public string get line sourc return line sourc 
deprec alwai return b null b public scriptabl get error object return null 
public abstract class ref implement serializ public boolean ha context cx return true 
public abstract object get context cx 
public abstract object get context cx public abstract object set context cx object valu 
public abstract object set context cx object valu public boolean delet context cx return fals 
creat a new live connect env public live connect env test file f test suit s live connect drv d thi file f thi suit s thi driver d thi temp log name js get random file name tmp 
call by the driver to execut the test program public synchron void run test try creat context file start time driver get current time execut test file file end time driver get current time if task get exit valu 0 system out println abmorm program termin exit valu task get exit valu if file name end with n js file pass true els file except process exit valu task get exit valu suit pass fals file pass fals pars result catch except e suit pass fals file pass fals e print stack trace 
instanti a new java script shell pass the helper file and the name of the test class as argument public object creat context task new observ task driver execut driver helper function get absolut path file file path temp log name thi return object task 
start the shell process public object execut test file try task exec catch ioexcept e system err println e file except e to string return null 
pars the result file for thi test the which contain data in the follow format pre classnam live connect test pass true fals length number of testcas in thi test no pass number of testcas that pass no fail number of testcas that fail pre see com netscap javascript qa liveconnect live connect test write result to temp file public synchron boolean pars result string line buffer reader buf new buffer reader new string reader new string task get input try do line buf read line system out println line while line null catch ioexcept e system err println except read process output e to string file except e to string return fals vector label null vector valu null string t null try file reader fr new file reader driver output directori get absolut path temp log name buffer reader br new buffer reader fr string classnam br read line boolean pass new boolean br read line boolean valu int length new doubl br read line int valu int no pass new doubl br read line int valu int no fail new doubl br read line int valu string bugnumb br read line if pass thi file pass fals thi suit pass fals thi file total case length thi suit total case length thi file case pass no pass thi suit case pass no pass thi file case fail no fail thi suit case fail no fail thi file bugnumb bugnumb catch ioexcept e system err println e e print stack trace return true 
public string get random file name return integ to string new doubl math random 100000 int valu 
delet the temp log associ with thi context public void close string templog driver output directori temp log name try file f new file templog if f exist f delet catch except e e print stack trace return 
void p string s system out println s 
public static void init context cx scriptabl scope boolean seal nativ global obj new nativ global for int id 1 id last scope function id id string name int ariti 1 switch id case id decod uri name decod uri break case id decod uricompon name decod uricompon break case id encod uri name encod uri break case id encod uricompon name encod uricompon break case id escap name escap break case id eval name eval break case id is finit name is finit break case id is na n name is na n break case id is xmlname name is xmlname break case id pars float name pars float break case id pars int name pars int ariti 2 break case id unescap name unescap break case id unev name unev break default throw kit code bug id function object f new id function object obj ftag id name ariti scope if seal f seal object f export as scope properti scriptabl object defin properti scope na n script runtim na nobj scriptabl object dontenum scriptabl object defin properti scope infin script runtim wrap number doubl posit infin scriptabl object dontenum scriptabl object defin properti scope undefin undefin instanc scriptabl object dontenum string error method kit semicolon split convers error eval error rang error refer error syntax error type error urierror intern error java except each error constructor get it own error object as a prototyp with the name properti set to the name of the error for int i 0 i error method length i string name error method i scriptabl error proto script runtim new object cx scope error script runtim empti arg error proto put name error proto name if seal if error proto instanceof scriptabl object scriptabl object error proto seal object id function object ctor new id function object obj ftag id new common error name 1 scope ctor mark as constructor error proto if seal ctor seal object ctor export as scope properti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag ftag int method id f method id switch method id case id decod uri case id decod uricompon string str script runtim to string arg 0 return decod str method id id decod uri case id encod uri case id encod uricompon string str script runtim to string arg 0 return encod str method id id encod uri case id escap return js escap arg case id eval return js eval cx scope arg case id is finit boolean result if arg length 1 result fals els doubl d script runtim to number arg 0 result d d d doubl posit infin d doubl neg infin return script runtim wrap boolean result case id is na n the global method is na n as per ecma 262 15 1 2 6 boolean result if arg length 1 result true els doubl d script runtim to number arg 0 result d d return script runtim wrap boolean result case id is xmlname object name arg length 0 undefin instanc arg 0 xmllib xml lib xmllib extract from scope scope return script runtim wrap boolean xml lib is xmlname cx name case id pars float return js pars float arg case id pars int return js pars int arg case id unescap return js unescap arg case id unev object valu arg length 0 arg 0 undefin instanc return script runtim unev cx scope valu case id new common error the implement of all the ecma error constructor syntax error type error etc return nativ error make cx scope f arg throw f unknown 
the global method pars int as per ecma 262 15 1 2 2 privat object js pars int object arg string s script runtim to string arg 0 int radix script runtim to int32 arg 1 int len s length if len 0 return script runtim na nobj boolean neg fals int start 0 char c do c s char at start if charact is whitespac c break start while start len if c neg c start final int no radix 1 if radix 0 radix no radix els if radix 2 radix 36 return script runtim na nobj els if radix 16 len start 1 s char at start 0 c s char at start 1 if c x c x start 2 if radix no radix radix 10 if len start 1 s char at start 0 c s char at start 1 if c x c x radix 16 start 2 els if 0 c c 9 radix 8 start doubl d script runtim string to number s start radix return script runtim wrap number neg d d 
the global method pars float as per ecma 262 15 1 2 3 param cx unus param thi obj unus param arg the argument to pars float ignor arg 1 param fun obj unus privat object js pars float object arg if arg length 1 return script runtim na nobj string s script runtim to string arg 0 int len s length int start 0 scan forward to skip whitespac char c for if start len return script runtim na nobj c s char at start if token stream is jsspace c break start int i start if c c i if i len return script runtim na nobj c s char at i if c i check for infin if i 8 len s region match i infin 0 8 doubl d if s char at start d doubl neg infin els d doubl posit infin return script runtim wrap number d return script runtim na nobj find the end of the legal bit int decim 1 int expon 1 for i len i switch s char at i case if decim 1 onli allow a singl decim point break decim i continu case e case e if expon 1 break expon i continu case case onli allow or after e or e if expon i 1 break continu case 0 case 1 case 2 case 3 case 4 case 5 case 6 case 7 case 8 case 9 continu default break break s s substr start i try return doubl valu of s catch number format except ex return script runtim na nobj 
the global method escap as per ecma 262 15 1 2 4 includ code for the mask argument support by the c escap method which us to be part of the browser imbed blame for the strang constant name should be direct there privat object js escap object arg final int url xalpha 1 url xpalpha 2 url path 4 string s script runtim to string arg 0 int mask url xalpha url xpalpha url path if arg length 1 the mask argument non ecma doubl d script runtim to number arg 1 if d d mask int d d 0 mask url xalpha url xpalpha url path throw context report runtim error0 msg bad esc mask string buffer sb null for int k 0 l s length k l k int c s char at k if mask 0 c 0 c 9 c a c z c a c z c c c c c 0 mask url path c c if sb null sb append char c els if sb null sb new string buffer l 3 sb append s sb set length k int hex size if c 256 if c mask url xpalpha sb append continu sb append hex size 2 els sb append sb append u hex size 4 append hexadecim form of c left pad with 0 for int shift hex size 1 4 shift 0 shift 4 int digit 0xf c shift int hc digit 10 0 digit a 10 digit sb append char hc return sb null s sb to string 
the global unescap method as per ecma 262 15 1 2 5 privat object js unescap object arg string s script runtim to string arg 0 int first escap po s index of if first escap po 0 int l s length char buf s to char arrai int destin first escap po for int k first escap po k l char c buf k k if c k l int end start if buf k u start k 1 end k 5 els start k end k 2 if end l int x 0 for int i start i end i x kit x digit to int buf i x if x 0 c char x k end buf destin c destin s new string buf 0 destin return s 
privat object js eval context cx scriptabl scope object arg string m script runtim get message1 msg cant call indirect eval throw nativ global construct error cx eval error m scope 
static boolean is eval function object function obj if function obj instanceof id function object id function object function id function object function obj if function ha tag ftag function method id id eval return true return fals 
deprec us link script runtim construct error string string instead public static ecma error construct error context cx string error string messag scriptabl scope return script runtim construct error error messag 
deprec us link script runtim construct error string string string int int string instead public static ecma error construct error context cx string error string messag scriptabl scope string sourc name int line number int column number string line sourc return script runtim construct error error messag sourc name line number line sourc column number 
privat static string encod string str boolean full uri byte utf8buf null string buffer sb null for int k 0 length str length k length k char c str char at k if encod unescap c full uri if sb null sb append c els if sb null sb new string buffer length 3 sb append str sb set length k utf8buf new byte 6 if 0x dc00 c c 0x dfff throw context report runtim error0 msg bad uri int v if c 0x d800 0x dbff c v c els k if k length throw context report runtim error0 msg bad uri char c2 str char at k if 0x dc00 c2 c2 0x dfff throw context report runtim error0 msg bad uri v c 0x d800 10 c2 0x dc00 0x10000 int l on ucs4to utf8char utf8buf v for int j 0 j l j int d 0xff utf8buf j sb append sb append to hex char d 4 sb append to hex char d 0xf return sb null str sb to string 
privat static char to hex char int i if i 4 0 kit code bug return char i 10 i 0 i 10 a 
privat static int un hex char c if a c c f return c a 10 els if a c c f return c a 10 els if 0 c c 9 return c 0 els return 1 
privat static int un hex char c1 char c2 int i1 un hex c1 int i2 un hex c2 if i1 0 i2 0 return i1 4 i2 return 1 
privat static string decod string str boolean full uri char buf null int buf top 0 for int k 0 length str length k length char c str char at k if c if buf null buf buf top c k els if buf null decod alwai compress so result can not be bigger then str length buf new char length str get char 0 k buf 0 buf top k int start k if k 3 length throw context report runtim error0 msg bad uri int b un hex str char at k 1 str char at k 2 if b 0 throw context report runtim error0 msg bad uri k 3 if b 0x80 0 c char b els decod utf 8 sequenc into ucs4char and encod it into utf 16 int utf8tail ucs4char min ucs4char if b 0x c0 0x80 first utf 8 should be ousid 0x80 0x bf throw context report runtim error0 msg bad uri els if b 0x20 0 utf8tail 1 ucs4char b 0x1f min ucs4char 0x80 els if b 0x10 0 utf8tail 2 ucs4char b 0x0f min ucs4char 0x800 els if b 0x08 0 utf8tail 3 ucs4char b 0x07 min ucs4char 0x10000 els if b 0x04 0 utf8tail 4 ucs4char b 0x03 min ucs4char 0x200000 els if b 0x02 0 utf8tail 5 ucs4char b 0x01 min ucs4char 0x4000000 els first utf 8 can not be 0x ff or 0x fe throw context report runtim error0 msg bad uri if k 3 utf8tail length throw context report runtim error0 msg bad uri for int j 0 j utf8tail j if str char at k throw context report runtim error0 msg bad uri b un hex str char at k 1 str char at k 2 if b 0 b 0x c0 0x80 throw context report runtim error0 msg bad uri ucs4char ucs4char 6 b 0x3f k 3 check for overlong and other should not present code if ucs4char min ucs4char ucs4char 0x fffe ucs4char 0x ffff ucs4char 0x fffd if ucs4char 0x10000 ucs4char 0x10000 if ucs4char 0x fffff throw context report runtim error0 msg bad uri char h char ucs4char 10 0x d800 c char ucs4char 0x3ff 0x dc00 buf buf top h els c char ucs4char if full uri uri decod reserv index of c 0 for int x start x k x buf buf top str char at x els buf buf top c return buf null str new string buf 0 buf top 
privat static boolean encod unescap char c boolean full uri if a c c z a c c z 0 c c 9 return true if index of c 0 return true if full uri return uri decod reserv index of c 0 return fals 
privat static int on ucs4to utf8char byte utf8buff int ucs4char int utf8length 1 js assert ucs4char 0x7fffffff if ucs4char 0x7f 0 utf8buff 0 byte ucs4char els int i int a ucs4char 11 utf8length 2 while a 0 a 5 utf8length i utf8length while i 0 utf8buff i byte ucs4char 0x3f 0x80 ucs4char 6 utf8buff 0 byte 0x100 1 8 utf8length ucs4char return utf8length 
public interfac listen notifi about newli creat link context object public void context creat context cx 
notifi that the specifi link context instanc is no longer associ with the current thread 
get global context factori see ha explicit global see init global context factori public static context factori get global return global 
check if global factori wa set return true to indic that link init global context factori wa alreadi call and fals to indic that the global factori wa not explicitli set see get global see init global context factori public static boolean ha explicit global return ha custom global 
set global context factori the method can onli be call onc see get global see ha explicit global public static void init global context factori factori if factori null throw new illeg argument except if ha custom global throw new illeg state except ha custom global true global factori 
creat new link context instanc to be associ with the current thread thi is a callback method us by rhino to creat link context instanc when it is necessari to associ on with the current execut thread tt make context tt is allow to call link context seal object on the result to prevent link context chang by hostil script or applet protect context make context return new context 
implement of link context ha featur int featur index thi can be us to custom link context without introduc addit subclass protect boolean ha featur context cx int featur index int version switch featur index case context featur non ecma get year dure the great date rewrit of 1 3 we tri to track the evolv ecma standard which then had a definit of get year which alwai subtract 1900 which we implement not realiz that it wa incompat with the old behavior now rather than thrash the behavior yet again we ve decid to leav it with the 1900 behavior and point peopl to the get full year method but we try to protect exist script that have specifi a version version cx get languag version return version context version 1 0 version context version 1 1 version context version 1 2 case context featur member expr as function name return fals case context featur reserv keyword as identifi return fals case context featur to string as sourc version cx get languag version return version context version 1 2 case context featur parent proto proprti return true case context featur e4x version cx get languag version return version context version default version context version 1 6 case context featur dynam scope return fals case context featur strict var return fals case context featur strict eval return fals it is a bug to call the method with unknown featur index throw new illeg argument except string valu of featur index 
creat class loader for gener class thi method creat an instanc of the default implement of link gener class loader rhino us thi interfac to load gener jvm class when no link secur control is instal applic can overrid the method to provid custom class load protect gener class loader creat class loader class loader parent return new defin class loader parent 
get class loader to us when search for java class unless it wa explicitli initi with link init applic class loader class loader the method return null to indic that thread get context class loader should be us public final class loader get applic class loader return applic class loader 
set explicit class loader to us when search for java class see get applic class loader public final void init applic class loader class loader loader if loader null throw new illeg argument except loader is null if kit test if can load rhino class loader throw new illeg argument except loader can not resolv rhino class if thi applic class loader null throw new illeg state except applic class loader can onli be set onc check not seal thi applic class loader loader 
execut top call to script or function when the runtim is about to execut a script or function that will creat the first stack frame with scriptabl code it call thi method to perform the real call in thi wai execut of ani script happen insid thi function protect object do top call callabl callabl context cx scriptabl scope scriptabl thi obj object arg return callabl call cx scope thi obj arg 
implement of link context observ instruct count int instruct count thi can be us to custom link context without introduc addit subclass protect void observ instruct count context cx int instruct count 
protect void on context creat context cx object listen thi listen for int i 0 i listen l listen kit get listen listen i if l null break l context creat cx 
protect void on context releas context cx object listen thi listen for int i 0 i listen l listen kit get listen listen i if l null break l context releas cx 
public final void add listen listen listen check not seal synchron listen lock if disabl listen throw new illeg state except listen kit add listen listen listen 
public final void remov listen listen listen check not seal synchron listen lock if disabl listen throw new illeg state except listen kit remov listen listen listen 
the method is us onli to imlement context disabl static context listen final void disabl context listen check not seal synchron listen lock disabl listen true listen null 
check if thi is a seal context factori see seal public final boolean is seal return seal 
seal thi context factori so ani attempt to modifi it like to add or remov it listen will throw an except see is seal public final void seal check not seal seal true 
protect final void check not seal if seal throw new illeg state except 
call link context action run context cx us the link context instanc associ with the current thread if no context is associ with the thread then link make context will be call to construct new context instanc the instanc will be temporari associ with the thread dure call to link context action run context see context factori call context action see context call context factori factori callabl callabl scriptabl scope scriptabl thi obj object arg public final object call context action action return context call thi action 
same as link context enter with the differ that if a new context need to be creat then thi context factori is us to creat it instead of the global context factori return a context associ with the current thread public final context enter return enter null 
same as link context enter context with the differ that if a new context need to be creat then thi context factori is us to creat it instead of the global context factori return a context associ with the current thread public final context enter context cx return context enter cx thi 
same as link context exit although if you us link enter or link enter context method on thi object you should us thi exit method instead of the static on in link context public final void exit context exit thi 
creat a new ref env public ref env test file f test suit s ref drv d thi file f thi suit s thi driver d 
call by the driver to execut the test program public void run test driver p file name try file start time driver get current time creat context execut test file file end time driver get current time if task get exit valu 0 if file name end with n js file pass true els suit pass fals file pass fals if pars result if file name end with n js file pass true els suit pass fals file pass fals file except new string task get error catch except e suit pass fals file pass fals file except unknown process except file except new string task get error exit valu task get exit valu n threw except e 
instanti a new java script shell pass the test file as an argument public object creat context if driver code coverag string command coverag save merg data save merg text data driver execut f driver helper function get absolut path f file file path system out println command is command task new observ task command thi els task new observ task driver execut f driver helper function get absolut path f file file path thi return object task 
start the shell process public object execut test file try task exec catch ioexcept e driver p e to string file except e to string e print stack trace return null 
pars the standard output of the process and try to creat new test case object public boolean pars result string line int i j buffer reader br new buffer reader new string reader new string task get input try do line br read line driver p line if line null driver p t error no line to read return fals while line equal size tag if line br read line null return fals file total case integ valu of line int valu if line br read line null driver p t error no line after size tag return fals catch number format except nfe driver p t error no integ after size tag return fals catch ioexcept e driver p except read process output e to string file except e to string return fals for i 0 i file total case i string valu new string tag length try for j 0 j tag length j valu j null if line start with tag j driver p line didn t start with tag j line return fals while line br read line null line start with start tag valu j valu j null line valu j n line if valu j null valu j if line null i file total case 1 driver p line null and i file total case 1 return fals catch ioexcept e driver p except read process output e file except e to string return fals test case rt new test case valu 0 valu 1 valu 4 valu 2 valu 3 valu 5 file bugnumb valu 6 file case vector add element rt if rt pass equal fals if file name end with n js thi file pass true els thi file pass fals thi suit pass fals if file total case 0 if file name end with n js thi file pass true els thi file reason file contain no testcas thi file reason thi file pass fals thi suit pass fals return true 
method requir by test environ thi implemen doe noth public void close return 
privat xmlname string uri string local name thi uri uri thi local name local name 
static xmlname form star return new xmlname null 
static xmlname form properti string uri string local name return new xmlname uri local name 
void init xmlobject xmlobject impl xml object if xml object null throw new illeg argument except if thi xml object null throw new illeg state except thi xml object xml object 
string uri return uri 
string local name return local name 
boolean is attribut name return is attribut name 
void set attribut name if is attribut name throw new illeg state except is attribut name true 
boolean is descend return is descend 
void set is descend if is descend throw new illeg state except is descend true 
public boolean ha context cx if xml object null return fals return xml object ha xmlproperti thi 
public object get context cx if xml object null throw script runtim undef read error undefin instanc to string return xml object get xmlproperti thi 
public object set context cx object valu if xml object null throw script runtim undef write error undefin instanc to string valu assign to descend caus pars error on bad refer and thi should not be call if is descend throw kit code bug xml object put xmlproperti thi valu return valu 
public boolean delet context cx if xml object null return true xml object delet xmlproperti thi return xml object ha xmlproperti thi 
public string to string return qname local name string buffer buff new string buffer if is descend buff append if is attribut name buff append if uri null buff append if local name equal return buff to string els buff append append uri append buff append append local name return buff to string 
public class data type 001 extend live connect test public data type 001 super 
public static void main string arg data type 001 test new data type 001 test start 
public void execut test do static field test dt pub static boolean java lang boolean object new boolean data type class pub static final boolean do static field test dt pub static final boolean java lang boolean object new boolean data type class pub static final boolean do static field test dt pub static byte java lang doubl object new doubl data type class pub static final byte do static field test dt pub static final byte java lang doubl object new doubl data type class pub static final byte do static field test dt pub static short java lang doubl object new doubl data type class pub static final short do static field test dt pub static final short java lang doubl object new doubl data type class pub static final short do static field test dt pub static int java lang doubl object new doubl data type class pub static final int do static field test dt pub static final int java lang doubl object new doubl data type class pub static final int do static field test dt pub static long java lang doubl object new doubl data type class pub static final long do static field test dt pub static final long java lang doubl object new doubl data type class pub static final long do static field test dt pub static float java lang doubl object new doubl data type class pub static final float do static field test dt pub static final float java lang doubl object new doubl data type class pub static final float do static field test dt pub static doubl java lang doubl object new doubl data type class pub static final doubl do static field test dt pub static final doubl java lang doubl object new doubl data type class pub static final doubl do static field test dt pub static final char java lang doubl object new doubl data type class pub static final char do static field test dt pub static char java lang doubl object new doubl data type class pub static final char do static field test dt pub static string java lang string object new string data type class pub static final string do static field test dt pub static final string java lang string object new string data type class pub static final string 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class file bugnumb 301113 
public void do static field test string field string class name object valu get public static field field class name valu if field start with dt pub static final set public static final field field class name valu els set public static field field class name valu set java script variabl field class name valu 
set the valu of a java script variabl to a java valu get the valu of that variabl public void get public static field string field string class name object valu string descript field string except null object actual null string expect null string typeof null string expect type null check the class try global eval var myobject descript actual global get member myobject typeof string global eval typeof myobject expect class for name class name get name if valu instanceof number expect type number els if valu instanceof boolean expect type boolean els expect type object catch class not found except e catch except e except e to string might want to do all the interest stuff here in a try catch block add test case global eval var myobject descript global eval typeof myobject equal expect type true typeof equal expect type except add test case descript get class expect actual get class get name except add test case descript valu to string true actual equal valu except add test case actual to string equal valu to string true actual to string equal valu to string except 
try to set the valu of a public static field us jsobject set member which should succe public void set public static field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try befor global eval descript need to quot string if class name equal java lang string global eval descript new valu to string els global eval descript new valu after global eval descript expect class for name class name get name catch except e except e to string add test case global eval descript new valu to string after global eval descript after get class get name expect after get class get name except add test case after to string equal new valu to string true after equal new valu except add test case after to string equal new valu to string true after to string equal new valu to string except 
assign a valu to a public static final java field the assign should fail the valu should not chang but there should be no error messag public void set public static final field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try expect class for name class name get name catch except e except e to string befor global eval descript global eval descript new valu to string after global eval descript check the class of the result which should be the same as expect add test case descript get class expect after get class get name except the valu of the actual result should be the origin valu add test case descript valu to string true after equal valu except the string represent of the actual result should be the same as the string represent of the expect valu add test case after to string equal valu to string true after to string equal valu to string except get member field should return the same valu befor and after the assign add test case befor equal after true befor equal after except 
public void set java script variabl string field string class name object valu string descript field string except null object actual null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try global eval var myobject descript global set member myobject new valu actual global get member myobject expect class for name class name get name catch except e except e to string add test case global eval var myobject descript global set member myobject new valu to string actual global get member myobject actual get class get name expect actual get class get name except add test case descript new valu to string true actual equal new valu except add test case actual to string equal new valu to string true actual to string equal new valu to string except 
number node doubl number super token number thi number number 
privat static class string node extend node string node int type string str super type thi str str 
public static class jump extend node public jump int type super type 
jump int type int lineno super type lineno 
jump int type node child super type child 
jump int type node child int lineno super type child lineno 
public final jump get jump statement if type token break type token continu kit code bug return jump node 
public final void set jump statement jump jump statement if type token break type token continu kit code bug if jump statement null kit code bug if thi jump node null kit code bug onli onc thi jump node jump statement 
public final node get default if type token switch kit code bug return target2 
public final void set default node default target if type token switch kit code bug if default target type token target kit code bug if target2 null kit code bug onli onc target2 default target 
public final node get final if type token try kit code bug return target2 
public final void set final node final target if type token try kit code bug if final target type token target kit code bug if target2 null kit code bug onli onc target2 final target 
public final jump get loop if type token label kit code bug return jump node 
public final void set loop jump loop if type token label kit code bug if loop null kit code bug if jump node null kit code bug onli onc jump node loop 
public final node get continu if type token loop kit code bug return target2 
public final void set continu node continu target if type token loop kit code bug if continu target type token target kit code bug if target2 null kit code bug onli onc target2 continu target 
public node int node type type node type 
public node int node type node child type node type first last child child next null 
public node int node type node left node right type node type first left last right left next right right next null 
public node int node type node left node mid node right type node type first left last right left next mid mid next right right next null 
public node int node type int line type node type lineno line 
public node int node type node child int line thi node type child lineno line 
public node int node type node left node right int line thi node type left right lineno line 
public node int node type node left node mid node right int line thi node type left mid right lineno line 
public static node new number doubl number return new number node number 
public static node new string string str return new string node token string str 
public static node new string int type string str return new string node type str 
public int get type return type 
public void set type int type thi type type 
public boolean ha children return first null 
public node get first child return first 
public node get last child return last 
public node get next return next 
public node get child befor node child if child first return null node n first while n next child n n next if n null throw new runtim except node is not a child return n 
public node get last sibl node n thi while n next null n n next return n 
public void add child to front node child child next first first child if last null last child 
public void add child to back node child child next null if last null first last child return last next child last child 
public void add children to front node children node last sib children get last sibl last sib next first first children if last null last last sib 
public void add children to back node children if last null last next children last children get last sibl if first null first children 
add child befor node public void add child befor node new child node node if new child next null throw new runtim except new child had sibl in add child befor if first node new child next first first new child return node prev get child befor node add child after new child prev 
add child after node public void add child after node new child node node if new child next null throw new runtim except new child had sibl in add child after new child next node next node next new child if last node last new child 
public void remov child node child node prev get child befor child if prev null first first next els prev next child next if child last last prev child next null 
public void replac child node child node new child new child next child next if child first first new child els node prev get child befor child prev next new child if child last last new child child next null 
public void replac child after node prev child node new child node child prev child next new child next child next prev child next new child if child last last new child child next null 
privat static final string prop to string int prop type if token print tree if context print tree is fals the compil can remov all these string switch prop type case function prop return function case local prop return local case local block prop return local block case regexp prop return regexp case casearrai prop return casearrai case targetblock prop return targetblock case variabl prop return variabl case isnumb prop return isnumb case directcal prop return directcal case specialcal prop return specialcal case skip index prop return skip index case object id prop return object id prop case incrdecr prop return incrdecr prop case catch scope prop return catch scope prop case label id prop return label id prop case member type prop return member type prop case name prop return name prop default kit code bug return null 
privat prop list item lookup properti int prop type prop list item x prop list head while x null prop type x type x x next return x 
privat prop list item ensur properti int prop type prop list item item lookup properti prop type if item null item new prop list item item type prop type item next prop list head prop list head item return item 
public void remov prop int prop type prop list item x prop list head if x null prop list item prev null while x type prop type prev x x x next if x null return if prev null prop list head x next els prev next x next 
public object get prop int prop type prop list item item lookup properti prop type if item null return null return item object valu 
public int get int prop int prop type int default valu prop list item item lookup properti prop type if item null return default valu return item int valu 
public int get exist int prop int prop type prop list item item lookup properti prop type if item null kit code bug return item int valu 
public void put prop int prop type object prop if prop null remov prop prop type els prop list item item ensur properti prop type item object valu prop 
public void put int prop int prop type int prop prop list item item ensur properti prop type item int valu prop 
public int get lineno return lineno 
can onli be call when tt get type token number tt public final doubl get doubl return number node thi number 
public final void set doubl doubl number number node thi number number 
can onli be call when node ha string context public final string get string return string node thi str 
can onli be call when node ha string context public final void set string string s if s null kit code bug string node thi str s 
public static node new target return new node token target 
public final int label id if type token target kit code bug return get int prop label id prop 1 
public void label id int label id if type token target kit code bug put int prop label id prop label id 
public string to string if token print tree string buffer sb new string buffer to string new obj to int map sb return sb to string return string valu of type 
privat void to string obj to int map print id string buffer sb if token print tree sb append token name type if thi instanceof string node sb append sb append get string els if thi instanceof script or fn node script or fn node sof script or fn node thi if thi instanceof function node function node fn function node thi sb append sb append fn get function name sb append sourc name sb append sof get sourc name sb append encod sourc length sb append sof get encod sourc end sof get encod sourc start sb append base line sb append sof get base lineno sb append end line sb append sof get end lineno sb append els if thi instanceof jump jump jump jump thi if type token break type token continu sb append label append print id jump get jump statement print id sb sb append els if type token try node catch node jump target node final target jump get final if catch node null sb append catch append print id catch node print id sb sb append if final target null sb append final append print id final target print id sb sb append els if type token label type token loop type token switch sb append break append print id jump target print id sb sb append if type token loop sb append continu append print id jump get continu print id sb sb append els sb append target append print id jump target print id sb sb append els if type token number sb append sb append get doubl els if type token target sb append append print id thi print id sb if lineno 1 sb append sb append lineno for prop list item x prop list head x null x x next int type x type sb append sb append prop to string type sb append string valu switch type case targetblock prop can t add thi as it recurs valu target block properti break case local block prop can t add thi as it is dull valu last local block break case isnumb prop switch x int valu case both valu both break case right valu right break case left valu left break default throw kit code bug break case specialcal prop switch x int valu case specialcal eval valu eval break case specialcal with valu with break default non specialcal should not be store throw kit code bug break default object obj x object valu if obj null valu obj to string els valu string valu of x int valu break sb append valu sb append 
public string to string tree script or fn node tree top if token print tree string buffer sb new string buffer to string tree helper tree top thi null 0 sb return sb to string return null 
privat static void to string tree helper script or fn node tree top node n obj to int map print id int level string buffer sb if token print tree if print id null print id new obj to int map gener print id tree top print id for int i 0 i level i sb append n to string print id sb sb append n for node cursor n get first child cursor null cursor cursor get next if cursor get type token function int fn index cursor get exist int prop node function prop function node fn tree top get function node fn index to string tree helper fn fn null level 1 sb els to string tree helper tree top cursor print id level 1 sb 
privat static void gener print id node n obj to int map map if token print tree map put n map size for node cursor n get first child cursor null cursor cursor get next gener print id cursor map 
privat static void append print id node n obj to int map print id string buffer sb if token print tree if n null int id print id get n 1 sb append if id 1 sb append id 1 els sb append not avail 
privat string str public consol write consol text area text area string str thi text area text area thi str str 
public void run text area write str 
privat string buffer buffer public consol writer consol text area text area thi text area text area buffer new string buffer 
public synchron void write int ch buffer append char ch if ch n flush buffer 
public synchron void write char data int off int len for int i off i len i buffer append data i if data i n flush buffer 
public synchron void flush if buffer length 0 flush buffer 
public void close flush 
privat void flush buffer string str buffer to string buffer set length 0 swing util invok later new consol write text area str 
privat int output mark 0 public void select int start int end request focu super select start end 
public consol text area string argv super histori new java util vector console1 new consol writer thi console2 new consol writer thi out new print stream console1 err new print stream console2 pipe output stream out pipe new pipe output stream in pipe new print writer out pipe in new pipe input stream try out pipe connect in catch ioexcept exc exc print stack trace get document add document listen thi add kei listen thi set line wrap true set font new font monospac 0 12 
synchron void return press document doc get document int len doc get length segment segment new segment try doc get text output mark len output mark segment catch javax swing text bad locat except ignor ignor print stack trace if segment count 0 histori add element segment to string histori index histori size in pipe write segment arrai segment offset segment count append n output mark doc get length in pipe write n in pipe flush console1 flush 
public void eval string str in pipe write str in pipe write n in pipe flush console1 flush 
public void kei press kei event e int code e get kei code if code kei event vk back space code kei event vk left if output mark get caret posit e consum els if code kei event vk home int caret po get caret posit if caret po output mark e consum els if caret po output mark if e is control down if e is shift down move caret posit output mark els set caret posit output mark e consum els if code kei event vk enter return press e consum els if code kei event vk up histori index if histori index 0 if histori index histori size histori index histori size 1 if histori index 0 string str string histori element at histori index int len get document get length replac rang str output mark len int caret po output mark str length select caret po caret po els histori index els histori index e consum els if code kei event vk down int caret po output mark if histori size 0 histori index if histori index 0 histori index 0 int len get document get length if histori index histori size string str string histori element at histori index replac rang str output mark len caret po output mark str length els histori index histori size replac rang output mark len select caret po caret po e consum 
public void kei type kei event e int kei char e get kei char if kei char 0x8 kei event vk back space if output mark get caret posit e consum els if get caret posit output mark set caret posit output mark 
public synchron void kei releas kei event e 
public synchron void write string str insert str output mark int len str length output mark len select output mark output mark 
public synchron void insert updat document event e int len e get length int off e get offset if output mark off output mark len 
public synchron void remov updat document event e int len e get length int off e get offset if output mark off if output mark off len output mark len els output mark off 
public synchron void post updat ui thi attempt to cleanup the damag done by updat compon tree ui request focu set caret get caret select output mark output mark 
public synchron void chang updat document event e 
public input stream get in return in 
public print stream get out return out 
public print stream get err return err 
public compil environ error report default error report instanc languag version context version default gener debug info true us dynam scope fals reserv keyword as identifi fals allow member expr as function name fals xml avail true optim level 0 gener sourc true 
public void init from context context cx set error report cx get error report thi languag version cx get languag version us dynam scope cx compil function with dynam scope flag gener debug info cx is gener debug chang cx is gener debug reserv keyword as identifi cx ha featur context featur reserv keyword as identifi allow member expr as function name cx ha featur context featur member expr as function name xml avail cx ha featur context featur e4x optim level cx get optim level gener sourc cx is gener sourc activ name cx activ name 
public final error report get error report return error report 
public void set error report error report error report if error report null throw new illeg argument except thi error report error report 
public final int get languag version return languag version 
public void set languag version int languag version context check languag version languag version thi languag version languag version 
public final boolean is gener debug info return gener debug info 
public void set gener debug info boolean flag thi gener debug info flag 
public final boolean is us dynam scope return us dynam scope 
public final boolean is reserv keyword as identifi return reserv keyword as identifi 
public void set reserv keyword as identifi boolean flag reserv keyword as identifi flag 
public final boolean is allow member expr as function name return allow member expr as function name 
public void set allow member expr as function name boolean flag allow member expr as function name flag 
public final boolean is xml avail return xml avail 
public void set xml avail boolean flag xml avail flag 
public final int get optim level return optim level 
public void set optim level int level context check optim level level thi optim level level 
public final boolean is gener sourc return gener sourc 
specifi whether or not sourc inform should be gener p without sourc inform evalu the to string method on java script function produc onli nativ code for the bodi of the function note that code gener without sourc is not fulli ecma conform public void set gener sourc boolean gener sourc thi gener sourc gener sourc 
public class data type 015 extend live connect test public data type 015 super 
public static void main string arg data type 015 test new data type 015 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt static get object arrai true do arrai test dt pub static arrai object true do arrai test dt get object arrai true do arrai test dt pub arrai object fals 
assign a java object arrai to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command the command to eval to get the object arrai public void do arrai test string command boolean should equal object arrai data type class pub static arrai object object js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java arrai js arrai object global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai object item object global eval js arrai i add test case js arrai command global eval js arrai i equal arrai i should equal item equal arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal js arrai arrai except 
privat special ref scriptabl target int type string name thi target target thi type type thi name name 
static ref creat special context cx object object string name scriptabl target script runtim to object or null cx object if target null throw script runtim undef read error object name int type if name equal proto type special proto els if name equal parent type special parent els throw new illeg argument except name if cx ha featur context featur parent proto proprti clear special after check for valid name type special none return new special ref target type name 
public object get context cx switch type case special none return script runtim get object prop target name cx case special proto return target get prototyp case special parent return target get parent scope default throw kit code bug 
public object set context cx object valu switch type case special none return script runtim set object prop target name valu cx case special proto case special parent scriptabl obj script runtim to object or null cx valu if obj null check that obj doe not contain on it prototyp scope chain to prevent cycl scriptabl search obj do if search target throw context report runtim error1 msg cyclic valu name if type special proto search search get prototyp els search search get parent scope while search null if type special proto target set prototyp obj els target set parent scope obj return obj default throw kit code bug 
public boolean ha context cx if type special none return script runtim ha object elem target name cx return true 
public boolean delet context cx if type special none return script runtim delet object elem target name cx return fals 
privat static final int function end token last token 1 string get encod sourc return sourc to string 0 
int get current offset return sourc top 
int mark function start int function type int save offset get current offset add token token function append char function type return save offset 
int mark function end int function start int offset get current offset append char function end return offset 
void add token int token if 0 token token token last token throw new illeg argument except append char token 
void add eol int token if 0 token token token last token throw new illeg argument except append char token append char token eol 
void add name string str add token token name append string str 
void add string string str add token token string append string str 
void add regexp string regexp string flag add token token regexp append string regexp flag 
void add number doubl n add token token number encod the number in the sourc stream save as number type char char char char char where type is d doubl s short j long we need to retain float vs integ type info to keep the behavior of liveconnect type guess the same after decompil liveconnect tri to present 1 0 to java as a float doubl opt thi is no longer true we could compress the format thi mai not be the most space effici encod the char creat below mai take up to 3 byte in constant pool utf 8 encod so a doubl could take up to 12 byte long lbit long n if lbit n if it s float point save as a doubl bit pattern 12 15 97 our scanner onli return doubl for f p lbit doubl doubl to long bit n append d append char lbit 48 append char lbit 32 append char lbit 16 append char lbit els we can ignor neg valu bc thei re alreadi prefix by neg if lbit 0 kit code bug will it fit in a char thi give a short encod for integ valu up to 2 16 if lbit charact max valu append s append char lbit els integr but won t fit in a char store as a long append j append char lbit 48 append char lbit 32 append char lbit 16 append char lbit 
privat void append string string str int l str length int length encod size 1 if l 0x8000 length encod size 2 int next top sourc top length encod size l if next top sourc buffer length increas sourc capac next top if l 0x8000 us 2 char to encod string exceed 32k were the highest bit in the first char indic presenc of the next byte sourc buffer sourc top char 0x8000 l 16 sourc top sourc buffer sourc top char l sourc top str get char 0 l sourc buffer sourc top sourc top next top 
privat void append char c if sourc top sourc buffer length increas sourc capac sourc top 1 sourc buffer sourc top c sourc top 
privat void increas sourc capac int minim capac call thi onli when capac increas is must if minim capac sourc buffer length kit code bug int new capac sourc buffer length 2 if new capac minim capac new capac minim capac char tmp new char new capac system arraycopi sourc buffer 0 tmp 0 sourc top sourc buffer tmp 
privat string sourc to string int offset if offset 0 sourc top offset kit code bug return new string sourc buffer offset sourc top offset 
decompil the sourc inform associ with thi js function script back into a string for the most part thi just mean translat token back to their string represent there s a littl bit of lookahead logic to decid the proper space indent most of the work in map the origin sourc to the prettyprint decompil version is done by the parser param sourc encod sourc tree present param flag flag to select output format param properti indent properti public static string decompil string sourc int flag uint map properti int length sourc length if length 0 return int indent properti get int initi indent prop 0 if indent 0 throw new illeg argument except int indent gap properti get int indent gap prop 4 if indent gap 0 throw new illeg argument except int case gap properti get int case gap prop 2 if case gap 0 throw new illeg argument except string buffer result new string buffer boolean just function bodi 0 flag decompil onli bodi flag boolean to sourc 0 flag decompil to sourc flag spew token in sourc for debug as type number char if print sourc system err println length length for int i 0 i length i note that token to name will fail unless context print tree is true string tokennam null if token print name tokennam token name sourc char at i if tokennam null tokennam string pad tokennam length 7 t t t system err println tokennam pad int sourc char at i t script runtim escap string sourc substr i i 1 system err println int brace nest 0 boolean after first eol fals int i 0 int top function type if sourc char at i token script i top function type 1 els top function type sourc char at i 1 if to sourc add an initi newlin to exactli match js result append n for int j 0 j indent j result append els if top function type function node function express result append while i length switch sourc char at i case token name case token regexp re wrap in s in parser i print sourc string sourc i 1 fals result continu case token string i print sourc string sourc i 1 true result continu case token number i print sourc number sourc i 1 result continu case token true result append true break case token fals result append fals break case token null result append null break case token thi result append thi break case token function i skip function type result append function break case function end do noth break case token comma result append break case token lc brace nest if token eol get next sourc length i indent indent gap result append break case token rc brace nest don t print the close rc if it close the toplevel function and we re call from decompil function bodi if just function bodi brace nest 0 break result append switch get next sourc length i case token eol case function end indent indent gap break case token while case token els indent indent gap result append break break case token lp result append break case token rp result append if token lc get next sourc length i result append break case token lb result append break case token rb result append break case token eol if to sourc break boolean new line true if after first eol after first eol true if just function bodi throw awai just ad function name and restor the origin indent result set length 0 indent indent gap new line fals if new line result append n add indent if ani token remain less setback if next token is a label case or default if i 1 length int less 0 int next token sourc char at i 1 if next token token case next token token default less indent gap case gap els if next token token rc less indent gap elabor check against label skip past a follow inlin name and look for a colon els if next token token name int after name get sourc string end sourc i 2 if sourc char at after name token colon less indent gap for less indent less result append break case token dot result append break case token new result append new break case token delprop result append delet break case token if result append if break case token els result append els break case token for result append for break case token in result append in break case token with result append with break case token while result append while break case token do result append do break case token try result append try break case token catch result append catch break case token final result append final break case token throw result append throw break case token switch result append switch break case token break result append break if token name get next sourc length i result append break case token continu result append continu if token name get next sourc length i result append break case token case result append case break case token default result append default break case token return result append return if token semi get next sourc length i result append break case token var result append var break case token semi result append if token eol get next sourc length i separ in for result append break case token assign result append break case token assign add result append break case token assign sub result append break case token assign mul result append break case token assign div result append break case token assign mod result append break case token assign bitor result append break case token assign bitxor result append break case token assign bitand result append break case token assign lsh result append break case token assign rsh result append break case token assign ursh result append break case token hook result append break case token objectlit pun objectlit to mean colon in objlit properti initi thi need to be distinct from colon in the gener case to distinguish from the colon in a ternari which need differ space result append break case token colon if token eol get next sourc length i it s the end of a label result append els it s the middl part of a ternari result append break case token or result append break case token and result append break case token bitor result append break case token bitxor result append break case token bitand result append break case token sheq result append break case token shne result append break case token eq result append break case token ne result append break case token le result append break case token lt result append break case token ge result append break case token gt result append break case token instanceof result append instanceof break case token lsh result append break case token rsh result append break case token ursh result append break case token typeof result append typeof break case token void result append void break case token not result append break case token bitnot result append break case token po result append break case token neg result append break case token inc result append break case token dec result append break case token add result append break case token sub result append break case token mul result append break case token div result append break case token mod result append break case token coloncolon result append break case token dotdot result append break case token dotqueri result append break case token xmlattr result append break default if we don t know how to decompil it rais an except throw new runtim except i if to sourc add that trail newlin if it s an outermost function if just function bodi result append n els if top function type function node function express result append return result to string 
privat static int get next string sourc int length int i return i 1 length sourc char at i 1 token eof 
privat static int get sourc string end string sourc int offset return print sourc string sourc offset fals null 
privat static int print sourc string string sourc int offset boolean as quot string string buffer sb int length sourc char at offset offset if 0x8000 length 0 length 0x7fff length 16 sourc char at offset offset if sb null string str sourc substr offset offset length if as quot string sb append str els sb append sb append script runtim escap string str sb append return offset length 
privat static int print sourc number string sourc int offset string buffer sb doubl number 0 0 char type sourc char at offset offset if type s if sb null int ival sourc char at offset number ival offset els if type j type d if sb null long lbit lbit long sourc char at offset 48 lbit long sourc char at offset 1 32 lbit long sourc char at offset 2 16 lbit long sourc char at offset 3 if type j number lbit els number doubl long bit to doubl lbit offset 4 els bad sourc throw new runtim except if sb null sb append script runtim number to string number 10 return offset 
public static class class or null string class name try return class for name class name catch class not found except ex catch secur except ex catch linkag error ex catch illeg argument except e can be thrown if name ha charact that a class name can not contain return null 
public static class class or null class loader loader string class name try return loader load class class name catch class not found except ex catch secur except ex catch linkag error ex catch illeg argument except e can be thrown if name ha charact that a class name can not contain return null 
static object new instanc or null class cl try return cl new instanc catch secur except x catch linkag error ex catch instanti except x catch illeg access except x return null 
check that test class is acces from the given loader static boolean test if can load rhino class class loader loader class test class script runtim context factori class class x kit class or null loader test class get name if x test class the check cover the case when x null loader doe not know about test class or the case when x null x test class loader load a class unrel to test class return fals return true 
if init caus method exist in throwabl call tt ex init caus caus tt or otherwis do noth return the tt ex tt argument public static runtim except init caus runtim except ex throwabl caus if throwabl init caus null object arg caus try throwabl init caus invok ex arg catch except e ignor ani except return ex 
split string into arrai of string us semicolon as string termin after the last string is requir public static string semicolon split string s string arrai null for loop 2 time first to count semicolon and then to fill arrai int count 0 int cursor 0 for int next s index of cursor if next 0 break if arrai null arrai count s substr cursor next count cursor next 1 after the last semicolon if arrai null arrai size count state check for requir termin if cursor s length throw new illeg argument except arrai new string count els arrai fill state stop the loop break return arrai 
if charact tt c tt is a hexadecim digit return tt accumul tt 16 plu correspond number otheris return 1 public static int x digit to int int c int accumul check us 0 9 a z a z if c 9 c 0 if 0 c break check els if c f if a c c a 10 break check els if c f if a c c a 10 break check return 1 return accumul 4 c 
add i listen i to i bag i of listen the function doe not modifi i bag i and return a new collect contain i listen i and all listen from i bag i bag without listen alwai repres as the null valu p usag exampl pre privat volatil object chang listen public void add my listen properti chang listen l synchron thi chang listen kit add listen chang listen l public void remov text listen properti chang listen l synchron thi chang listen kit remov listen chang listen l public void fire chang event object old valu object new valu get immun local copi object listen chang listen if listen null properti chang event e new properti chang event thi some properti old valu new valu for int i 0 i object l kit get listen listen i if l null break properti chang listen l properti chang e pre param listen listen to add to i bag i param bag current collect of listen return a new bag contain all listen from i bag i and i listen i see remov listen object bag object listen see get listen object bag int index public static object add listen object bag object listen if listen null throw new illeg argument except if listen instanceof object throw new illeg argument except if bag null bag listen els if bag instanceof object bag new object bag listen els object arrai object bag int l arrai length bag ha at least 2 element if it is arrai if l 2 throw new illeg argument except object tmp new object l 1 system arraycopi arrai 0 tmp 0 l tmp l listen bag tmp return bag 
remov i listen i from i bag i of listen the function doe not modifi i bag i and return a new collect contain all listen from i bag i except i listen i if i bag i doe not contain i listen i the function return i bag i p for usag exampl see link add listen object bag object listen param listen listen to remov from i bag i param bag current collect of listen return a new bag contain all listen from i bag i except i listen i see add listen object bag object listen see get listen object bag int index public static object remov listen object bag object listen if listen null throw new illeg argument except if listen instanceof object throw new illeg argument except if bag listen bag null els if bag instanceof object object arrai object bag int l arrai length bag ha at least 2 element if it is arrai if l 2 throw new illeg argument except if l 2 if arrai 1 listen bag arrai 0 els if arrai 0 listen bag arrai 1 els int i l do i if arrai i listen object tmp new object l 1 system arraycopi arrai 0 tmp 0 i system arraycopi arrai i 1 tmp i l i 1 bag tmp break while i 0 return bag 
get listen at i index i posit in i bag i or null if i index i equal to number of listen in i bag i p for usag exampl see link add listen object bag object listen param bag current collect of listen param index index of the listen to access return listen at the given index or null see add listen object bag object listen see remov listen object bag object listen public static object get listen object bag int index if index 0 if bag null return null if bag instanceof object return bag object arrai object bag bag ha at least 2 element if it is arrai if arrai length 2 throw new illeg argument except return arrai 0 els if index 1 if bag instanceof object if bag null throw new illeg argument except return null object arrai object bag the arrai access will check for index on it own return arrai 1 els bag ha to arrai object arrai object bag int l arrai length if l 2 throw new illeg argument except if index l return null return arrai index 
static object init hash hashtabl h object kei object initi valu synchron h object current h get kei if current null h put kei initi valu els initi valu current return initi valu 
complex kei object key1 object key2 thi key1 key1 thi key2 key2 
public boolean equal object anoth obj if anoth obj instanceof complex kei return fals complex kei anoth complex kei anoth obj return key1 equal anoth key1 key2 equal anoth key2 
public int hash code if hash 0 hash key1 hash code key2 hash code return hash 
public static object make hash kei from pair object key1 object key2 if key1 null throw new illeg argument except if key2 null throw new illeg argument except return new complex kei key1 key2 
public static string read reader reader r throw ioexcept char buffer new char 512 int cursor 0 for int n r read buffer cursor buffer length cursor if n 0 break cursor n if cursor buffer length char tmp new char buffer length 2 system arraycopi buffer 0 tmp 0 cursor buffer tmp return new string buffer 0 cursor 
public static byte read stream input stream is int initi buffer capac throw ioexcept if initi buffer capac 0 throw new illeg argument except bad initi buffer capac initi buffer capac byte buffer new byte initi buffer capac int cursor 0 for int n is read buffer cursor buffer length cursor if n 0 break cursor n if cursor buffer length byte tmp new byte buffer length 2 system arraycopi buffer 0 tmp 0 cursor buffer tmp if cursor buffer length byte tmp new byte cursor system arraycopi buffer 0 tmp 0 cursor buffer tmp return buffer 
throw runtim except to indic fail assert the function never return and it return type is runtim except onli to be abl to write tt throw kit code bug tt if plain tt kit code bug tt trigger unreach code error public static runtim except code bug throw runtim except runtim except ex new illeg state except fail assert print stack trace asap ex print stack trace system err throw ex 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public class data type 013 extend live connect test public data type 013 super 
public static void main string arg data type 013 test new data type 013 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt static get int arrai true do arrai test dt pub static arrai int true do arrai test dt get int arrai true do arrai test dt pub arrai int fals 
assign a java byte arrai to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command the command to eval to get the byte arrai public void do arrai test string command boolean should equal int arrai data type class pub static arrai int int js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java object js arrai int global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai doubl item doubl global eval js arrai i add test case js arrai command global eval js arrai i equal arrai i true item equal new doubl arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal true fals js arrai arrai 
privat static vmbridg make instanc for int i 0 i 3 i string class name if i 0 class name org mozilla javascript vmbridg custom els if i 1 class name org mozilla javascript jdk13 vmbridg jdk13 els class name org mozilla javascript jdk11 vmbridg jdk11 class cl kit class or null class name if cl null vmbridg bridg vmbridg kit new instanc or null cl if bridg null return bridg throw new illeg state except fail to creat vmbridg instanc 
return a helper object to optim link context access p the runtim will pass the result helper object to the subsequ call to link get context object context helper and link set context object context helper context cx method in thi wai the implement can us the helper to cach inform about current thread to make link context access faster 
get link context instanc associ with the current thread or null if none param context helper the result of link get thread context helper call from the current thread 
associ link context instanc with the current thread or remov the current associ if tt cx tt is null param context helper the result of link get thread context helper call from the current thread 
protect abstract void set context object context helper context cx return the class loader instanc associ with the current thread protect abstract class loader get current thread class loader 
in mani jvmss public method in privat class ar not access by default sun bug 4071593 vmbridg instanc should try to workaround that via for exampl call method set access true when it is avail the implement is respons to catch all possibl except like secur except if the workaround is not avail return true if it wa possibl to make method access or fals otherwis 
creat helper object to creat later proxi implement the specifi interfac later under jdk 1 3 the implement can look like pre return java lang reflect proxi get proxi class interfac get constructor new class java lang reflect invoc handler class pre param interfac arrai with on or more interfac class object protect object get interfac proxi helper context factori cf class interfac throw context report runtim error vmbridg get interfac proxi helper is not support 
creat proxi object for link interfac adapt the proxi should call link interfac adapt invok context factori cf object target scriptabl top scope method method object arg as implement of interfac method associ with tt proxi helper tt param proxi helper the result of the previou call to link get interfac proxi helper context factori class protect object new interfac proxi object proxi helper context factori cf interfac adapt adapt object target scriptabl top scope throw context report runtim error vmbridg new interfac proxi is not support 
public class member 001 extend live connect test public member 001 super 
public static void main string arg member 001 test new member 001 test start 
public void setup test environ super setup test environ 
public void execut test object data get data arrai for int i 0 i data length i jsobject js object get jsobject object data i get the initi valu of the properti get member js object object data i object data i 4 set the valu of the properti set member js object object data i verifi the valu of the properti get member js object object data i object data i 5 
public jsobject get jsobject object data return jsobject global eval data 0 data 1 
get the data arrai which is an object arrai data arrai which ar also object arrai the data arrai consist of 3 item ul li string pass to global eval to creat the thi object for set member li string properti of the jsobject to get or set li object new valu of the properti pass to set member and expect li object valu of the properti befor set it expect result from get member li string represent of the properti as retriev by get member li string class name of the properti as retriev by get member li string typeof as determin by java script ul to add test case to thi test modifi thi method return the data arrai public object get data arrai object d0 new string d0 0 identifi new string new boolean 1 assign express new string foo 2 properti new string bar 3 valu to assign new string undefin 4 initi valu new string bar 5 valu after assign java lang string 6 class of properti new string object 7 js typeof valu object d1 new string d1 0 identifi new string new string java script 1 assign express new string foo 2 properti new boolean true 3 valu to assign new string undefin 4 initi valu new boolean true 5 valu after assign java lang boolean 6 class of properti new string object 7 js typeof valu object d2 new string d2 0 identifi new string new number 12345 1 assign express new string foo 2 properti new doubl 0 2134 3 valu to assign new string undefin 4 initi valu new doubl 0 2134 5 valu after assign java lang doubl 6 class of properti new string object 7 js typeof valu object d3 new string d3 0 identifi new string new number 12345 1 assign express new string foo 2 properti new integ 987654 3 valu to assign new string undefin 4 initi valu new integ 987654 5 valu after assign java lang integ 6 class of properti new string object 7 js typeof valu object d4 new string d4 new string new object new string properti global new string undefin global netscap javascript jsobject new string object object data arrai d0 d1 d3 d4 return data arrai 
get the valu of a java script properti check it class public void get member jsobject the thi object data object valu string except string properti string data 2 object e valu valu object a valu null class e class null class a class null try a valu the thi get member properti if a valu null e class e valu get class a class a valu get class catch except e except the thi get member properti threw e to string file except except e print stack trace final if a valu null els check the valu of the properti add test case get member return a valu data 0 get member properti equal e valu true a valu equal e valu except check the class of the properti add test case a valu get class return a class get name a class get name equal e class get name true a class get name equal e class get name except 
set the valu of a java script properti public void set member jsobject the thi object data string except string result pass string properti string data 2 object valu data 3 try the thi set member properti valu catch except e result fail except the thi set member properti valu threw e to string file except except e print stack trace final add test case the thi set member properti valu pass result except 
static final long serial version uid 6358550398665688245l member box method method init method 
member box constructor constructor init constructor 
privat void init method method thi member object method thi arg type method get paramet type 
privat void init constructor constructor thi member object constructor thi arg type constructor get paramet type 
method method return method member object 
constructor ctor return constructor member object 
boolean is method return member object instanceof method 
boolean is ctor return member object instanceof constructor 
boolean is static return modifi is static member object get modifi 
string get name return member object get name 
class get declar class return member object get declar class 
string to java declar string buffer sb new string buffer if is method method method method sb append method get return type sb append sb append method get name els constructor ctor ctor string name ctor get declar class get name int last dot name last index of if last dot 0 name name substr last dot 1 sb append name sb append java member live connect signatur arg type return sb to string 
public string to string return member object to string 
object invok object target object arg method method method try try return method invok target arg catch illeg access except ex method access search access method method arg type if access null member object access method access els if vmbridg instanc try to make access method throw context throw as script runtim ex ex retri after recoveri return method invok target arg catch except ex throw context throw as script runtim ex ex 
object new instanc object arg constructor ctor ctor try try return ctor new instanc arg catch illeg access except ex if vmbridg instanc try to make access ctor throw context throw as script runtim ex ex return ctor new instanc arg catch except ex throw context throw as script runtim ex ex 
privat static method search access method method method class param int modifi method get modifi if modifi is public modifi modifi is static modifi class c method get declar class if modifi is public c get modifi string name method get name class intf c get interfac for int i 0 n intf length i n i class intf intf i if modifi is public intf get modifi try return intf get method name param catch no such method except ex catch secur except ex for c c get superclass if c null break if modifi is public c get modifi try method m c get method name param int m modifi m get modifi if modifi is public m modifi modifi is static m modifi return m catch no such method except ex catch secur except ex return null 
privat void read object object input stream in throw ioexcept class not found except in default read object member member read member in if member instanceof method init method member els init constructor member 
privat void write object object output stream out throw ioexcept out default write object write member out member object 
write a constructor or method object method and constructor ar not serializ so we must serial inform about the class the name and the paramet and recreat upon deseri privat static void write member object output stream out member member throw ioexcept if member null out write boolean fals return out write boolean true if member instanceof method member instanceof constructor throw new illeg argument except not method or constructor out write boolean member instanceof method out write object member get name out write object member get declar class if member instanceof method write paramet out method member get paramet type els write paramet out constructor member get paramet type 
read a method or a constructor from the stream privat static member read member object input stream in throw ioexcept class not found except if in read boolean return null boolean is method in read boolean string name string in read object class declar class in read object class parm read paramet in try if is method return declar get method name parm els return declar get constructor parm catch no such method except e throw new ioexcept cannot find member e 
write an arrai of paramet type to the stream requir special handl becaus primit type cannot be found upon deseri by the default java implement privat static void write paramet object output stream out class parm throw ioexcept out write short parm length outer for int i 0 i parm length i class parm parm i out write boolean parm is primit if parm is primit out write object parm continu for int j 0 j primit length j if parm equal primit j out write byte j continu outer throw new illeg argument except primit parm not found 
read an arrai of paramet type from the stream privat static class read paramet object input stream in throw ioexcept class not found except class result new class in read short for int i 0 i result length i if in read boolean result i class in read object continu result i primit in read byte return result 
static void check valid attribut int attribut final int mask readonli dontenum perman if attribut mask 0 throw new illeg argument except string valu of attribut 
public scriptabl object 
public scriptabl object scriptabl scope scriptabl prototyp if scope null throw new illeg argument except parent scope object scope prototyp object prototyp 
return the name of the class thi is typic the same name as the constructor class extend scriptabl object must implement thi abstract method 
return true if the name properti is defin param name the name of the properti param start the object in which the lookup began return true if and onli if the properti wa found in the object public boolean ha string name scriptabl start return null get name slot name 
return true if the properti index is defin param index the numer index for the properti param start the object in which the lookup began return true if and onli if the properti wa found in the object public boolean ha int index scriptabl start return null get slot null index 
return the valu of the name properti or not found if the properti wa creat us defin properti the appropri getter method is call param name the name of the properti param start the object in which the lookup began return the valu of the properti mai be null or not found public object get string name scriptabl start slot slot get name slot name if slot null return scriptabl not found if slot instanceof getter slot getter slot gslot getter slot slot if gslot getter null return get by getter gslot start return slot valu 
return the valu of the index properti or not found param index the numer index for the properti param start the object in which the lookup began return the valu of the properti mai be null or not found public object get int index scriptabl start slot slot get slot null index if slot null return scriptabl not found return slot valu 
set the valu of the name properti creat it if need be if the properti wa creat us defin properti the appropri setter method is call p if the properti s attribut includ readonli no action is taken thi method will actual set the properti in the start object param name the name of the properti param start the object whose properti is be set param valu valu to set the properti to public void put string name scriptabl start object valu slot slot last access get local copi if name slot string kei slot wa delet 0 int hash name hash code slot get slot name hash if slot null if start thi start put name start valu return slot add slot name hash null note cach is not updat in put if start thi is seal throw context report runtim error1 msg modifi seal name if slot attribut scriptabl object readonli 0 return if slot instanceof getter slot getter slot gslot getter slot slot if gslot setter null set by setter gslot start valu return if thi start slot valu valu els start put name start valu 
set the valu of the index properti creat it if need be param index the numer index for the properti param start the object whose properti is be set param valu valu to set the properti to public void put int index scriptabl start object valu slot slot get slot null index if slot null if start thi start put index start valu return slot add slot null index null if start thi is seal throw context report runtim error1 msg modifi seal integ to string index if slot attribut scriptabl object readonli 0 return if thi start slot valu valu els start put index start valu 
remov a name properti from the object if the properti is not found or it ha the perman attribut no action is taken param name the name of the properti public void delet string name remov slot name name hash code 
remov the index properti from the object if the properti is not found or it ha the perman attribut no action is taken param index the numer index for the properti public void delet int index remov slot null index 
deprec us link get attribut string name the engin alwai ignor the start argument public final int get attribut string name scriptabl start return get attribut name 
deprec us link get attribut int index the engin alwai ignor the start argument public final int get attribut int index scriptabl start return get attribut index 
deprec us link set attribut string name int attribut the engin alwai ignor the start argument public final void set attribut string name scriptabl start int attribut set attribut name attribut 
deprec us link set attribut int index int attribut the engin alwai ignor the start argument public void set attribut int index scriptabl start int attribut set attribut index attribut 
get the attribut of a name properti the properti is specifi by code name code as defin for code ha code p param name the identifi for the properti return the bitset of attribut except evalu except if the name properti is not found see org mozilla javascript scriptabl object ha see org mozilla javascript scriptabl object readonli see org mozilla javascript scriptabl object dontenum see org mozilla javascript scriptabl object perman see org mozilla javascript scriptabl object empti public int get attribut string name slot slot get name slot name if slot null throw context report runtim error1 msg prop not found name return slot attribut 
get the attribut of an index properti param index the numer index for the properti except evalu except if the name properti is not found is not found return the bitset of attribut see org mozilla javascript scriptabl object ha see org mozilla javascript scriptabl object readonli see org mozilla javascript scriptabl object dontenum see org mozilla javascript scriptabl object perman see org mozilla javascript scriptabl object empti public int get attribut int index slot slot get slot null index if slot null throw context report runtim error1 msg prop not found string valu of index return slot attribut 
set the attribut of a name properti the properti is specifi by code name code as defin for code ha code p the possibl attribut ar readonli dontenum and perman combin of attribut ar express by the bitwis or of attribut empti is the state of no attribut set ani unus bit ar reserv for futur us param name the name of the properti param attribut the bitset of attribut except evalu except if the name properti is not found see org mozilla javascript scriptabl ha see org mozilla javascript scriptabl object readonli see org mozilla javascript scriptabl object dontenum see org mozilla javascript scriptabl object perman see org mozilla javascript scriptabl object empti public void set attribut string name int attribut check valid attribut attribut slot slot get name slot name if slot null throw context report runtim error1 msg prop not found name slot attribut short attribut 
set the attribut of an index properti param index the numer index for the properti param attribut the bitset of attribut except evalu except if the name properti is not found see org mozilla javascript scriptabl ha see org mozilla javascript scriptabl object readonli see org mozilla javascript scriptabl object dontenum see org mozilla javascript scriptabl object perman see org mozilla javascript scriptabl object empti public void set attribut int index int attribut check valid attribut attribut slot slot get slot null index if slot null throw context report runtim error1 msg prop not found string valu of index slot attribut short attribut 
return the prototyp of the object public scriptabl get prototyp return prototyp object 
set the prototyp of the object public void set prototyp scriptabl m prototyp object m 
return the parent enclos scope of the object public scriptabl get parent scope return parent scope object 
set the parent enclos scope of the object public void set parent scope scriptabl m parent scope object m 
return an arrai of id for the properti of the object p ani properti with the attribut dontenum ar not list p return an arrai of java lang object with an entri for everi list properti properti access via an integ index will have a correspond integ entri in the return arrai properti access by a string will have a string entri in the return arrai public object get id return get id fals 
return an arrai of id for the properti of the object p all properti even those with attribut dontenum ar list p return an arrai of java lang object with an entri for everi list properti properti access via an integ index will have a correspond integ entri in the return arrai properti access by a string will have a string entri in the return arrai public object get all id return get id true 
implement the default valu intern method p note that the to primit convers is a no op for everi type other than object for which default valu is call see ecma 9 1 p a code hint code of null mean no hint param type hint the type hint return the default valu for the object see ecma 8 6 2 6 public object get default valu class type hint context cx null for int i 0 i 2 i boolean try to string if type hint script runtim string class try to string i 0 els try to string i 1 string method name object arg if try to string method name to string arg script runtim empti arg els method name valu of arg new object 1 string hint if type hint null hint undefin els if type hint script runtim string class hint string els if type hint script runtim scriptabl class hint object els if type hint script runtim function class hint function els if type hint script runtim boolean class type hint boolean type hint boolean els if type hint script runtim number class type hint script runtim byte class type hint byte type type hint script runtim short class type hint short type type hint script runtim integ class type hint integ type type hint script runtim float class type hint float type type hint script runtim doubl class type hint doubl type hint number els throw context report runtim error1 msg invalid type type hint to string arg 0 hint object v get properti thi method name if v instanceof function continu function fun function v if cx null cx context get context v fun call cx fun get parent scope thi arg if v null if v instanceof scriptabl return v if type hint script runtim scriptabl class type hint script runtim function class return v if try to string v instanceof wrapper let a wrap java lang string pass for a primit string object u wrapper v unwrap if u instanceof string return u fall through to error string arg type hint null undefin type hint get name throw script runtim type error1 msg default valu arg 
implement the instanceof oper p thi oper ha been propos to ecma param instanc the valu that appear on the lh of the instanceof oper return true if thi appear in valu s prototyp chain public boolean ha instanc scriptabl instanc default for js object other than function is to do prototyp chase thi will be overridden in nativ function and non js object return script runtim js deleg to instanc thi 
custom tt tt oper must return link scriptabl not found if thi object doe not have custom equal oper for the given valu tt boolean true tt if thi object is equival to tt valu tt tt boolean fals tt if thi object is not equival to tt valu tt p the default implement return boolean true if tt thi valu tt or link scriptabl not found otherwis it indic that by default custom equal is avail onli if tt valu tt is tt thi tt in which case true is return protect object equival valu object valu return thi valu boolean true scriptabl not found 
defin java script object from a java class that implement scriptabl if the given class ha a method pre static void init context cx scriptabl scope boolean seal pre or it compat form pre static void init scriptabl scope pre then it is invok and no further initi is done p howev if no such a method is found then the class s constructor and method ar us to initi a class in the follow manner p first the zero paramet constructor of the class is call to creat the prototyp if no such constructor exist a link evalu except is thrown p next all method ar scan for special prefix that indic that thei have special mean for defin java script object these special prefix ar ul li code js function code for a java script function li code js static function code for a java script function that is a properti of the constructor li code js get code for a getter of a java script properti li code js set code for a setter of a java script properti li code js constructor code for a java script function that is the constructor ul p if the method s name begin with js function a java script function is creat with a name form from the rest of the java method name follow js function so a java method name js function foo will defin a java script method foo call thi java script function will caus the java method to be call the paramet of the method must be of number and type as defin by the function object class the java script function is then ad as a properti of the prototyp p if the method s name begin with js static function it is handl similarli except that the result java script function is ad as a properti of the constructor object the java method must be static if the method s name begin with js get or js set the method is consid to defin a properti access to the defin properti will result in call to these getter and setter method if no setter is defin the properti is defin as readonli p if the method s name is js constructor the method is consid to defin the bodi of the constructor onli on method of thi name mai be defin if no method is found that can serv as constructor a java constructor will be select to serv as the java script constructor in the follow manner if the class ha onli on java constructor that constructor is us to defin the java script constructor if the the class ha two constructor on must be the zero argument constructor otherwis an link evalu except would have alreadi been thrown when the prototyp wa to be creat in thi case the java constructor with on or more paramet will be us to defin the java script constructor if the class ha three or more constructor an link evalu except will be thrown p final if there is a method pre static void finish init scriptabl scope function object constructor scriptabl prototyp pre it will be call to finish ani initi the code scope code argument will be pass along with the newli creat constructor and the newli creat prototyp p param scope the scope in which to defin the constructor param clazz the java class to us to defin the java script object and properti except illeg access except if access is not avail to a reflect class member except instanti except if unabl to instanti the name class except invoc target except if an except is thrown dure execut of method of the name class see org mozilla javascript function see org mozilla javascript function object see org mozilla javascript scriptabl object readonli see org mozilla javascript scriptabl object defin properti public static void defin class scriptabl scope class clazz throw illeg access except instanti except invoc target except defin class scope clazz fals fals 
defin java script object from a java class option allow seal similar to code defin class scriptabl scope class clazz code except that seal is allow an object that is seal cannot have properti ad or remov note that seal is not allow in the current ecma iso languag specif but is like for the next version param scope the scope in which to defin the constructor param clazz the java class to us to defin the java script object and properti the class must implement scriptabl param seal whether or not to creat seal standard object that cannot be modifi except illeg access except if access is not avail to a reflect class member except instanti except if unabl to instanti the name class except invoc target except if an except is thrown dure execut of method of the name class sinc 1 4r3 public static void defin class scriptabl scope class clazz boolean seal throw illeg access except instanti except invoc target except defin class scope clazz seal fals 
defin java script object from a java class option allow seal and map of java inherit to java script prototyp base inherit similar to code defin class scriptabl scope class clazz code except that seal and inherit map ar allow an object that is seal cannot have properti ad or remov note that seal is not allow in the current ecma iso languag specif but is like for the next version param scope the scope in which to defin the constructor param clazz the java class to us to defin the java script object and properti the class must implement scriptabl param seal whether or not to creat seal standard object that cannot be modifi param map inherit whether or not to map java inherit to java script prototyp base inherit return the class name for the prototyp of the specifi class except illeg access except if access is not avail to a reflect class member except instanti except if unabl to instanti the name class except invoc target except if an except is thrown dure execut of method of the name class sinc 1 6r2 public static string defin class scriptabl scope class clazz boolean seal boolean map inherit throw illeg access except instanti except invoc target except method method function object get method list clazz for int i 0 i method length i method method method i if method get name equal init continu class parm type method get paramet type if parm type length 3 parm type 0 script runtim context class parm type 1 script runtim scriptabl class parm type 2 boolean type modifi is static method get modifi object arg context get context scope seal boolean true boolean fals method invok null arg return null if parm type length 1 parm type 0 script runtim scriptabl class modifi is static method get modifi object arg scope method invok null arg return null if we got here there isn t an init method with the right paramet type constructor ctor clazz get constructor constructor proto ctor null for int i 0 i ctor length i if ctor i get paramet type length 0 proto ctor ctor i break if proto ctor null throw context report runtim error1 msg zero arg ctor clazz get name scriptabl proto scriptabl proto ctor new instanc script runtim empti arg string class name proto get class name set the prototyp s prototyp try to map java inherit to js prototyp base inherit if request to do so scriptabl super proto null if map inherit class super class clazz get superclass if script runtim scriptabl class is assign from super class string name scriptabl object defin class scope super class seal map inherit if name null super proto scriptabl object get class prototyp scope name if super proto null super proto scriptabl object get object prototyp scope proto set prototyp super proto find out whether there ar ani method that begin with js if so then onli method that begin with special prefix will be defin as java script entiti final string function prefix js function final string static function prefix js static function final string getter prefix js get final string setter prefix js set final string ctor name js constructor member ctor member function object find singl method method ctor name if ctor member null if ctor length 1 ctor member ctor 0 els if ctor length 2 if ctor 0 get paramet type length 0 ctor member ctor 1 els if ctor 1 get paramet type length 0 ctor member ctor 0 if ctor member null throw context report runtim error1 msg ctor multipl parm clazz get name function object ctor new function object class name ctor member scope if ctor is var arg method throw context report runtim error1 msg vararg ctor ctor member get name ctor add as constructor scope proto method finish init null for int i 0 i method length i if method i ctor member continu string name method i get name if name equal finish init class parm type method i get paramet type if parm type length 3 parm type 0 script runtim scriptabl class parm type 1 function object class parm type 2 script runtim scriptabl class modifi is static method i get modifi finish init method i continu ignor ani compil gener method if name index of 1 continu if name equal ctor name continu string prefix null if name start with function prefix prefix function prefix els if name start with static function prefix prefix static function prefix if modifi is static method i get modifi throw context report runtim error js static function must be us with static method els if name start with getter prefix prefix getter prefix els if name start with setter prefix prefix setter prefix els continu name name substr prefix length if prefix setter prefix continu deal with set when we see get if prefix getter prefix if proto instanceof scriptabl object throw context report runtim error2 msg extend scriptabl proto get class to string name method setter function object find singl method method setter prefix name int attr scriptabl object perman scriptabl object dontenum setter null 0 scriptabl object readonli scriptabl object proto defin properti name null method i setter attr continu function object f new function object name method i proto if f is var arg constructor throw context report runtim error1 msg vararg fun ctor member get name scriptabl dest prefix static function prefix ctor proto defin properti dest name f dontenum if seal f seal object call user code to complet initi if necessari if finish init null object finish arg scope ctor proto finish init invok null finish arg seal the object if necessari if seal ctor seal object if proto instanceof scriptabl object scriptabl object proto seal object return class name 
defin a java script properti creat the properti with an initi valu and set it attribut param properti name the name of the properti to defin param valu the initi valu of the properti param attribut the attribut of the java script properti see org mozilla javascript scriptabl put public void defin properti string properti name object valu int attribut put properti name thi valu set attribut properti name attribut 
util method to add properti to arbitrari scriptabl object if destin is instanc of scriptabl object call defin properti there otherwis call put in destin ignor attribut public static void defin properti scriptabl destin string properti name object valu int attribut if destin instanceof scriptabl object destin put properti name destin valu return scriptabl object so scriptabl object destin so defin properti properti name valu attribut 
defin a java script properti with getter and setter side effect if the setter is not found the attribut readonli is ad to the given attribut p the getter must be a method with zero paramet and the setter if found must be a method with on paramet p param properti name the name of the properti to defin thi name also affect the name of the setter and getter to search for if the properti id is foo then code clazz code will be search for get foo and set foo method param clazz the java class to search for the getter and setter param attribut the attribut of the java script properti see org mozilla javascript scriptabl put public void defin properti string properti name class clazz int attribut int length properti name length if length 0 throw new illeg argument except char buf new char 3 length properti name get char 0 length buf 3 buf 3 charact to upper case buf 3 buf 0 g buf 1 e buf 2 t string getter name new string buf buf 0 s string setter name new string buf method method function object get method list clazz method getter function object find singl method method getter name method setter function object find singl method method setter name if setter null attribut scriptabl object readonli defin properti properti name null getter setter null null setter attribut 
defin a java script properti us thi method onli if you wish to defin getter and setter for a given properti in a scriptabl object to creat a properti without special getter or setter side effect us code defin properti string int code if code setter code is null the attribut readonli is ad to the given attribut p sever form of getter or setter ar allow in all case the type of the valu paramet can be ani on of the follow type object string boolean scriptabl byte short int long float or doubl the runtim will perform appropri convers base upon the type of the paramet see descript in function object the first form ar nonstat method of the class refer to by thi pre object get foo void set foo some type valu pre next ar static method that mai be of ani class the object whose properti is be access is pass in as an extra argument pre static object get foo scriptabl object obj static void set foo scriptabl object obj some type valu pre final it is possibl to deleg to anoth object entir us the code deleg to code paramet in thi case the method ar nonstat method of the class deleg to and the object whose properti is be access is pass in as an extra argument pre object get foo scriptabl object obj void set foo scriptabl object obj some type valu pre param properti name the name of the properti to defin param deleg to an object to call the getter and setter method on or null depend on the form us abov param getter the method to invok to get the valu of the properti param setter the method to invok to set the valu of the properti param attribut the attribut of the java script properti public void defin properti string properti name object deleg to method getter method setter int attribut if deleg to null modifi is static getter get modifi deleg to ha static accessor class parm type getter get paramet type if parm type length 0 if parm type length 1 parm type 0 script runtim scriptabl object class throw context report runtim error1 msg bad getter parm getter to string els if deleg to null throw context report runtim error1 msg obj getter parm getter to string if setter null if deleg to ha static accessor modifi is static setter get modifi throw context report runtim error0 msg getter static parm type setter get paramet type if parm type length 2 if parm type 0 script runtim scriptabl object class throw context report runtim error0 msg setter2 parm if deleg to null throw context report runtim error1 msg setter1 parm setter to string els if parm type length 1 if deleg to null throw context report runtim error1 msg setter2 expect setter to string els throw context report runtim error0 msg setter parm class setter type parm type parm type length 1 int setter type tag function object get type tag setter type if setter type tag function object java unsupport type throw context report runtim error2 msg setter2 expect setter type get name setter to string getter slot gslot new getter slot gslot deleg to deleg to gslot getter new member box getter if setter null gslot setter new member box setter gslot attribut short attribut slot insert add slot properti name properti name hash code gslot if insert gslot throw new runtim except properti alreadi exist 
search for name in a class ad the result method as properti p us reflect to find the method of the given name then function object ar construct from the method found and ar ad to thi object as properti with the given name param name the name of the method to add as function properti param clazz the class to search for the method param attribut the attribut of the new properti see org mozilla javascript function object public void defin function properti string name class clazz int attribut method method function object get method list clazz for int i 0 i name length i string name name i method m function object find singl method method name if m null throw context report runtim error2 msg method not found name clazz get name function object f new function object name m thi defin properti name f attribut 
get the object prototyp properti see ecma 15 2 4 public static scriptabl get object prototyp scriptabl scope return get class prototyp scope object 
get the function prototyp properti see ecma 15 3 4 public static scriptabl get function prototyp scriptabl scope return get class prototyp scope function 
get the prototyp for the name class for exampl code get class prototyp s date code will first walk up the parent chain to find the outermost scope then will search that scope for the date constructor and then will return date prototyp if ani of the lookup fail or the prototyp is not a java script object then null will be return param scope an object in the scope chain param class name the name of the constructor return the prototyp for the name class or null if it cannot be found public static scriptabl get class prototyp scriptabl scope string class name scope get top level scope scope object ctor get properti scope class name object proto if ctor instanceof base function proto base function ctor get prototyp properti els if ctor instanceof scriptabl scriptabl ctor obj scriptabl ctor proto ctor obj get prototyp ctor obj els return null if proto instanceof scriptabl return scriptabl proto return null 
get the global scope p walk the parent scope chain to find an object with a null parent scope the global object param obj a java script object return the correspond global scope public static scriptabl get top level scope scriptabl obj for scriptabl parent obj get parent scope if parent null return obj obj parent 
seal thi object a seal object mai not have properti ad or remov onc an object is seal it mai not be unseal sinc 1 4r3 public synchron void seal object if count 0 count 1 count 
return true if thi object is seal it is an error to attempt to add or remov properti to a seal object return true if seal fals otherwis sinc 1 4r3 public final boolean is seal return count 0 
get a name properti from an object or ani object in it prototyp chain p search the prototyp chain for a properti name code name code p param obj a java script object param name a properti name return the valu of a properti with name code name code found in code obj code or ani object in it prototyp chain or code scriptabl not found code if not found sinc 1 5r2 public static object get properti scriptabl obj string name scriptabl start obj object result do result obj get name start if result scriptabl not found break obj obj get prototyp while obj null return result 
get an index properti from an object or ani object in it prototyp chain p search the prototyp chain for a properti with integr index code index code note that if you wish to look for properti with numer but non integr indici you should us get properti scriptabl string with the string valu of the index p param obj a java script object param index an integr index return the valu of a properti with index code index code found in code obj code or ani object in it prototyp chain or code scriptabl not found code if not found sinc 1 5r2 public static object get properti scriptabl obj int index scriptabl start obj object result do result obj get index start if result scriptabl not found break obj obj get prototyp while obj null return result 
return whether a name properti is defin in an object or ani object in it prototyp chain p search the prototyp chain for a properti name code name code p param obj a java script object param name a properti name return the true if properti wa found sinc 1 5r2 public static boolean ha properti scriptabl obj string name return null get base obj name 
return whether an index properti is defin in an object or ani object in it prototyp chain p search the prototyp chain for a properti with index code index code p param obj a java script object param index a properti index return the true if properti wa found sinc 1 5r2 public static boolean ha properti scriptabl obj int index return null get base obj index 
put a name properti in an object or in an object in it prototyp chain p seach for the name properti in the prototyp chain if it is found the valu of the properti in code obj code is chang through a call to link scriptabl put string scriptabl object on the prototyp pass code obj code as the code start code argument thi allow the prototyp to veto the properti set in case the prototyp defin the properti with read onli attribut if the properti is not found it is ad in code obj code param obj a java script object param name a properti name param valu ani java script valu accept by scriptabl put sinc 1 5r2 public static void put properti scriptabl obj string name object valu scriptabl base get base obj name if base null base obj base put name obj valu 
put an index properti in an object or in an object in it prototyp chain p seach for the index properti in the prototyp chain if it is found the valu of the properti in code obj code is chang through a call to link scriptabl put int scriptabl object on the prototyp pass code obj code as the code start code argument thi allow the prototyp to veto the properti set in case the prototyp defin the properti with read onli attribut if the properti is not found it is ad in code obj code param obj a java script object param index a properti index param valu ani java script valu accept by scriptabl put sinc 1 5r2 public static void put properti scriptabl obj int index object valu scriptabl base get base obj index if base null base obj base put index obj valu 
remov the properti from an object or it prototyp chain p search for a properti with code name code in obj or it prototyp chain if it is found the object s delet method is call param obj a java script object param name a properti name return true if the properti doesn t exist or wa successfulli remov sinc 1 5r2 public static boolean delet properti scriptabl obj string name scriptabl base get base obj name if base null return true base delet name return base ha name obj 
remov the properti from an object or it prototyp chain p search for a properti with code index code in obj or it prototyp chain if it is found the object s delet method is call param obj a java script object param index a properti index return true if the properti doesn t exist or wa successfulli remov sinc 1 5r2 public static boolean delet properti scriptabl obj int index scriptabl base get base obj index if base null return true base delet index return base ha index obj 
return an arrai of all id from an object and it prototyp p param obj a java script object return an arrai of all id from all object in the prototyp chain if a given id occur multipl time in the prototyp chain it will occur onli onc in thi list sinc 1 5r2 public static object get properti id scriptabl obj if obj null return script runtim empti arg object result obj get id obj to int map map null for obj obj get prototyp if obj null break object id obj get id if id length 0 continu if map null if result length 0 result id continu map new obj to int map result length id length for int i 0 i result length i map intern result i result null allow to gc the result for int i 0 i id length i map intern id i if map null result map get kei return result 
call a method of an object param obj the java script object param method name the name of the function properti param arg the argument for the call see context get current context public static object call method scriptabl obj string method name object arg return call method null obj method name arg 
call a method of an object param cx the context object associ with the current thread param obj the java script object param method name the name of the function properti param arg the argument for the call public static object call method context cx scriptabl obj string method name object arg object fun obj get properti obj method name if fun obj instanceof function throw script runtim not function error obj method name function fun function fun obj xxx what should be the scope when call fun obj the follow favor scope store in the object on the assumpt that is more us especi under dynam scope setup an altern is to check for dynam scope flag and us scriptabl object get top level scope fun if the flag is not set but that requir access to context and messi code so for now it is not check scriptabl scope scriptabl object get top level scope obj if cx null return fun call cx scope obj arg els return context call null fun scope obj arg 
privat static scriptabl get base scriptabl obj string name do if obj ha name obj break obj obj get prototyp while obj null return obj 
privat static scriptabl get base scriptabl obj int index do if obj ha index obj break obj obj get prototyp while obj null return obj 
get arbitrari applic specif valu associ with thi object param kei kei object to select particular valu see associ valu object kei object valu public final object get associ valu object kei hashtabl h associ valu if h null return null return h get kei 
get arbitrari applic specif valu associ with the top scope of the given scope the method first call link get top level scope scriptabl scope and then search the prototyp chain of the top scope for the first object contain the associ valu with the given kei param scope the start scope param kei kei object to select particular valu see get associ valu object kei public static object get top scope valu scriptabl scope object kei scope scriptabl object get top level scope scope for if scope instanceof scriptabl object scriptabl object so scriptabl object scope object valu so get associ valu kei if valu null return valu scope scope get prototyp if scope null return null 
associ arbitrari applic specif valu with thi object valu can onli be associ with the given object and kei onli onc the method ignor ani subsequ attempt to chang the alreadi associ valu p the associ valu ar not seril param kei kei object to select particular valu param valu the valu to associ return the pass valu if the method is call first time for the given kei or old valu for ani subsequ call see get associ valu object kei public final object associ valu object kei object valu if valu null throw new illeg argument except hashtabl h associ valu if h null synchron thi h associ valu if h null h new hashtabl associ valu h return kit init hash h kei valu 
privat object get by getter getter slot slot scriptabl start object getter thi object arg if slot deleg to null if start thi walk the prototyp chain to find an appropri object to invok the getter on class clazz slot getter get declar class while clazz is instanc start start start get prototyp if start thi break if start null start thi break getter thi start arg script runtim empti arg els getter thi slot deleg to arg new object thi return slot getter invok getter thi arg 
privat void set by setter getter slot slot scriptabl start object valu if start thi if slot deleg to null slot setter get declar class is instanc start start put slot string kei start valu return object setter thi object arg object setter result context cx context get context class p type slot setter arg type class desir p type p type length 1 alert cach tag sinc it is alreadi calcul in defin properti int tag function object get type tag desir object actual arg function object convert arg cx start valu tag if slot deleg to null setter thi start arg new object actual arg els if start thi kit code bug setter thi slot deleg to arg new object thi actual arg check start is seal start is alwai instanc of scriptabl object due to logic in if start thi abov if scriptabl object start is seal throw context report runtim error1 msg modifi seal slot string kei setter result slot setter invok setter thi arg if slot setter method get return type void type replac getter slot by a simpl on slot replac new slot replac int kei slot int kei replac string kei slot string kei replac attribut slot attribut replac valu setter result synchron thi int i get slot posit slot slot string kei slot int kei check slot wa not delet replac befor synchron if i 0 slot i slot slot i replac it is import to make sure that last access slot to prevent access the old slot via last access and then invok setter on more time last access replac 
privat slot get name slot string name queri last access cach and check that it wa not delet slot slot last access if name slot string kei slot wa delet 0 return slot int hash name hash code slot slot thi slot get stabl local refer int i get slot posit slot name hash if i 0 return null slot slot i updat cach here string kei equal name hold but it can be that slot string kei name to make last name cach work need to chang the kei slot string kei name last access slot return slot 
privat slot get slot string id int index slot slot thi slot get local copi int i get slot posit slot id index return i 0 null slot i 
privat static int get slot posit slot slot string id int index if slot null int start index 0x7fffffff slot length int i start do slot slot slot i if slot null break if slot remov slot int kei index slot string kei id id null id equal slot string kei return i if i slot length i 0 while i start return 1 
add a new slot to the hash tabl thi method must be synchron sinc it is alter the hash tabl itself note that we search again for the slot to set sinc anoth thread could have ad the given properti or caus the tabl to grow while thi thread wa search privat synchron slot add slot string id int index slot new slot if is seal string str id null id integ to string index throw context report runtim error1 msg add seal str if slot null slot new slot 5 return add slot impl id index new slot 
must be insid synchron thi privat slot add slot impl string id int index slot new slot int start index 0x7fffffff slot length int i start for slot slot slot i if slot null slot remov if 4 count 1 3 slot length grow return add slot impl id index new slot slot new slot null new slot new slot slot string kei id slot int kei index slot i slot count return slot if slot int kei index slot string kei id id null id equal slot string kei return slot if i slot length i 0 if i start slot should never be full or bug in grow code throw new illeg state except 
remov a slot from the hash tabl thi method must be synchron sinc it is alter the hash tabl itself we might be abl to optim thi more but delet ar not common privat synchron void remov slot string name int index if is seal string str name null name integ to string index throw context report runtim error1 msg remov seal str int i get slot posit slot name index if i 0 slot slot slot i if slot attribut perman 0 mark the slot as remov to handl a case when anoth thread manag to put just remov slot into last access cach slot wa delet byte 1 if slot last access last access remov count if count 0 slot i remov els with no slot it is ok to mark with null slot i null 
must be insid synchron thi privat void grow slot new slot new slot slot length 2 1 for int j slot length 1 j 0 j slot slot slot j if slot null slot remov continu int k slot int kei 0x7fffffff new slot length while new slot k null if k new slot length k 0 the end of the synchron statement will caus the memori write to be propag on a multiprocessor machin we want to make sure that the new tabl is prepar to be read xxx caus the thi pointer to be null in call stack frame on the ms jvm synchron slot new slot k slot slot new slot 
object get id boolean get all slot s slot object a script runtim empti arg if s null return a int c 0 for int i 0 i s length i slot slot s i if slot null slot remov continu if get all slot attribut dontenum 0 if c 0 a new object s length i a c slot string kei null object slot string kei new integ slot int kei if c a length return a object result new object c system arraycopi a 0 result 0 c return result 
privat synchron void write object object output stream out throw ioexcept out default write object int n count if n 0 n 1 count slot s slot if s null if n 0 kit code bug out write int 0 els out write int s length for int i 0 n 0 i slot slot s i if slot null slot remov n out write object slot 
privat void read object object input stream in throw ioexcept class not found except in default read object last access remov int capac in read int if capac 0 slot new slot capac int n count boolean wa seal fals if n 0 n 1 n wa seal true count 0 for int i 0 i n i slot s slot in read object add slot impl s string kei s int kei s if wa seal count 1 count 
privat void read object object input stream in throw ioexcept class not found except in default read object if string kei null int kei string kei hash code 
static void init scriptabl scope boolean seal nativ number obj new nativ number 0 0 obj export as jsclass max prototyp id scope seal 
privat nativ number doubl number doubl valu number 
public string get class name return number 
protect void fill constructor properti id function object ctor final int attr scriptabl object dontenum scriptabl object perman scriptabl object readonli ctor defin properti na n script runtim na nobj attr ctor defin properti posit infin script runtim wrap number doubl posit infin attr ctor defin properti neg infin script runtim wrap number doubl neg infin attr ctor defin properti max valu script runtim wrap number doubl max valu attr ctor defin properti min valu script runtim wrap number doubl min valu attr super fill constructor properti ctor 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 1 s to string break case id to local string ariti 1 s to local string break case id to sourc ariti 0 s to sourc break case id valu of ariti 0 s valu of break case id to fix ariti 1 s to fix break case id to exponenti ariti 1 s to exponenti break case id to precis ariti 1 s to precis break default throw new illeg argument except string valu of id init prototyp method number tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag number tag return super exec id call f cx scope thi obj arg int id f method id if id id constructor doubl val arg length 1 script runtim to number arg 0 0 0 if thi obj null new number val creat a new number object return new nativ number val number val convert val to a number valu return script runtim wrap number val the rest of number prototyp method requir thi obj to be number if thi obj instanceof nativ number throw incompat call error f doubl valu nativ number thi obj doubl valu switch id case id to string case id to local string to local string is just an alia for to string for now int base arg length 0 10 script runtim to int32 arg 0 return script runtim number to string valu base case id to sourc return new number script runtim to string valu case id valu of return script runtim wrap number valu case id to fix return num to valu arg dto a dtostr fix dto a dtostr fix 20 0 case id to exponenti return num to valu arg dto a dtostr standard exponenti dto a dtostr exponenti 0 1 case id to precis return num to valu arg dto a dtostr standard dto a dtostr precis 1 0 default throw new illeg argument except string valu of id 
public string to string return script runtim number to string doubl valu 10 
privat static string num to doubl val object arg int zero arg mode int on arg mode int precis min int precis offset int precis if arg length 0 precis 0 on arg mode zero arg mode els we allow a larger rang of precis than ecma requir thi is permit by ecma precis script runtim to int32 arg 0 if precis precis min precis max precis string msg script runtim get message1 msg bad precis script runtim to string arg 0 throw script runtim construct error rang error msg string buffer sb new string buffer dto a js dtostr sb on arg mode precis precis offset val return sb to string 
protect int find prototyp id string s int id gener last updat 2004 03 17 13 41 35 cet l0 id 0 string x null int c l switch s length case 7 c s char at 0 if c t x to fix id id to fix els if c v x valu of id id valu of break l case 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string break l case 11 c s char at 0 if c c x constructor id id constructor els if c t x to precis id id to precis break l case 13 x to exponenti id id to exponenti break l case 14 x to local string id id to local string break l if x null x s x equal s id 0 gener return id 
public class data type 009 extend live connect test public data type 009 super 
public static void main string arg data type 009 test new data type 009 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt static get char arrai true do arrai test dt pub static arrai char true do arrai test dt get char arrai true do arrai test dt pub arrai char fals 
assign a java arrai to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command the command to eval to get the arrai public void do arrai test string command boolean should equal char arrai data type class pub static arrai char char js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java object js arrai char global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai doubl item doubl global eval js arrai i add test case js arrai command global eval js arrai i equal arrai i true item equal new doubl arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal true fals js arrai arrai 
creat a new context note that the context must be associ with a thread befor it can be us to execut a script see enter see call context action public context set languag version version default optim level codegen class null 0 1 maximum interpret stack depth integ max valu 
get the current context the current context is per thread thi method look up the context associ with the current thread p return the context associ with the current thread or null if no context is associ with the current thread see org mozilla javascript context enter see org mozilla javascript context exit public static context get current context object helper vmbridg instanc get thread context helper return vmbridg instanc get context helper 
get a context associ with the current thread creat on if need be the context store the execut state of the java script engin so it is requir that the context be enter befor execut mai begin onc a thread ha enter a context then get current context mai be call to find the context that is associ with the current thread p call code enter code will return either the context current associ with the thread or will creat a new context and associ it with the current thread each call to code enter code must have a match call to code exit code for exampl pre context cx context enter try cx evalu string final context exit pre instead of us tt enter tt tt exit tt pair consid us link call context action which guarante proper associ of context instanc with the current thread and is faster with thi method the abov exampl becom pre context call new context action public object run context cx cx evalu string return null pre return a context associ with the current thread see get current context see exit see call context action public static context enter return enter null 
get a context associ with the current thread us the given context if need be p the same as code enter code except that code cx code is associ with the current thread and return if the current thread ha no associ context and code cx code is not associ with ani other thread param cx a context to associ with the thread if possibl return a context associ with the current thread see enter see call context action see context factori call context action public static context enter context cx return enter cx context factori get global 
static final context enter context cx context factori factori object helper vmbridg instanc get thread context helper context old vmbridg instanc get context helper if old null if cx null cx old cx enter count 0 the supli context must be the context for the current thread if it is alreadi enter throw new illeg argument except cannot enter context activ on anoth thread if old factori null context with associ factori will be releas automat and doe not need to chang enter count return old if old seal on seal mutat cx old els if cx null cx factori make context els if cx seal on seal mutat if cx enter count 0 cx factori null throw new illeg state except if cx creation event wa sent cx creation event wa sent true factori on context creat cx if old null vmbridg instanc set context helper cx cx enter count return cx 
exit a block of code requir a context call code exit code will remov the associ between the current thread and a context if the prior call to code enter code on thi thread newli associ a context with thi thread onc the current thread no longer ha an associ context it cannot be us to execut java script until it is again associ with a context see org mozilla javascript context enter see call context action see context factori call context action public static void exit exit context factori get global 
static void exit context factori factori object helper vmbridg instanc get thread context helper context cx vmbridg instanc get context helper if cx null throw new illeg state except call context exit without previou context enter if cx factori null context with associ factori will be releas automat and doe not need to chang enter count return if cx enter count 1 kit code bug if cx seal on seal mutat cx enter count if cx enter count 0 vmbridg instanc set context helper null factori on context releas cx 
call link context action run context cx us the context instanc associ with the current thread if no context is associ with the thread then tt context factori get global make context tt will be call to construct new context instanc the instanc will be temporari associ with the thread dure call to link context action run context return the result of link context action run context public static object call context action action return call context factori get global action 
call link callabl call context cx scriptabl scope scriptabl thi obj object arg us the context instanc associ with the current thread if no context is associ with the thread then link context factori make context will be call to construct new context instanc the instanc will be temporari associ with the thread dure call to link context action run context p it is allow to us null for tt factori tt argument in which case the factori associ with the scope will be us to creat new context instanc see context factori call context action public static object call context factori factori callabl callabl scriptabl scope scriptabl thi obj object arg if factori null factori context factori get global object helper vmbridg instanc get thread context helper context cx vmbridg instanc get context helper if cx null object result if cx factori null result callabl call cx scope thi obj arg els context wa associ with the thread via context enter set factori to make context enter exit to be no op dure call cx factori factori try result callabl call cx scope thi obj arg final cx factori null return result cx prepar new context factori helper try return callabl call cx scope thi obj arg final releas context helper cx 
the method implement link context factori call context action logic static object call context factori factori context action action object helper vmbridg instanc get thread context helper context cx vmbridg instanc get context helper if cx null if cx factori null return action run cx els cx factori factori try return action run cx final cx factori null cx prepar new context factori helper try return action run cx final releas context helper cx 
privat static context prepar new context context factori factori object context helper context cx factori make context if cx factori null cx enter count 0 throw new illeg state except factori make context return context instanc alreadi associ with some thread cx factori factori factori on context creat cx if factori is seal cx is seal cx seal null vmbridg instanc set context context helper cx return cx 
privat static void releas context object context helper context cx vmbridg instanc set context context helper null try cx factori on context releas cx final cx factori null 
deprec see context factori add listen context factori listen see context factori get global public static void add context listen context listen listen special workaround for the debugg string dbg org mozilla javascript tool debugg main if dbg equal listen get class get name class cl listen get class class factori class kit class or null org mozilla javascript context factori class sig factori class object arg context factori get global try method m cl get method attach to sig m invok listen arg catch except ex runtim except rex new runtim except kit init caus rex ex throw rex return context factori get global add listen listen 
deprec see context factori remov listen context factori listen see context factori get global public static void remov context listen context listen listen context factori get global add listen listen 
return link context factori instanc us to creat thi context or the result of link context factori get global if no factori wa us for context creation public final context factori get factori context factori result factori if result null result context factori get global return result 
check if thi is a seal context a seal context instanc doe not allow to modifi ani of it properti and will throw an except on ani such attempt see seal object seal kei public final boolean is seal return seal 
seal thi context object so ani attempt to modifi ani of it properti includ call link enter and link exit method will throw an except p if tt seal kei tt is not null call link unseal object seal kei with the same kei unseal the object if tt seal kei tt is null unseal is no longer possibl see is seal see unseal object public final void seal object seal kei if seal on seal mutat seal true thi seal kei seal kei 
unseal previous seal context object the tt seal kei tt argument should not be null and should match tt seal kei tt supli with the last call to link seal object or an except will be thrown see is seal see seal object seal kei public final void unseal object seal kei if seal kei null throw new illeg argument except if thi seal kei seal kei throw new illeg argument except if seal throw new illeg state except seal fals thi seal kei null 
static void on seal mutat throw new illeg state except 
get the current languag version p the languag version number affect java script semant as detail in the overview document return an integ that is on of version 1 0 version 1 1 etc public final int get languag version return version 
set the languag version p set the languag version will affect function and script compil subsequ see the overview document for version specif behavior param version the version as specifi by version 1 0 version 1 1 etc public void set languag version int version if seal on seal mutat check languag version version object listen properti listen if listen null version thi version fire properti chang impl listen languag version properti new integ thi version new integ version thi version version 
public static boolean is valid languag version int version switch version case version default case version 1 0 case version 1 1 case version 1 2 case version 1 3 case version 1 4 case version 1 5 case version 1 6 return true return fals 
public static void check languag version int version if is valid languag version version return throw new illeg argument except bad languag version version 
get the implement version p the implement version is of the form pre i name lang ver i code releas code i rel num date i pre where i name i is the name of the product i lang ver i is the languag version i rel num i is the releas number and i date i is the releas date for that specif releas in the form yyyi mm dd return a string that encod the product languag version releas number and date public final string get implement version xxx probabl it would be better to emb thi directli into sourc with special build preprocess but that would requir some ant tweak and then replac token in resourc file wa simpler if implement version null implement version script runtim get message0 implement version return implement version 
get the current error report see org mozilla javascript error report public final error report get error report if error report null return default error report instanc return error report 
chang the current error report return the previou error report see org mozilla javascript error report public final error report set error report error report report if seal on seal mutat if report null throw new illeg argument except error report old get error report if report old return old object listen properti listen if listen null fire properti chang impl listen error report properti old report thi error report report return old 
get the current local return the default local if none ha been set see java util local public final local get local if local null local local get default return local 
set the current local see java util local public final local set local local loc if seal on seal mutat local result local local loc return result 
regist an object to receiv notif when a bound properti ha chang see java bean properti chang event see remov properti chang listen java bean properti chang listen param l the listen public final void add properti chang listen properti chang listen l if seal on seal mutat properti listen kit add listen properti listen l 
remov an object from the list of object regist to receiv notif of chang to a bound properti see java bean properti chang event see add properti chang listen java bean properti chang listen param l the listen public final void remov properti chang listen properti chang listen l if seal on seal mutat properti listen kit remov listen properti listen l 
notifi ani regist listen that a bound properti ha chang see add properti chang listen java bean properti chang listen see remov properti chang listen java bean properti chang listen see java bean properti chang listen see java bean properti chang event param properti the bound properti param old valu the old valu param new vale the new valu final void fire properti chang string properti object old valu object new valu object listen properti listen if listen null fire properti chang impl listen properti old valu new valu 
privat void fire properti chang impl object listen string properti object old valu object new valu for int i 0 i object l kit get listen listen i if l null break if l instanceof properti chang listen properti chang listen pcl properti chang listen l pcl properti chang new properti chang event thi properti old valu new valu 
report a warn us the error report for the current thread param messag the warn messag to report param sourc name a string describ the sourc such as a filenam param lineno the start line number param line sourc the text of the line mai be null param line offset the offset into line sourc where problem wa detect see org mozilla javascript error report public static void report warn string messag string sourc name int lineno string line sourc int line offset context cx context get context cx get error report warn messag sourc name lineno line sourc line offset 
report a warn us the error report for the current thread param messag the warn messag to report see org mozilla javascript error report public static void report warn string messag int linep 0 string filenam get sourc posit from stack linep context report warn messag filenam linep 0 null 0 
report an error us the error report for the current thread param messag the error messag to report param sourc name a string describ the sourc such as a filenam param lineno the start line number param line sourc the text of the line mai be null param line offset the offset into line sourc where problem wa detect see org mozilla javascript error report public static void report error string messag string sourc name int lineno string line sourc int line offset context cx get current context if cx null cx get error report error messag sourc name lineno line sourc line offset els throw new evalu except messag sourc name lineno line sourc line offset 
report an error us the error report for the current thread param messag the error messag to report see org mozilla javascript error report public static void report error string messag int linep 0 string filenam get sourc posit from stack linep context report error messag filenam linep 0 null 0 
report a runtim error us the error report for the current thread param messag the error messag to report param sourc name a string describ the sourc such as a filenam param lineno the start line number param line sourc the text of the line mai be null param line offset the offset into line sourc where problem wa detect return a runtim except that will be thrown to termin the execut of the script see org mozilla javascript error report public static evalu except report runtim error string messag string sourc name int lineno string line sourc int line offset context cx get current context if cx null return cx get error report runtim error messag sourc name lineno line sourc line offset els throw new evalu except messag sourc name lineno line sourc line offset 
static evalu except report runtim error0 string messag id string msg script runtim get message0 messag id return report runtim error msg 
static evalu except report runtim error1 string messag id object arg1 string msg script runtim get message1 messag id arg1 return report runtim error msg 
static evalu except report runtim error2 string messag id object arg1 object arg2 string msg script runtim get message2 messag id arg1 arg2 return report runtim error msg 
static evalu except report runtim error3 string messag id object arg1 object arg2 object arg3 string msg script runtim get message3 messag id arg1 arg2 arg3 return report runtim error msg 
static evalu except report runtim error4 string messag id object arg1 object arg2 object arg3 object arg4 string msg script runtim get message4 messag id arg1 arg2 arg3 arg4 return report runtim error msg 
report a runtim error us the error report for the current thread param messag the error messag to report see org mozilla javascript error report public static evalu except report runtim error string messag int linep 0 string filenam get sourc posit from stack linep return context report runtim error messag filenam linep 0 null 0 
initi the standard object creat instanc of the standard object and their constructor object string number date etc set up scope to act as a global object as in ecma 15 1 p thi method must be call to initi a scope befor script can be evalu in that scope p thi method doe not affect the context it is call upon return the initi scope public final scriptabl object init standard object return init standard object null fals 
initi the standard object creat instanc of the standard object and their constructor object string number date etc set up scope to act as a global object as in ecma 15 1 p thi method must be call to initi a scope befor script can be evalu in that scope p thi method doe not affect the context it is call upon param scope the scope to initi or null in which case a new object will be creat to serv as the scope return the initi scope the method return the valu of the scope argument if it is not null or newli alloc scope object which is an instanc link scriptabl object public final scriptabl init standard object scriptabl object scope return init standard object scope fals 
initi the standard object creat instanc of the standard object and their constructor object string number date etc set up scope to act as a global object as in ecma 15 1 p thi method must be call to initi a scope befor script can be evalu in that scope p thi method doe not affect the context it is call upon p thi form of the method also allow for creat seal standard object an object that is seal cannot have properti ad chang or remov thi is us to creat a superglob that can be share among sever top level object note that seal is not allow in the current ecma iso languag specif but is like for the next version param scope the scope to initi or null in which case a new object will be creat to serv as the scope param seal whether or not to creat seal standard object that cannot be modifi return the initi scope the method return the valu of the scope argument if it is not null or newli alloc scope object sinc 1 4r3 public scriptabl object init standard object scriptabl object scope boolean seal return script runtim init standard object thi scope seal 
get the singleton object that repres the java script undefin valu public static object get undefin valu return undefin instanc 
evalu a java script sourc string the provid sourc name and line number ar us for error messag and for produc debug inform param scope the scope to execut in param sourc the java script sourc param sourc name a string describ the sourc such as a filenam param lineno the start line number param secur domain an arbitrari object that specifi secur inform about the origin or owner of the script for implement that don t care about secur thi valu mai be null return the result of evalu the string see org mozilla javascript secur control public final object evalu string scriptabl scope string sourc string sourc name int lineno object secur domain script script compil string sourc sourc name lineno secur domain if script null return script exec thi scope els return null 
evalu a reader as java script sourc all charact of the reader ar consum param scope the scope to execut in param in the reader to get java script sourc from param sourc name a string describ the sourc such as a filenam param lineno the start line number param secur domain an arbitrari object that specifi secur inform about the origin or owner of the script for implement that don t care about secur thi valu mai be null return the result of evalu the sourc except ioexcept if an ioexcept wa gener by the reader public final object evalu reader scriptabl scope reader in string sourc name int lineno object secur domain throw ioexcept script script compil reader scope in sourc name lineno secur domain if script null return script exec thi scope els return null 
check whether a string is readi to be compil p string is compil unit is intend to support interact compil of javascript if compil the string would result in an error that might be fix by append more sourc thi method return fals in everi other case it return true p interact shell mai accumul sourc line us thi method after each new line is append to check whether the statement be enter is complet param sourc the sourc buffer to check return whether the sourc is readi for compil sinc 1 4 releas 2 public final boolean string is compil unit string sourc boolean errorseen fals compil environ compil env new compil environ compil env init from context thi no sourc name or sourc text manag becaus we re just go to throw awai the result compil env set gener sourc fals parser p new parser compil env default error report instanc try p pars sourc null 1 catch evalu except ee errorseen true return fals onli if an error occur as a result of read past the end of the file i e if the sourc could be fix by append more sourc if errorseen p eof return fals els return true 
deprec see compil reader reader in string sourc name int lineno object secur domain public final script compil reader scriptabl scope reader in string sourc name int lineno object secur domain throw ioexcept return compil reader in sourc name lineno secur domain 
compil the sourc in the given reader p return a script that mai later be execut will consum all the sourc in the reader param in the input reader param sourc name a string describ the sourc such as a filenam param lineno the start line number for report error param secur domain an arbitrari object that specifi secur inform about the origin or owner of the script for implement that don t care about secur thi valu mai be null return a script that mai later be execut except ioexcept if an ioexcept wa gener by the reader see org mozilla javascript script public final script compil reader reader in string sourc name int lineno object secur domain throw ioexcept if lineno 0 for compat illeg argument except can not be thrown here lineno 0 return script compil impl null in null sourc name lineno secur domain fals null null 
compil the sourc in the given string p return a script that mai later be execut param sourc the sourc string param sourc name a string describ the sourc such as a filenam param lineno the start line number for report error param secur domain an arbitrari object that specifi secur inform about the origin or owner of the script for implement that don t care about secur thi valu mai be null return a script that mai later be execut see org mozilla javascript script public final script compil string string sourc string sourc name int lineno object secur domain if lineno 0 for compat illeg argument except can not be thrown here lineno 0 return compil string sourc null null sourc name lineno secur domain 
final script compil string string sourc interpret compil error report compil error report string sourc name int lineno object secur domain try return script compil impl null null sourc sourc name lineno secur domain fals compil compil error report catch ioexcept ex should not happen when deal with sourc as string throw new runtim except 
compil a java script function p the function sourc must be a function definit as defin by ecma e g function f a return a param scope the scope to compil rel to param sourc the function definit sourc param sourc name a string describ the sourc such as a filenam param lineno the start line number param secur domain an arbitrari object that specifi secur inform about the origin or owner of the script for implement that don t care about secur thi valu mai be null return a function that mai later be call see org mozilla javascript function public final function compil function scriptabl scope string sourc string sourc name int lineno object secur domain return compil function scope sourc null null sourc name lineno secur domain 
final function compil function scriptabl scope string sourc interpret compil error report compil error report string sourc name int lineno object secur domain try return function compil impl scope null sourc sourc name lineno secur domain true compil compil error report catch ioexcept ioe should never happen becaus we just made the reader from a string throw new runtim except 
decompil the script p the canon sourc of the script is return param script the script to decompil param indent the number of space to indent the result return a string repres the script sourc public final string decompil script script script int indent nativ function script impl nativ function script return script impl decompil indent 0 
decompil a java script function p decompil a previous compil java script function object to canon sourc p return function bodi of nativ code if no decompil inform is avail param fun the java script function to decompil param indent the number of space to indent the result return a string repres the function sourc public final string decompil function function fun int indent if fun instanceof base function return base function fun decompil indent 0 els return function fun get class name n t nativ code n n 
decompil the bodi of a java script function p decompil the bodi a previous compil java script function object to canon sourc omit the function header and trail brace return nativ code if no decompil inform is avail param fun the java script function to decompil param indent the number of space to indent the result return a string repres the function bodi sourc public final string decompil function bodi function fun int indent if fun instanceof base function base function bf base function fun return bf decompil indent decompil onli bodi flag alert not sure what the right respons here is return nativ code n 
creat a new java script object equival to evalu new object param scope the scope to search for the constructor and to evalu against return the new object public final scriptabl new object scriptabl scope return new object scope object script runtim empti arg 
creat a new java script object by execut the name constructor the call code new object scope foo code is equival to evalu new foo param scope the scope to search for the constructor and to evalu against param constructor name the name of the constructor to call return the new object public final scriptabl new object scriptabl scope string constructor name return new object scope constructor name script runtim empti arg 
creat a new java script object by execut the name constructor search code scope code for the name constructor call it with the given argument and return the result p the code pre object arg a b new object scope foo arg pre is equival to evalu new foo a b assum that the foo constructor ha been defin in code scope code param scope the scope to search for the constructor and to evalu against param constructor name the name of the constructor to call param arg the arrai of argument for the constructor return the new object public final scriptabl new object scriptabl scope string constructor name object arg scope scriptabl object get top level scope scope function ctor script runtim get exist ctor thi scope constructor name if arg null arg script runtim empti arg return ctor construct thi scope arg 
creat an arrai with a specifi initi length p param scope the scope to creat the object in param length the initi length java script arrai mai have addit properti ad dynam return the new arrai object public final scriptabl new arrai scriptabl scope int length nativ arrai result new nativ arrai length script runtim set object proto and parent result scope return result 
creat an arrai with a set of initi element param scope the scope to creat the object in param element the initi element each object in thi arrai must be an accept java script type and type of arrai should be exactli object not some object subclass return the new arrai object public final scriptabl new arrai scriptabl scope object element if element get class get compon type script runtim object class throw new illeg argument except nativ arrai result new nativ arrai element script runtim set object proto and parent result scope return result 
get the element of a java script arrai p if the object defin a length properti convert to doubl number then the number is convert uint32 valu as defin in ecma 9 6 and java arrai of that size is alloc the arrai is initi with the valu obtain by call get on object for each valu of i in 0 length 1 if there is not a defin valu for a properti the undefin valu is us to initi the correspond element in the arrai the java arrai is then return if the object doesn t defin a length properti or it is not a number empti arrai is return param object the java script arrai or arrai like object return a java arrai of object sinc 1 4 releas 2 public final object get element scriptabl object return script runtim get arrai element object 
convert the valu to a java script boolean valu p see ecma 9 2 param valu a java script valu return the correspond boolean valu convert us the ecma rule public static boolean to boolean object valu return script runtim to boolean valu 
convert the valu to a java script number valu p return a java doubl for the java script number p see ecma 9 3 param valu a java script valu return the correspond doubl valu convert us the ecma rule public static doubl to number object valu return script runtim to number valu 
convert the valu to a java script string valu p see ecma 9 8 p param valu a java script valu return the correspond string valu convert us the ecma rule public static string to string object valu return script runtim to string valu 
convert the valu to an java script object valu p note that a scope must be provid to look up the constructor for number boolean and string p see ecma 9 9 p addition arbitrari java object and class will be wrap in a scriptabl object with it java field and method reflect as java script properti of the object param valu ani java object param scope global scope contain constructor for number boolean and string return new java script object public static scriptabl to object object valu scriptabl scope return script runtim to object scope valu 
deprec see to object object scriptabl public static scriptabl to object object valu scriptabl scope class static type return script runtim to object scope valu 
conveni method to convert java valu to it closest represent in java script p if valu is an instanc of string number boolean function or scriptabl it is return as it and will be treat as the correspond java script type of string number boolean function and object p note that for number instanc dure ani arithmet oper in java script the engin will alwai us the result of tt number doubl valu tt result in a precis loss if the number can not fit into doubl p if valu is an instanc of charact it will be convert to string of length 1 and it java script type will be string p the rest of valu will be wrap as live connect object by call link wrap factori wrap context cx scriptabl scope object obj class static type as in pre context cx context get current context return cx get wrap factori wrap cx scope valu null pre param valu ani java object param scope top scope object return valu suitabl to pass to ani api that take java script valu public static object java to js object valu scriptabl scope if valu instanceof string valu instanceof number valu instanceof boolean valu instanceof scriptabl return valu els if valu instanceof charact return string valu of charact valu char valu els context cx context get context return cx get wrap factori wrap cx scope valu null 
convert a java script valu into the desir type us the semant defin with live connect3 and throw an illeg argument except if the convers cannot be perform param valu the java script valu to convert param desir type the java type to convert to primit java type ar repres us the type field in the correspond wrapper class in java lang return the convert valu throw evalu except if the convers cannot be perform public static object js to java object valu class desir type throw evalu except return nativ java object coerc type impl desir type valu 
deprec see js to java object class throw illeg argument except if the convers cannot be perform note that link js to java object class throw link evalu except instead public static object to type object valu class desir type throw illeg argument except try return js to java valu desir type catch evalu except ex illeg argument except ex2 new illeg argument except ex get messag kit init caus ex2 ex throw ex2 
rethrow the except wrap it as the script runtim except unless the except is instanc of link ecma error or link evalu except it will be wrap as link wrap except a subclass of link evalu except the result except object alwai contain sourc name and line number of script that trigger except p thi method alwai throw an except it return valu is provid onli for conveni to allow a usag like pre throw context throw as script runtim ex ex pre to indic that code after the method is unreach throw evalu except throw ecma error public static runtim except throw as script runtim ex throwabl e while e instanceof invoc target except e invoc target except e get target except special handl of error so script would not catch them if e instanceof error throw error e if e instanceof rhino except throw rhino except e throw new wrap except e 
tell whether debug inform is be gener sinc 1 3 public final boolean is gener debug return gener debug 
specifi whether or not debug inform should be gener p set the gener of debug inform on will set the optim level to zero sinc 1 3 public final void set gener debug boolean gener debug if seal on seal mutat gener debug chang true if gener debug get optim level 0 set optim level 0 thi gener debug gener debug 
tell whether sourc inform is be gener sinc 1 3 public final boolean is gener sourc return gener sourc 
specifi whether or not sourc inform should be gener p without sourc inform evalu the to string method on java script function produc onli nativ code for the bodi of the function note that code gener without sourc is not fulli ecma conform sinc 1 3 public final void set gener sourc boolean gener sourc if seal on seal mutat thi gener sourc gener sourc 
get the current optim level p the optim level is express as an integ between 1 and 9 sinc 1 3 public final int get optim level return optim level 
set the current optim level p the optim level is expect to be an integ between 1 and 9 ani neg valu will be interpret as 1 and ani valu greater than 9 will be interpret as 9 an optim level of 1 indic that interpret mode will alwai be us level 0 through 9 indic that class file mai be gener higher optim level trade off compil time perform for runtim perform the optim level can t be set greater than 1 if the optim packag doesn t exist at run time param optim level an integ indic the level of optim to perform sinc 1 3 public final void set optim level int optim level if seal on seal mutat if optim level 2 to be compat with cocoon fork optim level 1 check optim level optim level if codegen class null optim level 1 thi optim level optim level 
public static boolean is valid optim level int optim level return 1 optim level optim level 9 
public static void check optim level int optim level if is valid optim level optim level return throw new illeg argument except optim level outsid 1 9 optim level 
return the maximum stack depth in term of number of call frame allow in a singl invoc of interpret if the set depth would be exceed the interpret will throw an evalu except in the script default to integ max valu the set onli ha effect for interpret function those compil with optim level set to 1 as the interpret doesn t us the java stack but rather manag it own stack in the heap memori a runawai recurs in interpret code would eventu consum all avail memori and caus out of memori error instead of a stack overflow error limit to onli a singl thread thi set help prevent such situat return the current maximum interpret stack depth public final int get maximum interpret stack depth return maximum interpret stack depth 
set the maximum stack depth in term of number of call frame allow in a singl invoc of interpret if the set depth would be exceed the interpret will throw an evalu except in the script default to integ max valu the set onli ha effect for interpret function those compil with optim level set to 1 as the interpret doesn t us the java stack but rather manag it own stack in the heap memori a runawai recurs in interpret code would eventu consum all avail memori and caus out of memori error instead of a stack overflow error limit to onli a singl thread thi set help prevent such situat param max the new maximum interpret stack depth throw illeg state except if thi context s optim level is not 1 throw illeg argument except if the new depth is not at least 1 public final void set maximum interpret stack depth int max if seal on seal mutat if optim level 1 throw new illeg state except cannot set maximum interpret stack depth when optim level 1 if max 1 throw new illeg argument except cannot set maximum interpret stack depth to less than 1 maximum interpret stack depth max 
set the secur control for thi context p secur control mai onli be set if it is current null and link secur control ha global is tt fals tt otherwis a secur except is thrown param control a secur control object throw secur except if there is alreadi a secur control object for thi context or global instal see secur control init global secur control control see secur control ha global public final void set secur control secur control control if seal on seal mutat if control null throw new illeg argument except if secur control null throw new secur except can not overwrit exist secur control object if secur control ha global throw new secur except can not overwrit exist global secur control object secur control control 
set the live connect access filter for thi context p link class shutter mai onli be set if it is current null otherwis a secur except is thrown param shutter a class shutter object throw secur except if there is alreadi a class shutter object for thi context public final void set class shutter class shutter shutter if seal on seal mutat if shutter null throw new illeg argument except if class shutter null throw new secur except cannot overwrit exist class shutter object class shutter shutter 
final class shutter get class shutter return class shutter 
get a valu correspond to a kei p sinc the context is associ with a thread it can be us to maintain valu that can be later retriev us the current thread p note that the valu ar maintain with the context so if the context is disassoci from the thread the valu cannot be retreiv also if privat data is to be maintain in thi manner the kei should be a java lang object whose refer is not divulg to untrust code param kei the kei us to lookup the valu return a valu previous store us put thread local public final object get thread local object kei if hashtabl null return null return hashtabl get kei 
put a valu that can later be retriev us a given kei p param kei the kei us to index the valu param valu the valu to save public final void put thread local object kei object valu if seal on seal mutat if hashtabl null hashtabl new hashtabl hashtabl put kei valu 
remov valu from thread local storag param kei the kei for the entri to remov sinc 1 5 releas 2 public final void remov thread local object kei if seal on seal mutat if hashtabl null return hashtabl remov kei 
deprec see featur dynam scope see ha featur int public final boolean ha compil function with dynam scope return compil function with dynam scope flag 
deprec see featur dynam scope see ha featur int public final void set compil function with dynam scope boolean flag if seal on seal mutat compil function with dynam scope flag flag 
deprec see class cach get scriptabl see class cach set cach enabl boolean public static void set cach enabl boolean cach enabl 
set a wrap factori for thi context p the wrap factori allow custom object wrap behavior for java object manipul with java script see wrap factori sinc 1 5 releas 4 public final void set wrap factori wrap factori wrap factori if seal on seal mutat if wrap factori null throw new illeg argument except thi wrap factori wrap factori 
return the current wrap factori or null if none is defin see wrap factori sinc 1 5 releas 4 public final wrap factori get wrap factori if wrap factori null wrap factori new wrap factori return wrap factori 
return the current debugg return the debugg or null if none is attach public final debugg get debugg return debugg 
return the debugg context data associ with current context return the debugg data or null if debugg is not attach public final object get debugg context data return debugg data 
set the associ debugg param debugg the debugg to be us on callback from the engin param context data arbitrari object that debugg can us to store per context data public final void set debugg debugg debugg object context data if seal on seal mutat thi debugg debugg debugg data context data 
return debugg script instanc if ani associ with the script if callabl support debugg script implement the method return it otherwis null is return public static debugg script get debugg view script script if script instanceof nativ function return nativ function script get debugg view return null 
control certain aspect of script semant should be overwritten to alter default behavior p the default implement call link context factori ha featur context cx int featur index that allow to custom context behavior without introduc context subclass link context factori document give an exampl of ha featur implement param featur index featur index to check return true if the code featur index code featur is turn on see featur non ecma get year see featur member expr as function name see featur reserv keyword as identifi see featur to string as sourc see featur parent proto proprti see featur e4x see featur dynam scope see featur strict var see featur strict eval public boolean ha featur int featur index context factori f get factori return f ha featur thi featur index 
get set threshold of execut instruct counter that trigger call to code observ instruct count code when the threshold is zero instruct count is disabl otherwis each time the run time execut at least the threshold valu of script instruct code observ instruct count code will be call public final int get instruct observ threshold return instruct threshold 
public final void set instruct observ threshold int threshold if seal on seal mutat if threshold 0 throw new illeg argument except instruct threshold threshold 
allow applic to monitor counter of execut script instruct in context subclass run time call thi when instruct count is enabl and the counter reach limit set by code set instruct observ threshold code the method is us to observ long run script and if necessari to termin them p the instruct count support is avail onli for interpret script gener when the optim level is set to 1 p the default implement call link context factori observ instruct count context cx int instruct count that allow to custom context behavior without introduc context subclass param instruct count amount of script instruct execut sinc last call to code observ instruct count code throw error to termin the script see set optim level int protect void observ instruct count int instruct count context factori f get factori f observ instruct count thi instruct count 
creat class loader for gener class the method call link context factori creat class loader class loader us the result of link get factori public gener class loader creat class loader class loader parent context factori f get factori return f creat class loader parent 
public final class loader get applic class loader if applic class loader null context factori f get factori class loader loader f get applic class loader if loader null class loader thread loader vmbridg instanc get current thread class loader if thread loader null kit test if can load rhino class thread loader thread get context class loader is not cach sinc it cach prevent it from gc which mai lead to a memori leak and hide updat to thread get context class loader return thread loader thread get context class loader can not load rhino class try to us the loader of context factori or context subclass class f class f get class if f class script runtim context factori class loader f class get class loader els loader get class get class loader applic class loader loader return applic class loader 
public final void set applic class loader class loader loader if seal on seal mutat if loader null restor default behaviour applic class loader null return if kit test if can load rhino class loader throw new illeg argument except loader can not resolv rhino class applic class loader loader 
intern method that report an error for miss call to enter static context get context context cx get current context if cx null throw new runtim except no context associ with current thread return cx 
privat object compil impl scriptabl scope reader sourc reader string sourc string string sourc name int lineno object secur domain boolean return function interpret compil error report compil error report throw ioexcept if secur domain null secur control null throw new illeg argument except secur domain should be null if set secur control wa never call on of sourc reader or sourc string ha to be null if sourc reader null sourc string null kit code bug scope should be given if and onli if compil function if scope null return function kit code bug compil environ compil env new compil environ compil env init from context thi if compil error report null compil error report compil env get error report if debugg null if sourc reader null sourc string kit read reader sourc reader sourc reader null parser p new parser compil env compil error report if return function p call by compil function true script or fn node tree if sourc string null tree p pars sourc string sourc name lineno els tree p pars sourc reader sourc name lineno if return function if tree get function count 1 tree get first child null tree get first child get type token function xxx the check just look for the first child and allow for more node after it for compat with sourc like function throw new illeg argument except compil function onli accept sourc with singl js function sourc string if compil null compil creat compil string encod sourc p get encod sourc object bytecod compil compil compil env tree encod sourc return function if debugg null if sourc string null kit code bug if bytecod instanceof debugg script debugg script dscript debugg script bytecod notifi debugg r thi dscript sourc string els throw new runtim except not support object result if return function result compil creat function object thi scope bytecod secur domain els result compil creat script object bytecod secur domain return result 
privat static void notifi debugg r context cx debugg script dscript string debug sourc cx debugg handl compil done cx dscript debug sourc for int i 0 i dscript get function count i notifi debugg r cx dscript get function i debug sourc 
privat interpret creat compil interpret result null if optim level 0 codegen class null result interpret kit new instanc or null codegen class if result null result new interpret return result 
static string get sourc posit from stack int linep context cx get current context if cx null return null if cx last interpret frame null return interpret get sourc posit from stack cx linep a bit of a hack but the onli wai to get filenam and line number from an enclos frame char arrai writer writer new char arrai writer runtim except re new runtim except re print stack trace new print writer writer string s writer to string int open 1 int close 1 int colon 1 for int i 0 i s length i char c s char at i if c colon i els if c open i els if c close i els if c n open 1 close 1 colon 1 open colon colon close string file str s substr open 1 colon if file str end with java string line str s substr colon 1 close try linep 0 integ pars int line str if linep 0 0 linep 0 0 return file str catch number format except e fall through open close colon 1 return null 
reg exp proxi get reg exp proxi if reg exp proxi null class cl kit class or null org mozilla javascript regexp reg exp impl if cl null reg exp proxi reg exp proxi kit new instanc or null cl return reg exp proxi 
final boolean is version ecma1 return version version default version version 1 3 
the method must not be public or protect secur control get secur control secur control global secur control global if global null return global return secur control 
public final boolean is gener debug chang return gener debug chang 
add a name to the list of name forc the creation of real activ object for function param name the name of the object to add to the list public void add activ name string name if seal on seal mutat if activ name null activ name new hashtabl 5 activ name put name name 
check whether the name is in the list of name of object forc the creation of activ object param name the name of the object to test return true if an function activ object is need public final boolean is activ need string name return activ name null activ name contain kei name 
remov a name from the list of name forc the creation of real activ object for function param name the name of the object to remov from the list public void remov activ name string name if seal on seal mutat if activ name null activ name remov name 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public int ambigu char arg return char 
public int ambigu short arg return short 
public int ambigu int arg return int 
public int ambigu long arg return long 
privat string sourc file public code printer get code printer return p 
public code printer get code printer return p public void set code printer code printer valu p valu 
public void set code printer code printer valu p valu public tool error report get report return r 
public tool error report get report return r public void set report tool error report valu r valu 
public void set report tool error report valu r valu public string get sourc file name return sourc file 
public string get sourc file name return sourc file public void set sourc file name string valu sourc file valu 
public void gener switch string pair string default valu int n pair length 2 id valu pair id pair new id valu pair n for int i 0 i n i id pair i new id valu pair pair 2 i pair 2 i 1 gener switch id pair default valu 
public void gener switch id valu pair pair string default valu int begin 0 int end pair length if begin end return thi pair pair thi default valu default valu gener bodi begin end 2 
privat void gener bodi int begin int end int indent level p indent indent level p p v switch label p p p p v id p p p p default valu p p string p p v guess p p null c wa defin fals int c def begin p get offset p p int p p v c p p int c def end p get offset p nl gener length switch begin end indent level 1 if c wa defin p eras c def begin c def end p indent indent level 1 p p if p p v guess p p null p p v guess p p p p v s p p p p v guess p p equal p p v s p p p p v id p p p p default valu p p p nl p line indent level 
privat void gener length switch int begin int end int indent level sort pair begin end 1 check all is differ begin end int length count count differ length begin end column new int pair end 1 id length boolean us if if length count us if threshold us if true if length count 1 p indent indent level p p int p p v s p p v length suffix p p p p v s p p length p nl els us if fals p indent indent level p p v label p p switch p p v s p p length p nl int same length begin begin int cur l pair begin id length l 0 for int i begin i if i end l pair i id length cur l int next indent if us if p indent indent level if same length begin begin p p els p p if if length count 1 p p v s p p length els p p v s p p v length suffix p p p p cur l p p next indent indent level 1 els p indent indent level p p case p p cur l p p next indent indent level 1 gener letter switch same length begin i next indent us if us if if us if p p p nl els p p break p p v label p p p nl if i end break same length begin i cur l l if us if p indent indent level p p p nl 
privat void gener letter switch int begin int end int indent level boolean label wa defin boolean insid if int l pair begin id length for int i 0 i l i column i i gener letter switch r begin end l indent level label wa defin insid if 
privat boolean gener letter switch r int begin int end int l int indent level boolean label wa defin boolean insid if boolean next is unreach fals if begin 1 end p p id valu pair pair pair begin if l char tail test threshold p p v guess p p p qstring pair id p p p p v id p p p p pair valu p p els if l 0 next is unreach true p p v id p p p p pair valu p p break p p v switch label p p els p p if int column column 0 p p v s p p char at p p column p p p qchar pair id char at column for int i 1 i l i p p column column i p p v s p p char at p p column p p p qchar pair id char at column p p p p v id p p p p pair valu p p break p p v switch label p p p p return next is unreach int max column index find max differ column begin end l int max column column max column index int count count differ char begin end max column column max column index column l 1 if insid if p nl p indent indent level els p p boolean us if if count us if threshold us if true c wa defin true p p v c p p p p v s p p char at p p max column p p els us if fals if label wa defin label wa defin true p p v label p p p p switch p p v s p p char at p p max column p p int same char begin begin int cur ch pair begin id char at max column ch 0 for int i begin i if i end ch pair i id char at max column cur ch int next indent if us if p nl p indent indent level if same char begin begin p p els p p if p p v c p p p qchar cur ch p p next indent indent level 1 els p nl p indent indent level p p case p qchar cur ch p p next indent indent level 1 boolean after unreach gener letter switch r same char begin i l 1 next indent label wa defin us if if us if p p els if after unreach p p break p p v label p p if i end break same char begin i cur ch ch if us if p nl if insid if p indent indent level 1 els p indent indent level els p nl p indent indent level p p if insid if p nl p indent indent level 1 els p p column max column index max column return next is unreach 
privat int count differ length int begin int end int length count 0 int cur l 1 for begin end begin int l pair begin id length if cur l l length count cur l l return length count 
privat int find max differ column int begin int end int l int max count 0 int max index 0 for int i 0 i l i int column column i sort pair begin end column int count count differ char begin end column if count end begin return i if max count count max count count max index i if max index l 1 sort pair begin end column max index return max index 
privat int count differ char int begin int end int column int char count 0 int cur ch 1 for begin end begin int ch pair begin id char at column if ch cur ch char count cur ch ch return char count 
privat void check all is differ int begin int end if begin end id valu pair prev pair begin while begin end id valu pair current pair begin if prev id equal current id throw on same pair fail prev current prev current 
privat evalu except on same pair fail id valu pair a id valu pair b string buffer sb new string buffer int line1 a get line number line2 b get line number if line2 line1 int tmp line1 line1 line2 line2 tmp string error text tool error report get messag msg idswitch same string a id new integ line2 return r runtim error error text sourc file line1 null 0 
privat void sort pair int begin int end int compar heap4sort pair begin end begin compar 
privat static boolean bigger id valu pair a id valu pair b int compar if compar 0 for length select switch it is enough to compar just length but to detect same string full comparison is essenti return a id length b id length int diff a id length b id length if diff 0 return diff 0 return a id compar to b id 0 els return a id char at compar b id char at compar 
privat static void heap4sort id valu pair arrai int offset int size int compar if size 1 return make heap4 arrai offset size compar while size 1 size id valu pair v1 arrai offset size id valu pair v2 arrai offset 0 arrai offset size v2 arrai offset 0 v1 heapify4 arrai offset size 0 compar 
privat static void make heap4 id valu pair arrai int offset int size int compar for int i size 2 2 i 0 i heapify4 arrai offset size i compar 
privat static void heapify4 id valu pair arrai int offset int size int i int compar int new i1 new i2 new i3 id valu pair i val arrai offset i for int base i 2 new i1 base 1 new i2 base 2 new i3 base 3 int new i4 base 4 if new i4 size break id valu pair val1 arrai offset new i1 id valu pair val2 arrai offset new i2 id valu pair val3 arrai offset new i3 id valu pair val4 arrai offset new i4 if bigger val2 val1 compar val1 val2 new i1 new i2 if bigger val4 val3 compar val3 val4 new i3 new i4 if bigger val3 val1 compar val1 val3 new i1 new i3 if bigger i val val1 compar return arrai offset i val1 arrai offset new i1 i val i new i1 if new i1 size id valu pair val1 arrai offset new i1 if new i2 size id valu pair val2 arrai offset new i2 if bigger val2 val1 compar val1 val2 new i1 new i2 if new i3 size id valu pair val3 arrai offset new i3 if bigger val3 val1 compar val1 val3 new i1 new i3 if bigger val1 i val compar arrai offset i val1 arrai offset new i1 i val 
public class data type 007 extend live connect test public data type 007 super 
public static void main string arg data type 007 test new data type 007 test start 
public void execut test do static method test dt static get boolean object java lang boolean object new boolean data type class pub static final boolean do static method test dt static get boolean java lang boolean object new boolean data type class pub static final boolean do static method test dt static get byte java lang doubl object new doubl data type class pub static final byte do static method test dt static get byte object java lang byte object new byte data type class pub static final byte do static method test dt static get char java lang doubl object new doubl data type class pub static final char do static method test dt static get charact java lang charact object new charact data type class pub static final char do static method test dt static get short java lang doubl object new doubl data type class pub static final short do static method test dt static get short object java lang short object new short data type class pub static final short do static method test dt static get integ java lang doubl object new doubl data type class pub static final int do static method test dt static get integ object java lang integ object new integ data type class pub static final int do static method test dt static get integ java lang doubl object new doubl data type class pub static final int do static method test dt static get long java lang doubl object new doubl data type class pub static final long do static method test dt static get long object java lang long object new long data type class pub static final long do static method test dt static get float java lang doubl object new doubl data type class pub static final float do static method test dt static get float object java lang float object new float data type class pub static final float do static method test dt static get doubl java lang doubl object new doubl data type class pub static final doubl do static method test dt static get doubl object java lang doubl object new doubl data type class pub static final doubl do static method test dt static get char java lang doubl object new doubl data type class pub static final char do static method test dt static get string object java lang string object new string data type class pub static final string 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class 
public void do static method test string method string class name object valu get public static method method class name valu get java script valu method class name valu 
set the valu of a java script variabl to a java valu get the valu of that variabl public void get public static method string method string class name object valu string descript method string except null object actual null string expect null check the class try actual global eval method expect class for name class name get name catch class not found except e catch except e except e to string might want to do all the interest stuff here in a try catch block add test case descript get class expect actual get class get name except add test case descript valu to string true actual equal valu except add test case actual to string equal valu to string true actual to string equal valu to string except 
try to set the valu of a public static field us jsobject set member which should succe public void set public static field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try befor global eval descript need to quot string if class name equal java lang string global eval descript new valu to string els global eval descript new valu after global eval descript expect class for name class name get name catch except e except e to string add test case global eval descript new valu to string after global eval descript after get class get name expect after get class get name except add test case after to string equal new valu to string true after equal new valu except add test case after to string equal new valu to string true after to string equal new valu to string except 
assign a valu to a public static final java field the assign should fail the valu should not chang but there should be no error messag public void set public static final field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try expect class for name class name get name catch except e except e to string befor global eval descript global eval descript new valu to string after global eval descript check the class of the result which should be the same as expect add test case descript get class expect after get class get name except the valu of the actual result should be the origin valu add test case descript valu to string true after equal valu except the string represent of the actual result should be the same as the string represent of the expect valu add test case after to string equal valu to string true after to string equal valu to string except get member field should return the same valu befor and after the assign add test case befor equal after true befor equal after except 
public void get java script valu string field string class name object valu string descript field string except null object actual null string expect null try global eval var myobject descript actual global get member myobject expect class for name class name get name catch except e except e to string add test case global eval var myobject descript actual global get member myobject actual get class get name expect actual get class get name except add test case actual valu to string true actual equal valu except add test case actual to string equal valu to string true actual to string equal valu to string except 
public class slot 001 extend live connect test public slot 001 super 
super public static void main string arg slot 001 test new slot 001 test start 
public void execut test for int i 0 i test matrix length i string arg string object test matrix i 0 jsobject js arrai creat jsarrai arg get the length of the arrai us jsobject get member int java length object test matrix i length 1 get length js arrai java length for int j 0 j java length j get slot js arrai j object test matrix i j 1 
creat a java script arrai name js arrai param new arrai argument string contain a list of argument for the java script arrai constructor return the jsobject arrai object public jsobject creat jsarrai string new arrai argument jsobject js arrai null string arg var js arrai new arrai new arrai argument string result pass try system out println arg global eval arg js arrai jsobject global get member js arrai catch except e result fail except global get member js arrai threw e to string file except except e print stack trace final add test case global eval var js arrai new arrai new arrai argument jsobject js arrai jsobject global get member js arrai pass result except return js arrai 
us jsobject get member to get the length properti of a jsobject param js arrai a jsobject with a properti name length param java length the expect length of the jsobject public void get length jsobject js arrai int java length string except int js length 0 try js length doubl js arrai get member length int valu catch except e except js arrai get member length threw e to string file except except e print stack trace final add test case length is js length js arrai get member length int valu java length true js length java length except 
us jsobject get slot to get an index member of a jsobject param js arrai the jsobject with index member param slot the index properti to retriev param java valu a java object whose type and valu ar what we expect js arrai get slot slot to return public void get slot jsobject js arrai int slot object java valu string except object result null class e class null class a class null try result js arrai get slot slot if java valu null e class java valu get class a class result get class catch except e except js arrai get slot slot threw e to string file except except e print stack trace final if java valu null add test case js arrai get slot slot return result java valu result true java valu result except els add test case js arrai get slot slot return result java valu equal result true java valu equal result except add test case e class equal a class true e class equal a class except 
jsobject set slot return undefin thi just verifi that we can call set slot without throw an except param js arrai the jsobject on which set slot will be call param slot the index member that will be set param java valu the valu to set the index member public void set slot jsobject js arrai int slot object java valu string except null string result pass try js arrai set slot slot java valu catch except e result fail except js arrai set slot slot java valu threw e to string file except except e print stack trace final add test case js arrai set slot slot java valu pass result except 
public static boolean node equal xml cursor xml on xml cursor xml two boolean result fals if xml on is startdoc xml on to first content token if xml two is startdoc xml two to first content token if xml on current token type xml two current token type if xml on is enddoc both empti result true els if xml on is attr result attribut equal xml on xml two els if xml on is text result text node equal xml on xml two els if xml on is comment result comment equal xml on xml two els if xml on is procinst result process instruct equal xml on xml two els if xml on is start compar root element result element equal xml on xml two return result 
privat static boolean element equal xml cursor xml on xml cursor xml two boolean result true if qname equal xml on get name xml two get name result fals els these filter out empti text node next token xml on next token xml two do if xml on current token type xml two current token type not same token result fals break els if xml on is end done with thi element step over end break els if xml on is enddoc shouldn t get here break els if xml on is attr thi on will move us to the first non attr token result attribut list equal xml on xml two els if xml on is text result text node equal xml on xml two els if xml on is comment result comment equal xml on xml two els if xml on is procinst result process instruct equal xml on xml two els if xml on is start result element equal xml on xml two els xml log unknown token type xml on current token type these filter out empti text node next token xml on next token xml two while result return result 
param xml on param xml two return privat static boolean attribut list equal xml cursor xml on xml cursor xml two boolean result true tree map map on load attribut map xml on tree map map two load attribut map xml two if map on size map two size result fals els set kei on map on kei set set kei two map two kei set iter it on kei on iter iter it two kei two iter while result it on ha next string valu on string it on next string valu two string it two next if valu on equal valu two result fals els javax xml namespac qname qname on javax xml namespac qname map on get valu on javax xml namespac qname qname two javax xml namespac qname map two get valu two if qname equal qname on qname two result fals return result 
param xml return privat static tree map load attribut map xml cursor xml tree map result new tree map while xml is attr result put xml get text valu xml get name next token xml return result 
param xml on param xml two return privat static boolean attribut equal xml cursor xml on xml cursor xml two boolean result fals if xml on is attr xml two is attr if qname equal xml on get name xml two get name if xml on get text valu equal xml two get text valu result true return result 
param xml on param xml two return privat static boolean text node equal xml cursor xml on xml cursor xml two boolean result fals if xml on is text xml two is text if xml on get char equal xml two get char result true return result 
param xml on param xml two return privat static boolean comment equal xml cursor xml on xml cursor xml two boolean result fals if xml on is comment xml two is comment if xml on get text valu equal xml two get text valu result true return result 
param xml on param xml two return privat static boolean process instruct equal xml cursor xml on xml cursor xml two boolean result fals if xml on is procinst xml two is procinst if qname equal xml on get name xml two get name if xml on get text valu equal xml two get text valu result true return result 
param qname on param qname two return privat static boolean qname equal javax xml namespac qname qname on javax xml namespac qname qname two boolean result fals if qname on get namespac uri equal qname two get namespac uri if qname on get local part equal qname two get local part return true return result 
filter out empti text node here param xml privat static void next token xml cursor xml do xml to next token if xml is text not a text node break els if xml get char trim length 0 text node is not empti break while true 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public int ambigu char arg return char 
public int ambigu short arg return short 
public int ambigu int arg return int 
public int ambigu long arg return long 
public int ambigu string arg return string 
public int ambigu object arg return object 
return object public int expect return object 
protect xmlobject impl xmllib impl lib xmlobject prototyp super lib global scope prototyp thi lib lib 
ecma ha cx id call thi after resolv when id to xmlname and check it is not uint32 index 
ecma get cx id call thi after resolv when id to xmlname and check it is not uint32 index 
ecma put cx id valu call thi after resolv when id to xmlname and check it is not uint32 index 
ecma delet cx id call thi after resolv when id to xmlname and check it is not uint32 index 
abstract void delet xmlproperti xmlname name test xml equal with target the target abstract boolean equival xml object target 
method from section 12 4 4 in the spec abstract xml add namespac namespac ns 
method from section 12 4 4 in the spec abstract xml add namespac namespac ns abstract xml append child object xml 
abstract xml add namespac namespac ns abstract xml append child object xml abstract xmllist attribut xmlname xml name 
abstract xml append child object xml abstract xmllist attribut xmlname xml name abstract xmllist attribut 
abstract xmllist attribut xmlname xml name abstract xmllist attribut abstract xmllist child long index 
abstract xmllist attribut abstract xmllist child long index abstract xmllist child xmlname xml name 
abstract xmllist child long index abstract xmllist child xmlname xml name abstract int child index 
abstract xmllist child xmlname xml name abstract int child index abstract xmllist children 
abstract int child index abstract xmllist children abstract xmllist comment 
abstract xmllist children abstract xmllist comment abstract boolean contain object xml 
abstract xmllist comment abstract boolean contain object xml abstract object copi 
abstract boolean contain object xml abstract object copi abstract xmllist descend xmlname xml name 
abstract object copi abstract xmllist descend xmlname xml name abstract object in scope namespac 
abstract xmllist descend xmlname xml name abstract object in scope namespac abstract xml insert child after object child object xml 
abstract object in scope namespac abstract xml insert child after object child object xml abstract xml insert child befor object child object xml 
abstract xml insert child after object child object xml abstract xml insert child befor object child object xml abstract boolean ha own properti xmlname xml name 
abstract xml insert child befor object child object xml abstract boolean ha own properti xmlname xml name abstract boolean ha complex content 
abstract boolean ha own properti xmlname xml name abstract boolean ha complex content abstract boolean ha simpl content 
abstract boolean ha complex content abstract boolean ha simpl content abstract int length 
abstract boolean ha simpl content abstract int length abstract string local name 
abstract int length abstract string local name abstract qname name 
abstract string local name abstract qname name abstract object namespac string prefix 
abstract qname name abstract object namespac string prefix abstract object namespac declar 
abstract object namespac string prefix abstract object namespac declar abstract object node kind 
abstract object namespac declar abstract object node kind abstract void normal 
abstract object node kind abstract void normal abstract object parent 
abstract void normal abstract object parent abstract xml prepend child object xml 
abstract object parent abstract xml prepend child object xml abstract object process instruct xmlname xml name 
abstract xml prepend child object xml abstract object process instruct xmlname xml name abstract boolean properti is enumer object member 
abstract object process instruct xmlname xml name abstract boolean properti is enumer object member abstract xml remov namespac namespac ns 
abstract boolean properti is enumer object member abstract xml remov namespac namespac ns abstract xml replac long index object xml 
abstract xml remov namespac namespac ns abstract xml replac long index object xml abstract xml replac xmlname name object xml 
abstract xml replac long index object xml abstract xml replac xmlname name object xml abstract xml set children object xml 
abstract xml replac xmlname name object xml abstract xml set children object xml abstract void set local name string name 
abstract xml set children object xml abstract void set local name string name abstract void set name qname xml name 
abstract void set local name string name abstract void set name qname xml name abstract void set namespac namespac ns 
abstract void set name qname xml name abstract void set namespac namespac ns abstract xmllist text 
abstract void set namespac namespac ns abstract xmllist text public abstract string to string 
abstract xmllist text public abstract string to string abstract string to sourc int indent 
public abstract string to string abstract string to sourc int indent abstract string to xmlstring int indent 
abstract string to sourc int indent abstract string to xmlstring int indent abstract object valu of 
abstract object valu of extens to access nativ implement from script abstract org apach xmlbean xml object get xml object 
abstract org apach xmlbean xml object get xml object protect abstract object js constructor context cx boolean in new expr object arg 
final object get method string id return super get id thi 
public final object get default valu class hint return to string 
public void delet string name throw new illeg argument except string name 
xmlobject alwai compar with ani valu and equival valu never return link scriptabl not found for them but rather call equival xml valu and wrap the result as boolean protect final object equival valu object valu boolean result equival xml valu return result boolean true boolean fals 
public final xmllib lib return lib 
implement of ecmascript ha public final boolean ecma ha context cx object id if cx null cx context get current context xmlname xml name lib to xmlname or index cx id if xml name null long index script runtim last uint32result cx xxx fix thi cast return ha int index thi return ha xmlproperti xml name 
implement of ecmascript get public final object ecma get context cx object id if cx null cx context get current context xmlname xml name lib to xmlname or index cx id if xml name null long index script runtim last uint32result cx xxx fix thi cast object result get int index thi if result scriptabl not found result undefin instanc return result return get xmlproperti xml name 
implement of ecmascript put public final void ecma put context cx object id object valu if cx null cx context get current context xmlname xml name lib to xmlname or index cx id if xml name null long index script runtim last uint32result cx xxx fix thi cast put int index thi valu return put xmlproperti xml name valu 
implement of ecmascript delet public final boolean ecma delet context cx object id if cx null cx context get current context xmlname xml name lib to xmlname or index cx id if xml name null long index script runtim last uint32result cx xxx fix thi delet int index return true delet xmlproperti xml name return true 
public ref member ref context cx object elem int member type flag xmlname xml name if member type flag node attribut flag 0 xml name lib to attribut name cx elem els if member type flag node descend flag 0 code gener would us ecma get ha delet set for normal name idenrifi so on attribut flag or descend flag ha to be set throw kit code bug xml name lib to xmlname cx elem if member type flag node descend flag 0 xml name set is descend xml name init xmlobject thi return xml name 
gener refer to implement x ns x ns y x ns y etc public ref member ref context cx object namespac object elem int member type flag xmlname xml name lib to qualifi name cx namespac elem if member type flag node attribut flag 0 if xml name is attribut name xml name set attribut name if member type flag node descend flag 0 xml name set is descend xml name init xmlobject thi return xml name 
public nativ with enter with scriptabl scope return new xmlwith scope lib scope thi 
public nativ with enter dot queri scriptabl scope xmlwith scope xw new xmlwith scope lib scope thi xw init as dot queri return xw 
public final object add valu context cx boolean thi is left object valu if valu instanceof xmlobject xmlobject v1 v2 if thi is left v1 thi v2 xmlobject valu els v1 xmlobject valu v2 thi return lib add xmlobject cx v1 v2 if valu undefin instanc both xml undefin and undefin xml give string xml return script runtim to string thi return super add valu cx thi is left valu 
final void export as jsclass boolean seal prototyp flag true export as jsclass max prototyp id lib global scope seal 
protect int find prototyp id string s int id gener last updat 2004 11 10 15 38 11 cet l0 id 0 string x null int c l switch s length case 4 c s char at 0 if c c x copi id id copi els if c n x name id id name els if c t x text id id text break l case 5 x child id id child break l case 6 c s char at 0 if c l x length id id length els if c p x parent id id parent break l case 7 c s char at 0 if c r x replac id id replac els if c s x set name id id set name els if c v x valu of id id valu of break l case 8 switch s char at 4 case k x node kind id id node kind break l case a x contain id id contain break l case d x children id id children break l case e x comment id id comment break l case r x to string id id to string break l case u x to sourc id id to sourc break l break l case 9 switch s char at 2 case c x local name id id local name break l case m x namespac id id namespac break l case r x normal id id normal break l case t x attribut id id attribut break l break l case 10 c s char at 0 if c a x attribut id id attribut els if c c x child index id id child index break l case 11 switch s char at 0 case a x append child id id append child break l case c x constructor id id constructor break l case d x descend id id descend break l case s x set children id id set children break l case t x to xmlstring id id to xmlstring break l break l case 12 switch s char at 0 case a x add namespac id id add namespac break l case g x get xml object id id get xml object break l case p x prepend child id id prepend child break l case s c s char at 3 if c l x set local name id id set local name els if c n x set namespac id id set namespac break l break l case 14 x ha own properti id id ha own properti break l case 15 x remov namespac id id remov namespac break l case 16 c s char at 0 if c h x ha simpl content id id ha simpl content els if c i x insert child after id id insert child after break l case 17 c s char at 3 if c c x ha complex content id id ha complex content els if c c x in scope namespac id id in scope namespac els if c e x insert child befor id id insert child befor break l case 20 x properti is enumer id id properti is enumer break l case 21 x namespac declar id id namespac declar break l case 22 x process instruct id id process instruct break l if x null x s x equal s id 0 gener return id 
protect void init prototyp id int id string s int ariti switch id case id constructor id function object ctor if thi instanceof xml ctor new xmlctor xml thi xmlobject tag id 1 els ctor new id function object thi xmlobject tag id 1 init prototyp constructor ctor return case id add namespac ariti 1 s add namespac break case id append child ariti 1 s append child break case id attribut ariti 1 s attribut break case id attribut ariti 0 s attribut break case id child ariti 1 s child break case id child index ariti 0 s child index break case id children ariti 0 s children break case id comment ariti 0 s comment break case id contain ariti 1 s contain break case id copi ariti 0 s copi break case id descend ariti 1 s descend break case id ha complex content ariti 0 s ha complex content break case id ha own properti ariti 1 s ha own properti break case id ha simpl content ariti 0 s ha simpl content break case id in scope namespac ariti 0 s in scope namespac break case id insert child after ariti 2 s insert child after break case id insert child befor ariti 2 s insert child befor break case id length ariti 0 s length break case id local name ariti 0 s local name break case id name ariti 0 s name break case id namespac ariti 1 s namespac break case id namespac declar ariti 0 s namespac declar break case id node kind ariti 0 s node kind break case id normal ariti 0 s normal break case id parent ariti 0 s parent break case id prepend child ariti 1 s prepend child break case id process instruct ariti 1 s process instruct break case id properti is enumer ariti 1 s properti is enumer break case id remov namespac ariti 1 s remov namespac break case id replac ariti 2 s replac break case id set children ariti 1 s set children break case id set local name ariti 1 s set local name break case id set name ariti 1 s set name break case id set namespac ariti 1 s set namespac break case id text ariti 0 s text break case id to string ariti 0 s to string break case id to sourc ariti 1 s to sourc break case id to xmlstring ariti 1 s to xmlstring break case id valu of ariti 0 s valu of break case id get xml object ariti 0 s get xml object break default throw new illeg argument except string valu of id init prototyp method xmlobject tag id s ariti 
param f param cx param scope param thi obj param arg return public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag xmlobject tag return super exec id call f cx scope thi obj arg int id f method id if id id constructor return js constructor cx thi obj null arg all xml xmllist prototyp method requir thi obj to be xml if thi obj instanceof xmlobject impl throw incompat call error f xmlobject impl real thi xmlobject impl thi obj switch id case id add namespac namespac ns lib cast to namespac cx arg arg 0 return real thi add namespac ns case id append child return real thi append child arg arg 0 case id attribut xmlname xml name lib to attribut name cx arg arg 0 return real thi attribut xml name case id attribut return real thi attribut case id child xmlname xml name lib to xmlname or index cx arg arg 0 if xml name null long index script runtim last uint32result cx return real thi child index els return real thi child xml name case id child index return script runtim wrap int real thi child index case id children return real thi children case id comment return real thi comment case id contain return script runtim wrap boolean real thi contain arg arg 0 case id copi return real thi copi case id descend xmlname xml name arg length 0 xmlname form star lib to xmlname cx arg 0 return real thi descend xml name case id in scope namespac object arrai real thi in scope namespac return cx new arrai scope arrai case id insert child after return real thi insert child after arg arg 0 arg arg 1 case id insert child befor return real thi insert child befor arg arg 0 arg arg 1 case id ha own properti xmlname xml name lib to xmlname cx arg arg 0 return script runtim wrap boolean real thi ha own properti xml name case id ha complex content return script runtim wrap boolean real thi ha complex content case id ha simpl content return script runtim wrap boolean real thi ha simpl content case id length return script runtim wrap int real thi length case id local name return real thi local name case id name return real thi name case id namespac string prefix arg length 0 script runtim to string arg 0 null return real thi namespac prefix case id namespac declar object arrai real thi namespac declar return cx new arrai scope arrai case id node kind return real thi node kind case id normal real thi normal return undefin instanc case id parent return real thi parent case id prepend child return real thi prepend child arg arg 0 case id process instruct xmlname xml name arg length 0 lib to xmlname cx arg 0 xmlname form star return real thi process instruct xml name case id properti is enumer return script runtim wrap boolean real thi properti is enumer arg arg 0 case id remov namespac namespac ns lib cast to namespac cx arg arg 0 return real thi remov namespac ns case id replac xmlname xml name lib to xmlname or index cx arg arg 0 object arg1 arg arg 1 if xml name null long index script runtim last uint32result cx return real thi replac index arg1 els return real thi replac xml name arg1 case id set children return real thi set children arg arg 0 case id set local name string local name object arg arg arg 0 if arg instanceof qname local name qname arg local name els local name script runtim to string arg real thi set local name local name return undefin instanc case id set name object arg arg length 0 arg 0 undefin instanc qname qname if arg instanceof qname qname qname arg if qname uri null qname lib construct qname from string cx qname local name els e4x 13 4 4 35 requir to alwai construct qname qname lib construct qname cx qname els qname lib construct qname cx arg real thi set name qname return undefin instanc case id set namespac namespac ns lib cast to namespac cx arg arg 0 real thi set namespac ns return undefin instanc case id text return real thi text case id to string return real thi to string case id to sourc int indent script runtim to int32 arg 0 return real thi to sourc indent case id to xmlstring int indent script runtim to int32 arg 0 return real thi to xmlstring indent case id valu of return real thi valu of case id get xml object org apach xmlbean xml object xml object real thi get xml object return context java to js xml object scope throw new illeg argument except string valu of id 
privat static object arg object arg int i return i arg length arg i undefin instanc 
public class reg exp impl implement reg exp proxi public boolean is reg exp scriptabl obj return obj instanceof nativ reg exp 
public object compil reg exp context cx string sourc string flag return nativ reg exp compil re sourc flag fals 
public scriptabl wrap reg exp context cx scriptabl scope object compil return new nativ reg exp scope compil 
public object action context cx scriptabl scope scriptabl thi obj object arg int action type glob data data new glob data data mode action type switch action type case ra match object rval data optarg 1 rval match or replac cx scope thi obj arg thi data fals return data arrayobj null rval data arrayobj case ra search data optarg 1 return match or replac cx scope thi obj arg thi data fals case ra replac object arg1 arg length 2 undefin instanc arg 1 string repstr null function lambda null if arg1 instanceof function lambda function arg1 els repstr script runtim to string arg1 data optarg 2 data lambda lambda data repstr repstr data dollar repstr null 1 repstr index of data char buf null data left index 0 object val match or replac cx scope thi obj arg thi data true sub string rc thi right context if data char buf null if data global val null val equal boolean true didn t match even onc return data str sub string lc thi left context replac glob data cx scope thi lc index lc length data char buf append rc char arrai rc index rc length return data char buf to string default throw kit code bug 
analog of c match or replac privat static object match or replac context cx scriptabl scope scriptabl thi obj object arg reg exp impl re impl glob data data boolean forc flat nativ reg exp re string str script runtim to string thi obj data str str scriptabl top scope scriptabl object get top level scope scope if arg length 0 object compil nativ reg exp compil re fals re new nativ reg exp top scope compil els if arg 0 instanceof nativ reg exp re nativ reg exp arg 0 els string src script runtim to string arg 0 string opt if data optarg arg length arg 0 src opt script runtim to string arg data optarg els opt null object compil nativ reg exp compil re src opt forc flat re new nativ reg exp top scope compil data regexp re data global re get flag nativ reg exp jsreg glob 0 int indexp 0 object result null if data mode ra search result re execut reg exp cx scope re impl str indexp nativ reg exp test if result null result equal boolean true result new integ re impl left context length els result new integ 1 els if data global re last index 0 for int count 0 indexp 0 str length count result re execut reg exp cx scope re impl str indexp nativ reg exp test if result null result equal boolean true break if data mode ra match match glob data cx scope count re impl els if data mode ra replac kit code bug sub string last match re impl last match int left index data left index int leftlen last match index left index data left index last match index last match length replac glob data cx scope re impl left index leftlen if re impl last match length 0 if indexp 0 str length break indexp 0 els result re execut reg exp cx scope re impl str indexp data mode ra replac nativ reg exp test nativ reg exp match return result 
public int find split context cx scriptabl scope string target string separ scriptabl re obj int ip int matchlen boolean match string parensp int i ip 0 int length target length int result int version cx get languag version nativ reg exp re nativ reg exp re obj again while true imit c label js1 2 deviat from perl by never match at end of string int ipsav ip 0 reus ip to save object creation ip 0 i object ret re execut reg exp cx scope thi target ip nativ reg exp test if ret boolean true mismatch ensur our caller advanc i past end of string ip 0 ipsav matchlen 0 1 match 0 fals return length i ip 0 ip 0 ipsav match 0 true sub string sep thi last match matchlen 0 sep length if matchlen 0 0 empti string match never split on an empti match at the start of a find split cycl same rule as for an empti global match in match or replac if i ip 0 bump along to avoid stick at an empti match but don t bump past end of string our caller must do that by ad sep length to our return valu if i length if version context version 1 2 matchlen 0 1 result i els result 1 break i continu again imit c goto pr assert size t i sep length result i matchlen 0 break int size paren null 0 paren length parensp 0 new string size for int num 0 num size num sub string parsub get paren sub string num parensp 0 num parsub to string return result 
analog of regexp paren substr in c jsregexp h assum zero base i e for 3 i 2 sub string get paren sub string int i if paren null i paren length sub string parsub paren i if parsub null return parsub return sub string empti sub string 
privat static void match glob glob data mdata context cx scriptabl scope int count reg exp impl re impl if mdata arrayobj null scriptabl s scriptabl object get top level scope scope mdata arrayobj script runtim new object cx s arrai null sub string matchsub re impl last match string matchstr matchsub to string mdata arrayobj put count mdata arrayobj matchstr 
privat static void replac glob glob data rdata context cx scriptabl scope reg exp impl re impl int left index int leftlen int replen string lambda str if rdata lambda null invok lambda function with arg last match 1 2 n left context length whole string sub string paren re impl paren int paren count paren null 0 paren length object arg new object paren count 3 arg 0 re impl last match to string for int i 0 i paren count i sub string sub paren i if sub null arg i 1 sub to string els arg i 1 undefin instanc arg paren count 1 new integ re impl left context length arg paren count 2 rdata str thi is a hack to prevent expos of re impl data to js function which can run new regexp modif regexp that ar us later by the engin todo redesign is necessari if re impl script runtim get reg exp proxi cx kit code bug reg exp impl re2 new reg exp impl re2 multilin re impl multilin re2 input re impl input script runtim set reg exp proxi cx re2 try scriptabl parent scriptabl object get top level scope scope object result rdata lambda call cx parent parent arg lambda str script runtim to string result final script runtim set reg exp proxi cx re impl replen lambda str length els lambda str null replen rdata repstr length if rdata dollar 0 int skip new int 1 int dp rdata dollar do sub string sub interpret dollar cx re impl rdata repstr dp skip if sub null replen sub length skip 0 dp skip 0 els dp dp rdata repstr index of dp while dp 0 int growth leftlen replen re impl right context length string buffer char buf rdata char buf if char buf null char buf new string buffer growth rdata char buf char buf els char buf ensur capac rdata char buf length growth char buf append re impl left context char arrai left index leftlen if rdata lambda null char buf append lambda str els do replac rdata cx re impl 
privat static sub string interpret dollar context cx reg exp impl re string da int dp int skip char dc int num tmp if da char at dp kit code bug allow a real backslash liter to escap 1 etc int version cx get languag version if version context version default version context version 1 4 if dp 0 da char at dp 1 return null int da l da length if dp 1 da l return null interpret all perl match induc dollar variabl dc da char at dp 1 if nativ reg exp is digit dc int cp if version context version default version context version 1 4 if dc 0 return null check for overflow to avoid gobbl arbitrari decim digit num 0 cp dp while cp da l nativ reg exp is digit dc da char at cp tmp 10 num dc 0 if tmp num break num tmp els ecma 3 1 9 or 01 99 int paren count re paren null 0 re paren length num dc 0 if num paren count return null cp dp 2 if dp 2 da l dc da char at dp 2 if nativ reg exp is digit dc tmp 10 num dc 0 if tmp paren count cp num tmp if num 0 return null 0 or 00 is not valid adjust num from 1 n origin to 0 arrai index origin num skip 0 cp dp return re get paren sub string num skip 0 2 switch dc case return new sub string case return re last match case return re last paren case if version context version 1 2 js1 2 imit the perl4 bug where left context at each step in an iter us of a global regexp start from last match not from the start of the target string but perl4 doe start at the begin of the target string when it is us in a substitut so we emul that special case here re left context index 0 re left context length re last match index return re left context case return re right context return null 
analog of do replac in jsstr c privat static void do replac glob data rdata context cx reg exp impl reg exp impl string buffer char buf rdata char buf int cp 0 string da rdata repstr int dp rdata dollar if dp 1 int skip new int 1 do int len dp cp char buf append da substr cp dp cp dp sub string sub interpret dollar cx reg exp impl da dp skip if sub null len sub length if len 0 char buf append sub char arrai sub index len cp skip 0 dp skip 0 els dp dp da index of dp while dp 0 int da l da length if da l cp char buf append da substr cp da l 
public parser compil environ compil env error report error report thi compil env compil env thi error report error report 
protect decompil creat decompil compil environ compil env return new decompil 
void add warn string messag id string messag arg string messag script runtim get message1 messag id messag arg error report warn messag sourc uri ts get lineno ts get line ts get offset 
void add error string messag id syntax error count string messag script runtim get message0 messag id error report error messag sourc uri ts get lineno ts get line ts get offset 
runtim except report error string messag id add error messag id throw a parser except except to unwind the recurs descent pars throw new parser except 
privat int peek token throw ioexcept int tt current flag token if tt token eof tt ts get token if tt token eol do tt ts get token while tt token eol tt ti after eol current flag token tt return tt clear ti mask 
privat int peek flag token throw ioexcept peek token return current flag token 
privat void consum token current flag token token eof 
privat int next token throw ioexcept int tt peek token consum token return tt 
privat int next flag token throw ioexcept peek token int tt flag current flag token consum token return tt flag 
privat boolean match token int to match throw ioexcept int tt peek token if tt to match return fals consum token return true 
privat int peek token or eol throw ioexcept int tt peek token check for last peek token flag if current flag token ti after eol 0 tt token eol return tt 
privat void set check for label if current flag token clear ti mask token name throw kit code bug current flag token ti check label 
privat void must match token int to match string messag id throw ioexcept parser except if match token to match report error messag id 
privat void must have xml if compil env is xml avail report error msg xml not avail 
public string get encod sourc return encod sourc 
public boolean eof return ts eof 
boolean insid function return nest of function 0 
privat node enter loop node loop label node loop nf creat loop node loop label ts get lineno if loop set null loop set new obj arrai if loop and switch set null loop and switch set new obj arrai loop set push loop loop and switch set push loop return loop 
privat void exit loop loop set pop loop and switch set pop 
privat node enter switch node switch selector int lineno node switch label node switch node nf creat switch switch selector lineno if loop and switch set null loop and switch set new obj arrai loop and switch set push switch node return switch node 
privat void exit switch loop and switch set pop 
public script or fn node pars string sourc string string sourc uri int lineno thi sourc uri sourc uri thi ts new token stream thi null sourc string lineno try return pars catch ioexcept ex should never happen throw new illeg state except 
public script or fn node pars reader sourc reader string sourc uri int lineno throw ioexcept thi sourc uri sourc uri thi ts new token stream thi sourc reader null lineno return pars 
privat script or fn node pars throw ioexcept thi decompil creat decompil compil env thi nf new irfactori thi current script or fn nf creat script int sourc start offset decompil get current offset thi encod sourc null decompil add token token script thi current flag token token eof thi syntax error count 0 int base lineno ts get lineno line number where sourc start so we have someth to add node to until we ve collect all the sourc node pn nf creat leaf token block try for int tt peek token if tt token eof break node n if tt token function consum token try n function call by compil function function node function express function node function statement catch parser except e break els n statement nf add child to back pn n catch stack overflow error ex string msg script runtim get message0 mag too deep parser recurs throw context report runtim error msg sourc uri ts get lineno null 0 if thi syntax error count 0 string msg string valu of thi syntax error count msg script runtim get message1 msg got syntax error msg throw error report runtim error msg sourc uri base lineno null 0 current script or fn set sourc name sourc uri current script or fn set base lineno base lineno current script or fn set end lineno ts get lineno int sourc end offset decompil get current offset current script or fn set encod sourc bound sourc start offset sourc end offset nf init script current script or fn pn if compil env is gener sourc encod sourc decompil get encod sourc thi decompil null it help gc return current script or fn 
privat node pars function bodi throw ioexcept nest of function node pn nf creat block ts get lineno try bodi loop for node n int tt peek token switch tt case token error case token eof case token rc break bodi loop case token function consum token n function function node function statement break default n statement break nf add child to back pn n catch parser except e ignor it final nest of function return pn 
privat node function int function type throw ioexcept parser except int synthet type function type int base lineno ts get lineno line number where sourc start int function sourc start decompil mark function start function type string name node member expr node null if match token token name name ts get string decompil add name name if match token token lp if compil env is allow member expr as function name extens to ecma if function name doe not follow by assum name start member expr node member expr head nf creat name name name member expr node member expr tail fals member expr head must match token token lp msg no paren parm els if match token token lp anonym function name els name if compil env is allow member expr as function name note that member expr can not start with like in function 1 2 to string becaus function alreadi process as anonym function member expr node member expr fals must match token token lp msg no paren parm if member expr node null synthet type function node function express boolean nest insid function function node fn node nf creat function name if nest nest of with 0 1 nest function ar not affect by the dynam scope flag as dynam scope is alreadi a parent of their scope 2 function defin under the with statement also immun to thi setup in which case dynam scope is ignor in favor of with object fn node it ignor dynam scope true int function index current script or fn add function fn node int function sourc end script or fn node save script or fn current script or fn current script or fn fn node int save nest of with nest of with nest of with 0 hashtabl save label set label set label set null obj arrai save loop set loop set loop set null obj arrai save loop and switch set loop and switch set loop and switch set null node bodi string sourc try decompil add token token lp if match token token rp boolean first true do if first decompil add token token comma first fals must match token token name msg no parm string s ts get string if fn node ha param or var s add warn msg dup parm s fn node add param s decompil add name s while match token token comma must match token token rp msg no paren after parm decompil add token token rp must match token token lc msg no brace bodi decompil add eol token lc bodi pars function bodi must match token token rc msg no brace after bodi decompil add token token rc function sourc end decompil mark function end function sourc start if function type function node function express if compil env get languag version context version 1 2 function f function g is not allow in 1 2 or later but for compat with old script the check is done onli if languag is explicitli set xxx warn need if version version default int tt peek token or eol if tt token function report error msg no semi stmt add eol onli if function is not part of express sinc it get semi eol from statement in that case decompil add token token eol final loop and switch set save loop and switch set loop set save loop set label set save label set nest of with save nest of with current script or fn save script or fn fn node set encod sourc bound function sourc start function sourc end fn node set sourc name sourc uri fn node set base lineno base lineno fn node set end lineno ts get lineno node pn nf init function fn node function index bodi synthet type if member expr node null pn nf creat assign token assign member expr node pn if function type function node function express xxx check jscript behavior should it be creat expr statement pn nf creat expr statement no return pn base lineno return pn 
privat node statement throw ioexcept node pn nf creat block ts get lineno int tt while tt peek token token eof tt token rc nf add child to back pn statement return pn 
privat node condit throw ioexcept parser except node pn must match token token lp msg no paren cond decompil add token token lp pn expr fals must match token token rp msg no paren after cond decompil add token token rp there s a check here in jspars c that correct to return pn 
match a name return null if no match privat node match jump label name throw ioexcept parser except node label null int tt peek token or eol if tt token name consum token string name ts get string decompil add name name if label set null label node label set get name if label null report error msg undef label return label 
privat node statement throw ioexcept try node pn statement helper null if pn null return pn catch parser except e skip to end of statement int lineno ts get lineno guess statement end for int tt peek token or eol consum token switch tt case token error case token eof case token eol case token semi break guess statement end return nf creat expr statement nf creat name error lineno 
whether the catch e e instanceof except syntax is implement privat node statement helper node statement label throw ioexcept parser except node pn null int tt tt peek token switch tt case token if consum token decompil add token token if int lineno ts get lineno node cond condit decompil add eol token lc node if true statement node if fals null if match token token els decompil add token token rc decompil add token token els decompil add eol token lc if fals statement decompil add eol token rc pn nf creat if cond if true if fals lineno return pn case token switch consum token decompil add token token switch int lineno ts get lineno must match token token lp msg no paren switch decompil add token token lp pn enter switch expr fals lineno statement label try must match token token rp msg no paren after switch decompil add token token rp must match token token lc msg no brace switch decompil add eol token lc boolean ha default fals switch loop for tt next token node case express switch tt case token rc break switch loop case token case decompil add token token case case express expr fals must match token token colon msg no colon case decompil add eol token colon break case token default if ha default report error msg doubl switch default decompil add token token default ha default true case express null must match token token colon msg no colon case decompil add eol token colon break default report error msg bad switch break switch loop node block nf creat leaf token block while tt peek token token rc tt token case tt token default tt token eof nf add child to back block statement case express null add default labl nf add switch case pn case express block decompil add eol token rc nf close switch pn final exit switch return pn case token while consum token decompil add token token while node loop enter loop statement label try node cond condit decompil add eol token lc node bodi statement decompil add eol token rc pn nf creat while loop cond bodi final exit loop return pn case token do consum token decompil add token token do decompil add eol token lc node loop enter loop statement label try node bodi statement decompil add token token rc must match token token while msg no while do decompil add token token while node cond condit pn nf creat do while loop bodi cond final exit loop alwai auto insert semicon to follow spider monkei it is requir by emascript but is ignor by the rest of world see bug 238945 match token token semi decompil add eol token semi return pn case token for consum token boolean is for each fals decompil add token token for node loop enter loop statement label try node init node init is also foo in foo in object node cond node cond is also object in foo in object node incr null to kill warn node bodi see if thi is a for each instead of just a for if match token token name decompil add name ts get string if ts get string equal each is for each true els report error msg no paren for must match token token lp msg no paren for decompil add token token lp tt peek token if tt token semi init nf creat leaf token empti els if tt token var set init to a var list or initi consum token consum the var token init variabl true els init expr true if match token token in decompil add token token in cond is the object over which we re iter cond expr fals els ordinari for loop must match token token semi msg no semi for decompil add token token semi if peek token token semi no loop condit cond nf creat leaf token empti els cond expr fals must match token token semi msg no semi for cond decompil add token token semi if peek token token rp incr nf creat leaf token empti els incr expr fals must match token token rp msg no paren for ctrl decompil add token token rp decompil add eol token lc bodi statement decompil add eol token rc if incr null cond could be null if in obj got eaten by the init node pn nf creat for in loop init cond bodi is for each els pn nf creat for loop init cond incr bodi final exit loop return pn case token try consum token int lineno ts get lineno node tryblock node catchblock null node finallyblock null decompil add token token try decompil add eol token lc tryblock statement decompil add eol token rc catchblock nf creat leaf token block boolean saw default catch fals int peek peek token if peek token catch while match token token catch if saw default catch report error msg catch unreach decompil add token token catch must match token token lp msg no paren catch decompil add token token lp must match token token name msg bad catchcond string var name ts get string decompil add name var name node catch cond null if match token token if decompil add token token if catch cond expr fals els saw default catch true must match token token rp msg bad catchcond decompil add token token rp must match token token lc msg no brace catchblock decompil add eol token lc nf add child to back catchblock nf creat catch var name catch cond statement ts get lineno must match token token rc msg no brace after bodi decompil add eol token rc els if peek token final must match token token final msg try no catchfin if match token token final decompil add token token final decompil add eol token lc finallyblock statement decompil add eol token rc pn nf creat try catch final tryblock catchblock finallyblock lineno return pn case token throw consum token if peek token or eol token eol ecmascript doe not allow new line befor throw express see bug 256617 report error msg bad throw eol int lineno ts get lineno decompil add token token throw pn nf creat throw expr fals lineno break case token break consum token int lineno ts get lineno decompil add token token break match jump label name onli match if there is on node break statement match jump label name if break statement null if loop and switch set null loop and switch set size 0 report error msg bad break return null break statement node loop and switch set peek pn nf creat break break statement lineno break case token continu consum token int lineno ts get lineno decompil add token token continu node loop match jump label name onli match if there is on node label match jump label name if label null if loop set null loop set size 0 report error msg continu outsid return null loop node loop set peek els loop nf get label loop label if loop null report error msg continu nonloop return null pn nf creat continu loop lineno break case token with consum token decompil add token token with int lineno ts get lineno must match token token lp msg no paren with decompil add token token lp node obj expr fals must match token token rp msg no paren after with decompil add token token rp decompil add eol token lc nest of with node bodi try bodi statement final nest of with decompil add eol token rc pn nf creat with obj bodi lineno return pn case token var consum token pn variabl fals break case token return if insid function report error msg bad return consum token decompil add token token return int lineno ts get lineno node ret expr thi is ugli but we don t want to requir a semicolon tt peek token or eol switch tt case token semi case token rc case token eof case token eol case token error ret expr null break default ret expr expr fals pn nf creat return ret expr lineno break case token lc consum token if statement label null decompil add token token lc pn statement must match token token rc msg no brace block if statement label null decompil add eol token rc return pn case token error fall thru to have a node for error recoveri to work on case token semi consum token pn nf creat leaf token empti return pn case token function consum token pn function function node function express statement return pn case token default consum token must have xml decompil add token token default int ns line ts get lineno if match token token name ts get string equal xml report error msg bad namespac decompil add name ts get string if match token token name ts get string equal namespac report error msg bad namespac decompil add name ts get string if match token token assign report error msg bad namespac decompil add token token assign node expr expr fals pn nf creat default namespac expr ns line break case token name int lineno ts get lineno string name ts get string set check for label pn expr fals if pn get type token label pn nf creat expr statement pn lineno els pars the label push back token should be colon that primari expr left untouch if peek token token colon kit code bug consum token depend on decompil lookahead to guess that that last name wa a label decompil add name name decompil add eol token colon if label set null label set new hashtabl els if label set contain kei name report error msg dup label boolean first label if statement label null first label true statement label pn els discard multipl label node and us onli the first it allow to simplifi irfactori first label fals label set put name statement label try pn statement helper statement label final label set remov name if first label pn nf creat label statement statement label pn return pn break default int lineno ts get lineno pn expr fals pn nf creat expr statement pn lineno break int tt flag peek flag token switch tt flag clear ti mask case token semi consum as a part of express consum token break case token error case token eof case token rc autoinsert break default if tt flag ti after eol 0 report error if no eol or autoinsert otherwis report error msg no semi stmt break decompil add eol token semi return pn 
privat node variabl boolean in for init throw ioexcept parser except node pn nf creat variabl ts get lineno boolean first true decompil add token token var for node name node init must match token token name msg bad var string s ts get string if first decompil add token token comma first fals decompil add name s current script or fn add var s name nf creat name s omit check for argument hide if match token token assign decompil add token token assign init assign expr in for init nf add child to back name init nf add child to back pn name if match token token comma break return pn 
privat node expr boolean in for init throw ioexcept parser except node pn assign expr in for init while match token token comma decompil add token token comma pn nf creat binari token comma pn assign expr in for init return pn 
privat node assign expr boolean in for init throw ioexcept parser except node pn cond expr in for init int tt peek token if token first assign tt tt token last assign consum token decompil add token tt pn nf creat assign tt pn assign expr in for init return pn 
privat node cond expr boolean in for init throw ioexcept parser except node if true node if fals node pn or expr in for init if match token token hook decompil add token token hook if true assign expr fals must match token token colon msg no colon cond decompil add token token colon if fals assign expr in for init return nf creat cond expr pn if true if fals return pn 
privat node or expr boolean in for init throw ioexcept parser except node pn and expr in for init if match token token or decompil add token token or pn nf creat binari token or pn or expr in for init return pn 
privat node and expr boolean in for init throw ioexcept parser except node pn bit or expr in for init if match token token and decompil add token token and pn nf creat binari token and pn and expr in for init return pn 
privat node bit or expr boolean in for init throw ioexcept parser except node pn bit xor expr in for init while match token token bitor decompil add token token bitor pn nf creat binari token bitor pn bit xor expr in for init return pn 
privat node bit xor expr boolean in for init throw ioexcept parser except node pn bit and expr in for init while match token token bitxor decompil add token token bitxor pn nf creat binari token bitxor pn bit and expr in for init return pn 
privat node bit and expr boolean in for init throw ioexcept parser except node pn eq expr in for init while match token token bitand decompil add token token bitand pn nf creat binari token bitand pn eq expr in for init return pn 
privat node eq expr boolean in for init throw ioexcept parser except node pn rel expr in for init for int tt peek token switch tt case token eq case token ne case token sheq case token shne consum token int decompil token tt int pars token tt if compil env get languag version context version 1 2 java script 1 2 us shallow equal for and in addit convert and for decompil into and sinc the decompil is suppos to show canon sourc and in 1 2 ar allow onli as an alia to switch tt case token eq pars token token sheq break case token ne pars token token shne break case token sheq decompil token token eq break case token shne decompil token token ne break decompil add token decompil token pn nf creat binari pars token pn rel expr in for init continu break return pn 
privat node rel expr boolean in for init throw ioexcept parser except node pn shift expr for int tt peek token switch tt case token in if in for init break fall through case token instanceof case token le case token lt case token ge case token gt consum token decompil add token tt pn nf creat binari tt pn shift expr continu break return pn 
privat node shift expr throw ioexcept parser except node pn add expr for int tt peek token switch tt case token lsh case token ursh case token rsh consum token decompil add token tt pn nf creat binari tt pn add expr continu break return pn 
privat node add expr throw ioexcept parser except node pn mul expr for int tt peek token if tt token add tt token sub consum token decompil add token tt flush new line pn nf creat binari tt pn mul expr continu break return pn 
privat node mul expr throw ioexcept parser except node pn unari expr for int tt peek token switch tt case token mul case token div case token mod consum token decompil add token tt pn nf creat binari tt pn unari expr continu break return pn 
privat node unari expr throw ioexcept parser except int tt tt peek token switch tt case token void case token not case token bitnot case token typeof consum token decompil add token tt return nf creat unari tt unari expr case token add consum token convert to special po token in decompil and pars tree decompil add token token po return nf creat unari token po unari expr case token sub consum token convert to special neg token in decompil and pars tree decompil add token token neg return nf creat unari token neg unari expr case token inc case token dec consum token decompil add token tt return nf creat inc dec tt fals member expr true case token delprop consum token decompil add token token delprop return nf creat unari token delprop unari expr case token error consum token break xml stream encount in express case token lt if compil env is xml avail consum token node pn xml initi return member expr tail true pn fall thru to the default handl of relop default node pn member expr true don t look across a newlin boundari for a postfix incop tt peek token or eol if tt token inc tt token dec consum token decompil add token tt return nf creat inc dec tt true pn return pn return nf creat name err onli reach on error try to continu 
privat node xml initi throw ioexcept int tt ts get first xmltoken if tt token xml tt token xmlend report error msg syntax return null make a new node to append to node pn xml nf creat leaf token new string xml ts get string boolean f anonym xml trim start with node pn nf creat name f anonym xmllist xml nf add child to back pn xml pn pn null node expr for tt ts get next xmltoken switch tt case token xml xml ts get string decompil add name xml must match token token lc msg syntax decompil add token token lc expr peek token token rc nf creat string expr fals must match token token rc msg syntax decompil add token token rc if pn null pn nf creat string xml els pn nf creat binari token add pn nf creat string xml int node type if ts is xmlattribut node type token escxmlattr els node type token escxmltext expr nf creat unari node type expr pn nf creat binari token add pn expr break case token xmlend xml ts get string decompil add name xml if pn null pn nf creat string xml els pn nf creat binari token add pn nf creat string xml nf add child to back pn xml pn return pn xml default report error msg syntax return null 
privat void argument list node list node throw ioexcept parser except boolean match match match token token rp if match boolean first true do if first decompil add token token comma first fals nf add child to back list node assign expr fals while match token token comma must match token token rp msg no paren arg decompil add token token rp 
privat node member expr boolean allow call syntax throw ioexcept parser except int tt node pn check for new express tt peek token if tt token new eat the new token consum token decompil add token token new make a new node to append to pn nf creat call or new token new member expr fals if match token token lp decompil add token token lp add the argument to pn if ani ar suppli argument list pn xxx there s a check in the c sourc against too mani constructor argument how mani do we claim to support experiment syntax allow an object liter to follow a new express which will mean a kind of anonym class built with the java adapt the object liter will be pass as an addit argument to the constructor tt peek token if tt token lc nf add child to back pn primari expr els pn primari expr return member expr tail allow call syntax pn 
privat node member expr tail boolean allow call syntax node pn throw ioexcept parser except tail loop for int tt peek token switch tt case token dot case token dotdot int member type flag string s consum token decompil add token tt member type flag 0 if tt token dotdot must have xml member type flag node descend flag if compil env is xml avail must match token token name msg no name after dot s ts get string decompil add name s pn nf creat properti get pn null s member type flag break tt next token switch tt handl name ns name ns ns expr case token name s ts get string decompil add name s pn properti name pn s member type flag break handl name expr case token mul decompil add name pn properti name pn member type flag break handl attr ns attr ns ns attr attr case token xmlattr decompil add token token xmlattr pn attribut access pn member type flag break default report error msg no name after dot break case token dotqueri consum token must have xml decompil add token token dotqueri pn nf creat dot queri pn expr fals ts get lineno must match token token rp msg no paren decompil add token token rp break case token lb consum token decompil add token token lb pn nf creat element get pn null expr fals 0 must match token token rb msg no bracket index decompil add token token rb break case token lp if allow call syntax break tail loop consum token decompil add token token lp pn nf creat call or new token call pn add the argument to pn if ani ar suppli argument list pn break default break tail loop return pn 
privat node attribut access node pn int member type flag throw ioexcept member type flag node attribut flag int tt next token switch tt handl name ns name ns ns expr case token name string s ts get string decompil add name s pn properti name pn s member type flag break handl name expr case token mul decompil add name pn properti name pn member type flag break handl expr case token lb decompil add token token lb pn nf creat element get pn null expr fals member type flag must match token token rb msg no bracket index decompil add token token rb break default report error msg no name after xml attr pn nf creat properti get pn null member type flag break return pn 
check if follow name in which case it becom qualifi name privat node properti name node pn string name int member type flag throw ioexcept parser except string namespac null if match token token coloncolon decompil add token token coloncolon namespac name int tt next token switch tt handl name name case token name name ts get string decompil add name name break handl name case token mul decompil add name name break handl name expr case token lb decompil add token token lb pn nf creat element get pn namespac expr fals member type flag must match token token rb msg no bracket index decompil add token token rb return pn default report error msg no name after coloncolon name pn nf creat properti get pn namespac name member type flag return pn 
privat node primari expr throw ioexcept parser except node pn int tt flag next flag token int tt tt flag clear ti mask switch tt case token function return function function node function express case token lb obj arrai elem new obj arrai int skip count 0 decompil add token token lb boolean after lb or comma true for tt peek token if tt token comma consum token decompil add token token comma if after lb or comma after lb or comma true els elem add null skip count els if tt token rb consum token decompil add token token rb break els if after lb or comma report error msg no bracket arg elem add assign expr fals after lb or comma fals return nf creat arrai liter elem skip count case token lc obj arrai elem new obj arrai decompil add token token lc if match token token rc boolean first true commaloop do object properti if first decompil add token token comma els first fals tt peek token switch tt case token name case token string consum token map name to string in object liter context but tell the decompil the proper type string s ts get string if tt token name decompil add name s els decompil add string s properti script runtim get index object s break case token number consum token doubl n ts get number decompil add number n properti script runtim get index object n break case token rc trail comma is ok break commaloop default report error msg bad prop break commaloop must match token token colon msg no colon prop objlit is us as in object liter for decompil to solv space ambigu decompil add token token objectlit elem add properti elem add assign expr fals while match token token comma must match token token rc msg no brace prop decompil add token token rc return nf creat object liter elem case token lp brendan s ir jspars c make a new node tag with tok lp here i m not sure i understand why isn t the group alreadi implicit in the structur of the pars tree also tok lp is alreadi overload i think in the c ir as function call decompil add token token lp pn expr fals decompil add token token rp must match token token rp msg no paren return pn case token xmlattr must have xml decompil add token token xmlattr pn attribut access null 0 return pn case token name string name ts get string if tt flag ti check label 0 if peek token token colon do not consum colon it is us as unwind indic to return to statement helper xxx better wai return nf creat label ts get lineno decompil add name name if compil env is xml avail pn properti name null name 0 els pn nf creat name name return pn case token number doubl n ts get number decompil add number n return nf creat number n case token string string s ts get string decompil add string s return nf creat string s case token div case token assign div got or which should be treat as regexp in fact ts read reg exp tt string flag ts reg exp flag ts reg exp flag null string re ts get string decompil add regexp re flag int index current script or fn add regexp re flag return nf creat reg exp index case token null case token thi case token fals case token true decompil add token tt return nf creat leaf tt case token reserv report error msg reserv id break case token error the scanner or on of it subroutin report the error break case token eof report error msg unexpect eof break default report error msg syntax break return null should never reach here 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public int ambigu char arg return char 
public int ambigu short arg return short 
public int ambigu int arg return int 
public int ambigu long arg return long 
public int ambigu string arg return string 
return string public int expect return string 
public class data type 019 extend live connect test public data type 019 super 
public static void main string arg data type 019 test new data type 019 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt file bugnumb 302019 
public void execut test string expect string valu data type class pub string represent int expect number valu data type class pub number represent doubl expect doubl valu data type class pub doubl represent string actual string valu doubl actual number valu 0 doubl actual doubl valu 0 string js string doubl js number 0 try actual string valu string global eval dt to string actual number valu doubl global eval dt to number doubl valu actual doubl valu doubl global eval dt doubl valu doubl valu js string string global eval var js string string dt js string js number doubl global eval var js number number dt js number doubl valu catch except e e print stack trace file except e to string add test case dt to string expect string valu actual string valu file except add test case actual number valu expect number valu dt to number expect number valu actual number valu true expect number valu actual number valu file except add test case actual doubl valu expect doubl valu dt doubl valu expect doubl valu actual doubl valu true expect doubl valu actual doubl valu file except add test case global eval var js string string dt js string js string equal expect string valu true js string equal expect string valu file except add test case js number js number global eval var js number number dt js number js number expect doubl valu true js number expect doubl valu file except 
public class data type 017 extend live connect test public data type 017 super 
public static void main string arg data type 017 test new data type 017 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
call the setter test with 5 valu ul li string valu to call setter getter with li method to set the valu li method to get the valu li field that return the valu li expect result of getter field li whether or not an except get thrown ul the rule for convers ul li if the setter set the valu out of the rang return an except li if the valu is in rang transform valu to math floor valu li na n return 0 ul public void execut test for int i 0 i js val length i do setter test js val i dt set doubl dt get doubl dt pub doubl new doubl js val i doubl valu doubl max valu object except new doubl js val i doubl valu doubl min valu object except new doubl js val i do setter test dt set byte js val i dt get byte dt pub byte number new byte new float js val i byte valu new float byte max valu new float byte min valu do setter test dt set short js val i dt get short dt pub short number new short new doubl js val i short valu new float short max valu new float short min valu do setter test dt set integ js val i dt get integ dt pub int number new integ new doubl js val i int valu new float integ max valu new float integ min valu do setter test dt set float js val i dt get float dt pub float number new float new doubl js val i float valu new float float max valu new float float min valu do setter test dt set long js val i dt get long dt pub long number new long new doubl js val i long valu new float long max valu new float long min valu 
thi test call a java setter method from java script it verifi that the setter wa call properli in two wai by check the return valu of the getter method and by check the valu of the public field that wa set param setter java method that take an argument and set a valu param js valu java script valu that is pass to the setter param getter java method that return the valu set by setter param field java field that setter chang param e result expect result which should be of some number type public void do setter test string js valu string setter string getter string field object e result string set method setter js valu string get method getter string setter result no except thrown doubl getter result null doubl field result null object expect result null boolean eq fals try eq e result get class equal class for name java lang string catch class not found except e add test case set method driver error veri bad file except if eq try global eval set method catch except e setter result except file except e to string e print stack trace final add test case set method should throw a jsexcept except setter result file except els try from java script call the setter global eval set method from java script call the getter getter result doubl global eval get method from java sript access the field field result doubl global eval field catch except e e print stack trace file except e to string final add test case valu getter result expect expect result set method get method expect result equal getter result true expect result equal getter result file except add test case valu field result expect expect result set method field expect result equal field result true expect result equal field result file except 
qname xmllib impl lib string uri string local name string prefix super lib global scope lib qname prototyp if local name null throw new illeg argument except thi lib lib thi uri uri thi prefix prefix thi local name local name 
void export as jsclass boolean seal export as jsclass max prototyp id lib global scope seal 
return public string to string string result if uri null result concat local name els if uri length 0 result local name els result uri local name return result 
public string local name return local name 
string prefix return prefix null prefix 
string uri return uri 
public boolean equal object obj if obj instanceof qname return fals return equal qname obj 
protect object equival valu object valu if valu instanceof qname return scriptabl not found boolean result equal qname valu return result boolean true boolean fals 
privat boolean equal qname q boolean result if uri null result q uri null local name equal q local name els result uri equal q uri local name equal q local name return result 
return public string get class name return qname 
param hint return public object get default valu class hint return to string 
max instanc id 2 protect int get max instanc id return super get max instanc id max instanc id 
protect int find instanc id info string s int id gener last updat 2004 07 18 12 32 51 cest l0 id 0 string x null int s length s length if s length 3 x uri id id uri els if s length 9 x local name id id local name if x null x s x equal s id 0 gener if id 0 return super find instanc id info s int attr switch id case id local name case id uri attr perman readonli break default throw new illeg state except return instanc id info attr super get max instanc id id 
protect string get instanc id name int id switch id super get max instanc id case id local name return local name case id uri return uri return super get instanc id name id 
protect object get instanc id valu int id switch id super get max instanc id case id local name return local name case id uri return uri return super get instanc id valu id 
protect int find prototyp id string s int id gener last updat 2004 08 21 12 45 13 cest l0 id 0 string x null int c int s length s length if s length 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string els if s length 11 x constructor id id constructor if x null x s x equal s id 0 gener return id 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 2 s constructor break case id to string ariti 0 s to string break case id to sourc ariti 0 s to sourc break default throw new illeg argument except string valu of id init prototyp method qname tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag qname tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor return js constructor cx thi obj null arg case id to string return real thi thi obj f to string case id to sourc return real thi thi obj f js to sourc throw new illeg argument except string valu of id 
privat qname real thi scriptabl thi obj id function object f if thi obj instanceof qname throw incompat call error f return qname thi obj 
privat object js constructor context cx boolean in new expr object arg if in new expr arg length 1 return lib cast to qname cx arg 0 if arg length 0 return lib construct qname cx undefin instanc els if arg length 1 return lib construct qname cx arg 0 els return lib construct qname cx arg 0 arg 1 
privat string js to sourc string buffer sb new string buffer sb append to sourc impl uri local name prefix sb sb append return sb to string 
privat static void to sourc impl string uri string local name string prefix string buffer sb sb append new qname if uri null prefix null if equal local name sb append null els namespac to sourc impl prefix uri sb sb append sb append sb append script runtim escap string local name sb append 
public id valu pair string id string valu thi id length id length thi id id thi valu valu 
public int get line number return line number 
public int get line number return line number public void set line number int valu line number valu 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string expect return char 
java adapt signatur class super class class interfac obj to int map name thi super class super class thi interfac interfac thi name name 
public boolean equal object obj if obj instanceof java adapt signatur return fals java adapt signatur sig java adapt signatur obj if super class sig super class return fals if interfac sig interfac if interfac length sig interfac length return fals for int i 0 i interfac length i if interfac i sig interfac i return fals if name size sig name size return fals obj to int map iter iter new obj to int map iter name for iter start iter done iter next string name string iter get kei int ariti iter get valu if ariti name get name ariti 1 return fals return true 
public int hash code return super class hash code 0x9e3779b9 name size interfac length 16 
public static void init context cx scriptabl scope boolean seal java adapt obj new java adapt id function object ctor new id function object obj ftag id java adapt java adapt 1 scope ctor mark as constructor null if seal ctor seal object ctor export as scope properti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag ftag if f method id id java adapt return js creat adpter cx scope arg throw f unknown 
public static object convert result object result class c if result undefin instanc c script runtim object class c script runtim string class avoid an error for an undefin valu return null instead return null return context js to java result c 
public static scriptabl creat adapt wrapper scriptabl obj object adapt scriptabl scope scriptabl object get top level scope obj nativ java object re new nativ java object scope adapt null re set prototyp obj return re 
public static object get adapt self class adapt class object adapt throw no such field except illeg access except field self adapt class get declar field self return self get adapt 
static object js creat adpter context cx scriptabl scope object arg int n arg length if n 0 throw script runtim type error0 msg adapt zero arg class super class null class intf new class n 1 int interfac count 0 for int i 0 i n 1 i object arg arg i if arg instanceof nativ java class throw script runtim type error2 msg not java class arg string valu of i script runtim to string arg class c nativ java class arg get class object if c is interfac if super class null throw script runtim type error2 msg onli on super super class get name c get name super class c els intf interfac count c if super class null super class script runtim object class class interfac new class interfac count system arraycopi intf 0 interfac 0 interfac count scriptabl obj script runtim to object cx scope arg n 1 class adapt class get adapt class scope super class interfac obj class ctor parm script runtim context factori class script runtim scriptabl class object ctor arg cx get factori obj try object adapt adapt class get constructor ctor parm new instanc ctor arg return get adapt self adapt class adapt catch except ex throw context throw as script runtim ex ex 
need by nativ java object serial public static void write adapt object object java object object output stream out throw ioexcept class cl java object get class out write object cl get superclass get name class interfac cl get interfac string interfac name new string interfac length for int i 0 i interfac length i interfac name i interfac i get name out write object interfac name try object delege cl get field delege get java object out write object delege return catch illeg access except e catch no such field except e throw new ioexcept 
need by nativ java object de serial public static object read adapt object scriptabl self object input stream in throw ioexcept class not found except context factori factori context cx context get current context if cx null factori cx get factori els factori null class super class class for name string in read object string interfac name string in read object class interfac new class interfac name length for int i 0 i interfac name length i interfac i class for name interfac name i scriptabl delege scriptabl in read object class adapt class get adapt class self super class interfac delege class ctor parm script runtim context factori class script runtim scriptabl class script runtim scriptabl class object ctor arg factori delege self try return adapt class get constructor ctor parm new instanc ctor arg catch instanti except e catch illeg access except e catch invoc target except e catch no such method except e throw new class not found except adapt 
privat static obj to int map get object function name scriptabl obj object id scriptabl object get properti id obj obj to int map map new obj to int map id length for int i 0 i id length i if id i instanceof string continu string id string id i object valu scriptabl object get properti obj id if valu instanceof function function f function valu int length script runtim to int32 scriptabl object get properti f length if length 0 length 0 map put id length return map 
privat static class get adapt class scriptabl scope class super class class interfac scriptabl obj class cach cach class cach get scope hashtabl gener cach java adapt gener class obj to int map name get object function name obj java adapt signatur sig sig new java adapt signatur super class interfac name class adapt class class gener get sig if adapt class null string adapt name adapt cach new class serial number byte code creat adapt code name adapt name super class interfac null adapt class load adapt class adapt name code if cach is cach enabl gener put sig adapt class return adapt class 
public static byte creat adapt code obj to int map function name string adapt name class super class class interfac string script class name class file writer cfw new class file writer adapt name super class get name adapt cfw add field factori lorg mozilla javascript context factori short class file writer acc public class file writer acc final cfw add field delege lorg mozilla javascript scriptabl short class file writer acc public class file writer acc final cfw add field self lorg mozilla javascript scriptabl short class file writer acc public class file writer acc final int interfac count interfac null 0 interfac length for int i 0 i interfac count i if interfac i null cfw add interfac interfac i get name string super name super class get name replac gener ctor cfw adapt name super name gener serial ctor cfw adapt name super name if script class name null gener empti ctor cfw adapt name super name script class name obj to int map gener overrid new obj to int map obj to int map gener method new obj to int map gener method to satisfi all specifi interfac for int i 0 i interfac count i method method interfac i get method for int j 0 j method length j method method method j int mod method get modifi if modifi is static mod modifi is final mod continu string method name method get name class arg type method get paramet type if function name ha method name try super class get method method name arg type the class we re extend implement thi method and the java script object doesn t have an overrid see bug 61226 continu catch no such method except e not implement by superclass fall through make sure to gener onli on instanc of a particular method signatur string method signatur get method signatur method arg type string method kei method name method signatur if gener overrid ha method kei gener method cfw adapt name method name arg type method get return type gener overrid put method kei 0 gener method put method name 0 now go through the superclass method check for abstract method or addit method to overrid gener ani addit overrid that the object might contain method method super class get method for int j 0 j method length j method method method j int mod method get modifi if modifi is static mod modifi is final mod continu if a method is mark abstract must implement it or the result class won t be instanti otherwis if the object ha a properti of the same name then an overrid is intend boolean is abstract method modifi is abstract mod string method name method get name if is abstract method function name ha method name make sure to gener onli on instanc of a particular method signatur class arg type method get paramet type string method signatur get method signatur method arg type string method kei method name method signatur if gener overrid ha method kei gener method cfw adapt name method name arg type method get return type gener overrid put method kei 0 gener method put method name 0 if a method wa overridden gener a super method which let the deleg call the superclass version if is abstract method gener super cfw adapt name super name method name method signatur arg type method get return type gener java method for remain properti that ar not overrid obj to int map iter iter new obj to int map iter function name for iter start iter done iter next string function name string iter get kei if gener method ha function name continu int length iter get valu class parm new class length for int k 0 k length k parm k script runtim object class gener method cfw adapt name function name parm script runtim object class return cfw to byte arrai 
static class load adapt class string class name byte class byte gener class loader loader secur control creat loader null null class result loader defin class class name class byte loader link class result return result 
public static function get function scriptabl obj string function name object x scriptabl object get properti obj function name if x scriptabl not found thi method us to swallow the except from call an undefin method peopl have come to depend on thi somewhat dubiou behavior it allow peopl to avoid implement listen method that thei don t care about for instanc return null if x instanceof function throw script runtim not function error x function name return function x 
util method which dynam bind a context to the current thread if none alreadi exist public static object call method context factori factori final scriptabl thi obj final function f final object arg final long arg to wrap if f null see comment in get function return undefin instanc if factori null factori context factori get global final scriptabl scope f get parent scope if arg to wrap 0 return context call factori f scope thi obj arg context cx context get current context if cx null return do call cx scope thi obj f arg arg to wrap els return factori call new context action public object run context cx return do call cx scope thi obj f arg arg to wrap 
els return factori call new context action public object run context cx return do call cx scope thi obj f arg arg to wrap 
privat static object do call context cx scriptabl scope scriptabl thi obj function f object arg long arg to wrap wrap the rest of object for int i 0 i arg length i if 0 arg to wrap 1 i object arg arg i if arg instanceof scriptabl arg i cx get wrap factori wrap cx scope arg null return f call cx scope thi obj arg 
public static scriptabl run script final script script return scriptabl context call new context action public object run context cx scriptabl object global script runtim get global cx script exec cx global return global 
return scriptabl context call new context action public object run context cx scriptabl object global script runtim get global cx script exec cx global return global 
privat static void gener ctor class file writer cfw string adapt name string super name cfw start method init lorg mozilla javascript context factori lorg mozilla javascript scriptabl v class file writer acc public invok base class constructor cfw add byte code aload 0 thi cfw add invok byte code invokespeci super name init v save paramet in instanc variabl factori cfw add byte code aload 0 thi cfw add byte code aload 1 first arg context factori instanc cfw add byte code putfield adapt name factori lorg mozilla javascript context factori save paramet in instanc variabl delege cfw add byte code aload 0 thi cfw add byte code aload 2 second arg scriptabl delege cfw add byte code putfield adapt name delege lorg mozilla javascript scriptabl cfw add byte code aload 0 thi for the follow putfield for self creat a wrapper object to be us as thi in method call cfw add byte code aload 2 the scriptabl delege cfw add byte code aload 0 thi cfw add invok byte code invokestat org mozilla javascript java adapt creat adapt wrapper lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript scriptabl cfw add byte code putfield adapt name self lorg mozilla javascript scriptabl cfw add byte code return cfw stop method short 3 3 thi factori delege 
privat static void gener serial ctor class file writer cfw string adapt name string super name cfw start method init lorg mozilla javascript context factori lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl v class file writer acc public invok base class constructor cfw add byte code aload 0 thi cfw add invok byte code invokespeci super name init v save paramet in instanc variabl factori cfw add byte code aload 0 thi cfw add byte code aload 1 first arg context factori instanc cfw add byte code putfield adapt name factori lorg mozilla javascript context factori save paramet in instanc variabl delege cfw add byte code aload 0 thi cfw add byte code aload 2 second arg scriptabl delege cfw add byte code putfield adapt name delege lorg mozilla javascript scriptabl save self cfw add byte code aload 0 thi cfw add byte code aload 3 second arg scriptabl self cfw add byte code putfield adapt name self lorg mozilla javascript scriptabl cfw add byte code return cfw stop method short 4 4 thi factori delege self 
privat static void gener empti ctor class file writer cfw string adapt name string super name string script class name cfw start method init v class file writer acc public invok base class constructor cfw add byte code aload 0 thi cfw add invok byte code invokespeci super name init v set factori to null to us current global when necessari cfw add byte code aload 0 cfw add byte code aconst null cfw add byte code putfield adapt name factori lorg mozilla javascript context factori load script class cfw add byte code new script class name cfw add byte code dup cfw add invok byte code invokespeci script class name init v run script and save result scope cfw add invok byte code invokestat org mozilla javascript java adapt run script lorg mozilla javascript script lorg mozilla javascript scriptabl cfw add byte code astor 1 save the scriptabl in instanc variabl delege cfw add byte code aload 0 thi cfw add byte code aload 1 the scriptabl cfw add byte code putfield adapt name delege lorg mozilla javascript scriptabl cfw add byte code aload 0 thi for the follow putfield for self creat a wrapper object to be us as thi in method call cfw add byte code aload 1 the scriptabl cfw add byte code aload 0 thi cfw add invok byte code invokestat org mozilla javascript java adapt creat adapt wrapper lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript scriptabl cfw add byte code putfield adapt name self lorg mozilla javascript scriptabl cfw add byte code return cfw stop method short 2 thi delege 
gener code to wrap java argument into object non primit java type ar left as is pend convert in the helper method leav the arrai object on the top of the stack static void gener push wrap arg class file writer cfw class arg type int arrai length push argument cfw add push arrai length cfw add byte code anewarrai java lang object int param offset 1 for int i 0 i arg type length i cfw add byte code dup duplic arrai refer cfw add push i param offset gener wrap arg cfw param offset arg type i cfw add byte code aastor 
gener code to wrap java argument into object non primit java type ar left unconvert pend convert in the helper method leav the wrapper object on the top of the stack privat static int gener wrap arg class file writer cfw int param offset class arg type int size 1 if arg type is primit cfw add byte code aload param offset els if arg type boolean type wrap boolean valu with java lang boolean cfw add byte code new java lang boolean cfw add byte code dup cfw add byte code iload param offset cfw add invok byte code invokespeci java lang boolean init z v els if arg type charact type creat a string of length 1 us the charact paramet cfw add byte code iload param offset cfw add invok byte code invokestat java lang string valu of c ljava lang string els convert all numer valu to java lang doubl cfw add byte code new java lang doubl cfw add byte code dup string type name arg type get name switch type name char at 0 case b case s case i load an int valu convert to doubl cfw add byte code iload param offset cfw add byte code i2d break case l load a long convert to doubl cfw add byte code lload param offset cfw add byte code l2d size 2 break case f load a float convert to doubl cfw add byte code fload param offset cfw add byte code f2d break case d cfw add byte code dload param offset size 2 break cfw add invok byte code invokespeci java lang doubl init d v return size 
gener code to convert a wrap valu type to a primit type handl unwrap java lang boolean and java lang number type gener the appropri return bytecod static void gener return result class file writer cfw class ret type boolean call convert result wrap boolean valu with java lang boolean convert all other primit valu to java lang doubl if ret type void type cfw add byte code pop cfw add byte code return els if ret type boolean type cfw add invok byte code invokestat org mozilla javascript context to boolean ljava lang object z cfw add byte code ireturn els if ret type charact type charact ar repres as string in java script return the first charact first convert the valu to a string if possibl cfw add invok byte code invokestat org mozilla javascript context to string ljava lang object ljava lang string cfw add byte code iconst 0 cfw add invok byte code invokevirtu java lang string char at i c cfw add byte code ireturn els if ret type is primit cfw add invok byte code invokestat org mozilla javascript context to number ljava lang object d string type name ret type get name switch type name char at 0 case b case s case i cfw add byte code d2i cfw add byte code ireturn break case l cfw add byte code d2l cfw add byte code lreturn break case f cfw add byte code d2f cfw add byte code freturn break case d cfw add byte code dreturn break default throw new runtim except unexpect return type ret type to string els string ret type str ret type get name if call convert result cfw add load constant ret type str cfw add invok byte code invokestat java lang class for name ljava lang string ljava lang class cfw add invok byte code invokestat org mozilla javascript java adapt convert result ljava lang object ljava lang class ljava lang object now cast to return type cfw add byte code checkcast ret type str cfw add byte code areturn 
privat static void gener method class file writer cfw string gen name string method name class parm class return type string buffer sb new string buffer int param end append method signatur parm return type sb string method signatur sb to string cfw start method method name method signatur class file writer acc public prepar stack to call cal method push factori cfw add byte code aload 0 cfw add byte code getfield gen name factori lorg mozilla javascript context factori push self cfw add byte code aload 0 cfw add byte code getfield gen name self lorg mozilla javascript scriptabl push function cfw add byte code aload 0 cfw add byte code getfield gen name delege lorg mozilla javascript scriptabl cfw add push method name cfw add invok byte code invokestat org mozilla javascript java adapt get function lorg mozilla javascript scriptabl ljava lang string lorg mozilla javascript function push argument gener push wrap arg cfw parm parm length push bit to indic which paramet should be wrap if parm length 64 if it will be an issu then pass a static boolean arrai can be an option but for now us simpl bitmask throw context report runtim error0 java adapt can not subclass method with more then 64 argument long convert mask 0 for int i 0 i parm length i if parm i is primit convert mask 1 i cfw add push convert mask go through util method which creat a context to run the method in cfw add invok byte code invokestat org mozilla javascript java adapt call method lorg mozilla javascript context factori lorg mozilla javascript scriptabl lorg mozilla javascript function ljava lang object j ljava lang object gener return result cfw return type true cfw stop method short param end 
gener code to push type paramet onto the operand stack prior to a direct java method call privat static int gener push param class file writer cfw int param offset class param type if param type is primit cfw add aload param offset return 1 string type name param type get name switch type name char at 0 case z case b case c case s case i load an int valu convert to doubl cfw add iload param offset return 1 case l load a long convert to doubl cfw add lload param offset return 2 case f load a float convert to doubl cfw add fload param offset return 1 case d cfw add dload param offset return 2 throw kit code bug 
gener code to return a java type after call a java method that return the same type gener the appropri return bytecod privat static void gener pop result class file writer cfw class ret type if ret type is primit string type name ret type get name switch type name char at 0 case b case c case s case i case z cfw add byte code ireturn break case l cfw add byte code lreturn break case f cfw add byte code freturn break case d cfw add byte code dreturn break els cfw add byte code areturn 
gener a method call super method name which can be call from java script that is equival to call super method name from java eventu thi mai be support directli in java script privat static void gener super class file writer cfw string gen name string super name string method name string method signatur class parm class return type cfw start method super method name method signatur class file writer acc public push thi cfw add byte code aload 0 push the rest of the paramet int param offset 1 for int i 0 i parm length i param offset gener push param cfw param offset parm i call the superclass implement of the method cfw add invok byte code invokespeci super name method name method signatur now handl the return type appropri class ret type return type if ret type equal void type gener pop result cfw ret type els cfw add byte code return cfw stop method short param offset 1 
return a fulli qualifi method name concaten with it signatur privat static string get method signatur method method class arg type string buffer sb new string buffer append method signatur arg type method get return type sb return sb to string 
static int append method signatur class arg type class return type string buffer sb sb append int first local 1 arg type length includ thi for int i 0 i arg type length i class type arg type i append type string sb type if type long type type doubl type adjust for dubl slot first local sb append append type string sb return type return first local 
privat static string buffer append type string string buffer sb class type while type is arrai sb append type type get compon type if type is primit char type letter if type boolean type type letter z els if type long type type letter j els string type name type get name type letter charact to upper case type name char at 0 sb append type letter els sb append l sb append type get name replac sb append return sb 
static int get arg to convert class arg type int count 0 for int i 0 i arg type length i if arg type i is primit count if count 0 return null int arrai new int count count 0 for int i 0 i arg type length i if arg type i is primit arrai count i return arrai 
make glue object implement interfac cl that will call the suppli js function when call onli interfac were all method have the same signatur is support return the glue object or null if tt cl tt is not interfac or ha method with differ signatur static object creat context cx class cl callabl function if cl is interfac throw new illeg argument except scriptabl top scope script runtim get top call scope cx class cach cach class cach get top scope interfac adapt adapt adapt interfac adapt cach get interfac adapt cl context factori cf cx get factori if adapt null method method cl get method if method length 0 throw context report runtim error2 msg no empti interfac convers string valu of function cl get class get name boolean can call function fals can call function check class arg type method 0 get paramet type check that the rest of method ha the same signatur for int i 1 i method length i class types2 method i get paramet type if types2 length arg type length break can call function check for int j 0 j arg type length j if types2 j arg type j break can call function check can call function true if can call function throw context report runtim error2 msg no function interfac convers string valu of function cl get class get name adapt new interfac adapt cf cl cach cach interfac adapt cl adapt return vmbridg instanc new interfac proxi adapt proxi helper cf adapt function top scope 
privat interfac adapt context factori cf class cl thi proxi helper vmbridg instanc get interfac proxi helper cf new class cl 
public object invok context factori cf final object target final scriptabl top scope final method method final object arg context action action new context action public object run context cx return invok impl cx target top scope method arg return cf call action 
context action action new context action public object run context cx return invok impl cx target top scope method arg 
object invok impl context cx object target scriptabl top scope method method object arg int n arg null 0 arg length string method name method get name callabl function callabl target scriptabl thi obj top scope object jsarg new object n 1 jsarg n method get name if n 0 wrap factori wf cx get wrap factori for int i 0 i n i jsarg i wf wrap cx top scope arg i null object result function call cx top scope thi obj jsarg class java result type method get return type if java result type void type result null els result context js to java result java result type return result 
creat a new test file param name name of thi test file param file path full path to thi file public test file string name string file path super file path thi name name thi file path file path thi pass true thi complet fals thi start time 00 00 00 thi end time 00 00 00 thi reason thi program thi total case 0 thi case pass 0 thi case fail 0 thi case vector new vector thi except thi bugnumb 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string expect return string 
public test driver string arg thi arg arg if thread null thread new thread thi thread start 
public void run 
public void start thi file null thi output directori null thi opt level 0 thi debug level 0 thi runtim runtim get runtim thi free memori runtim free memori thi total memori runtim total memori if process option open log file output directori null test directori output directori write date to log hr output directori write log header output directori if file null file test directori list if test driver tinderbox write tinderbox header execut suit get suit file for int i 0 i suit size i get case test suit suit element at i for int i 0 i suit size i if test driver tinderbox write tinderbox suit name test suit suit element at i execut suit test suit suit element at i if test driver tinderbox write tinderbox suit result test suit suit element at i runtim gc stop 
close all log public void stop close log runtim gc long new free memori runtim free memori long new total memori runtim total memori string string tt free memori new free memori n br total memori new total memori n br free leak free memori new free memori n br total leak total memori new total memori n br tt p string p done if thread null thread stop thread null 
public void close log write date to log output directori get log output directori summari log name close log get log output directori suit log name close log get log output directori file log name close log get log output directori case log name close log if debug get log output directori debug log name close log 
get inform about the oper system public static string get system inform string system system get properti os name system get properti os arch system get properti os version return system 
return a file object with the specifi in the output directori public static test log get log file output string filenam enabl privileg test log log null string system get system inform string platform system 0 length 4 system 0 system 0 substr 0 4 string platform system 0 try file logdir new file output get absolut path output get absolut path end with file separ file separ platform system 1 system 2 get current date logdir mkdir log new test log logdir get absolut path file separ filenam termin catch except e p test driver get log threw e to string p platform platform p output output to string p filenam filenam to string p file separ file separ to string p system 0 system 0 p system 1 system 1 p system 2 system 2 p date get current date e print stack trace return log 
creat and write header to log file param output directori in which output file ar written public static void open log file file output enabl privileg test log summari log get log output summari log name test log file log get log output file log name test log suit log get log output suit log name test log case log get log output case log name if debug test log debug log get log output debug log name return 
public void write log header file output string header tabl tr th test driver td thi get class to string tr tr th output directori td output directori tr execut null tr th opt level td opt level tr tr th debug level td debug level tr tr th execut td execut tr tr th java version td system get properti java vendor system get properti java version tr tr th test file directori td test directori tr tr th helper function td helper function tr tr th free memori td free memori tr tr th total jvm memori td total memori tr tabl get log output directori suit log name write line header get log output directori case log name write line header get log output directori file log name write line header get log output directori summari log name write line header get log output directori summari log name write line tabl width 100 tr bg color ffffcc th rowspan 2 width 15 suit th rowspan 2 width 20 file th rowspan 2 width 10 case th colspan 2 width 20 pass th colspan 2 width 20 fail th rowspan 2 width 15 result tr tr th width 10 th width 10 th width 10 th width 10 tr tabl return 
for each subdirectori of the main test directori creat a new test suit object public vector get suit string file vector suit new vector for int i 0 i file length i string filenam strip doubl slash test directori file separ file i file fileobject new file filenam if fileobject is directori test suit s new test suit fileobject get name filenam suit add element s return suit 
if two slash in a row ar found on slash is strip out mac client ha troubl if we don t do thi xxx thi doesn t work and need to be fix public static string strip doubl slash string string string buffer buffer new string buffer for int letter 0 letter string length letter char current char string char at letter if current char file separ char buffer append current char els while string char at letter file separ char onli add on slash buffer append file separ char letter if new charact string char at letter to string equal if new charact string char at letter 1 to string equal onli got on leav it alon buffer append string char at letter els buffer append string char at letter return buffer to string 
for each test file in the suit directori creat a test file object public void get case test suit suit enabl privileg file dir new file suit file path string file dir list for int i 0 i file length i test file item new test file file i suit file path file separ file i if item is file item get name to lower case end with get suffix item is directori suit add element item p item 
subclass should overrid thi method to iter through all test file in the test suit creat a new test environ run the test and close the test environ for exampl see com netscap javascript qa driver rhino drv and see com netscap javascript qa driver ref drv public synchron void execut suit test suit suit 
if the environ us a secur manag and requir privileg to access system properti overrid thi method to enabl privileg the default method doe noth public static void enabl privileg 
write the suit result to the tinderbox log xxx need machin branch start time end time public void write tinderbox header string execut string dot line string product execut null ns js rhino ns js ref string os info system get properti os name system get properti os arch system get properti os version string java info system get properti java vendor system get properti java version creat the log string system out println dot line system out println product product system out println machin machin system out println oper system os info system out println java version java info system out println free memori free memori system out println total jvm memori total memori system out println test driver thi get class get name system out println output directori output directori system out println path to execut execut if product equal ns js rhino system out println optim level opt level system out println debug level debug level system out println test directori test directori system out println dot line 
public void write tinderbox suit name test suit suit system out println suit suit name 
public void write tinderbox suit result test suit suit string dot line system out println result suit pass pass fail if suit pass system out println fail file for int i 0 i suit size i test file file test file suit element at i if file pass system out println file name file bugnumb equal http scopu mcom com bugsplat show bug cgi id file bugnumb system out println dot line 
write an html format string to suit log public static void write suit result test suit suit file output if suit size 0 return string buffer buffer tt suit pass font color 00dd00 pass font font color dd0000 fail font nbsp a href suit name suit name a b if suit pass for int i 0 i suit size i test file file test file suit element at i if file pass buffer nbsp a href case html suit name file name file name a if file bugnumb equal buffer nbsp a href http scopu mcom com bugsplat show bug cgi id file bugnumb file bugnumb a buffer tt br get log output suit log name write line buffer to string 
write an html format string to the summari log that look like thi pre suit number of number of pass fail result name file case pre public static void write suit summari test suit suit file output if suit size 0 return string buffer p total suit total case p pass suit case pass p fail suit case fail doubl percent pass math round doubl suit case pass doubl suit total case 10000 100 doubl percent fail math round doubl suit case fail doubl suit total case 10000 100 buffer tabl width 100 buffer th bgcolor ffffcc width 15 suit name buffer th width 15 bgcolor ffffcc suit size th width 10 bgcolor ffffcc suit total case th width 10 bgcolor ffffcc suit case pass th width 10 bgcolor ffffcc percent pass th width 10 bgcolor ffffcc suit case fail th width 10 bgcolor ffffcc percent fail th width 15 bgcolor ffffcc suit pass true font color 006600 pass font font color 990000 fail font tr tabl for int i 0 i suit size i test file file test file suit element at i doubl p pass 0 doubl p fail 0 if file total case 0 p pass math round doubl file case pass doubl file total case 10000 100 p fail math round doubl file case fail doubl file total case 10000 100 buffer tabl width 100 tr td width 15 td width 15 a href case html suit name file name file name a td width 10 file total case td width 10 bg color ccffcc file case pass td width 10 bg color ccffcc p pass td width 10 bg color ffcccc file case fail td width 10 bg color ffcccc p fail td width 15 file pass true font color 006600 pass font font color 990000 fail font file reason equal file reason file except equal br file except tr tabl get log output summari log name write line buffer to string 
write the result of the current file to the file log if the file threw an except print the except public static void write file result test file file test suit suit file output string suitenam suit null suit name if file pass string buffer buffer tt font color file pass 00dd00 pass font nbsp dd0000 fail font nbsp a href case html suitenam file name suitenam file name a file except n if file bugnumb equal buffer nbsp a href http scopu mcom com bugsplat show bug cgi id file bugnumb file bugnumb a get log output file log name write line buffer to string 
read the content of a file into a string public static string read file string file path file js file new file file path int length new long js file length int valu byte b new byte length string buffer content new string buffer try file input stream fi new file input stream js file int read fi read b content append new string b catch except e p e to string return content to string 
test case manag system tcm requir the follow inform machin id pass or fail test file name beaker test file name date run in mm dd yy start time hh mm ss end time hh mm ss expect result string quit often null actual result string reason for failur test can provid thi inform we expect it to be in an object call test case with the follow structur pre function test case pass name expect actual reason thi pass pass thi name descript of the test case thi expect the expect result thi actual the actual result thi reason reason for failur pre we will gener machin id pass fail date run start time end time if tcm fals omit unnecessari log id public static void write case result test file file test suit suit file output suit total case file total case string system get system inform string buffer for int i 0 i file case vector size i test case tcase test case file case vector element at i format and write test case result to case log if tcase pass equal true if file pass buffer a name suit name file name buffer tt buffer system 0 if tcase pass equal true if file pass buffer pass suit case pass 1 file case pass 1 els if file pass buffer fail suit case fail 1 file case fail 1 if tcm buffer tcase name tcase descript beaker tcase name tcase descript get current date file start time file end time tcase expect tcase actual tcase reason n els buffer tcase name tcase descript tcase expect tcase actual tcase reason n if tcase pass equal true buffer tt br n get log output case log name write line buffer to string els buffer 
short version of write test case result to the case log us by live connec test subclass param case vector of testcas whose result should be written to the case log live connect test send a vector of fail test case object param classnam name of the live connect test class param output directori in which output is written see com netscap javascript qa liveconnect live connect test write result to case log public static void write case result test file file string classnam file output string system get system inform string buffer for int i 0 i file case vector size i test case tcase test case file case vector element at i if tcase pass equal true buffer pass els buffer tt buffer system 0 buffer fail buffer tcase name tcase descript tcase expect tcase actual tcase reason n buffer tt br n get log output case log name write line buffer to string 
write system inform and current date to the summari log file log and suit log xxx need to fix thi to output all test inform public static void write date to log string separ file output date todai new date string system get system inform long new free memori runtim free memori long new total memori runtim total memori string string tt free memori new free memori n br total memori new total memori n br free leak free memori new free memori n br total leak total memori new total memori n br tt separ system 0 system 1 system 2 todai to string get log output summari log name write line string get log output file log name write line string get log output suit log name write line string if tcm get log output case log name write line string 
conveni method public static void p string s if test driver tinderbox system out println s 
public static void debug string s if debug test driver tinderbox system err println s 
from the current date return a string in the format dd mm yy where is specifi by the separ argument public static string get current date string separ date todai new date string date todai get date 10 0 string valu of todai get date string valu of todai get date string month todai get month 1 10 0 string valu of todai get month 1 string valu of todai get month 1 string year string valu of todai get year return month separ date separ year 
from the current time return a string in the format hh mm ss public static string get current time date now new date string hour now get hour 10 0 string valu of now get hour string valu of now get hour string minut now get minut 10 0 string valu of now get minut string valu of now get minut string second now get second 10 0 string valu of now get second string valu of now get second string time hour minut second return time 
return time public string get suffix return suffix 
return suffix public void set suffix string s suffix s 
temporari stop thi thread for 5 second public boolean sleep int ms try thread sleep 5000 catch except e p sleep fail e return fals return true 
process option should pars the arg object return true if the driver should continu return fals if the driver should not continu public boolean process option return fals 
return fals public static void main string arg test driver d new test driver arg d start 
public class jsobject 001 extend live connect test public jsobject 001 super 
public static void main string arg jsobject 001 test new jsobject 001 test start 
public void execut test get doubl na n get doubl infin get jsobject pars int get jsobject pars float get jsobject eval get jsobject escap get jsobject unescap get jsobject is na n get jsobject is finit get jsobject object get jsobject function get jsobject arrai get jsobject string get jsobject boolean get jsobject number get jsobject date get jsobject math 
try to get a properti of the java script global object the type of thi properti should be a java lang doubl if it is not the test will fail with a java lang class cast except param properti name of the java script properti to get public void get doubl string properti object jsobject null string except null string identifi thi get class to string string descript object jsobject global get member properti jsobject instanceof java lang doubl try jsobject global get member properti catch except e except except get properti e to string system err println except string expect true string actual jsobject instanceof java lang doubl add test case descript expect actual except 
try to get a properti of the java script global object the type of thi properti should be a netscap javascript jsobject if it is not the test will fail with a java lang class cast except param properti name of the java script properti to get public void get jsobject string properti object jsobject null string except null string identifi thi get class to string string descript object jsobject global get member properti jsobject instanceof jsobject try jsobject global get member properti catch except e except except get properti e to string system err println except string expect true string actual jsobject instanceof jsobject add test case descript expect actual except 
public class tool error report implement error report public tool error report boolean report warn thi report warn system err 
public tool error report boolean report warn print stream err thi report warn report warn thi err err 
look up the messag correspond to messag id in the org mozilla javascript tool shell resourc messag properti file for internation support public static string get messag string messag id return get messag messag id object null 
public static string get messag string messag id string argument object arg argument return get messag messag id arg 
public static string get messag string messag id object arg1 object arg2 object arg arg1 arg2 return get messag messag id arg 
public static string get messag string messag id object arg context cx context get current context local local cx null local get default cx get local resourc bundl doe cach resourc bundl rb resourc bundl get bundl org mozilla javascript tool resourc messag local string format string try format string rb get string messag id catch java util miss resourc except mre throw new runtim except no messag resourc found for messag properti messag id if arg null return format string els messag format formatt new messag format format string return formatt format arg 
privat static string get except messag rhino except ex string msg if ex instanceof java script except msg get messag msg uncaught jsexcept ex detail els if ex instanceof ecma error msg get messag msg uncaught ecma error ex detail els msg ex to string return msg 
public void warn string messag string sourc name int line string line sourc int line offset if report warn return report error messag messag sourc name line line sourc line offset true 
public void error string messag string sourc name int line string line sourc int line offset ha report error flag true report error messag messag sourc name line line sourc line offset fals 
public evalu except runtim error string messag string sourc name int line string line sourc int line offset error messag sourc name line line sourc line offset return new evalu except messag sourc name line line sourc line offset 
public boolean ha report error return ha report error flag 
public boolean is report warn return thi report warn 
public void set is report warn boolean report warn thi report warn report warn 
public static void report except error report er rhino except ex if er instanceof tool error report tool error report er report except ex els string msg get except messag ex er error msg ex sourc name ex line number ex line sourc ex column number 
public void report except rhino except ex if ex instanceof wrap except wrap except we wrap except ex we print stack trace err els string msg get except messag ex report error messag msg ex sourc name ex line number ex line sourc ex column number fals 
privat void report error messag string messag string sourc name int line string line sourc int line offset boolean just warn if line 0 string line str string valu of line if sourc name null object arg sourc name line str messag messag get messag msg format3 arg els object arg line str messag messag get messag msg format2 arg els object arg messag messag get messag msg format1 arg if just warn messag get messag msg warn messag err println messag prefix messag if null line sourc err println messag prefix line sourc err println messag prefix build indic line offset 
privat string build indic int offset string buffer sb new string buffer for int i 0 i offset 1 i sb append sb append return sb to string 
public nav drv super null system out println constructor set suffix html 
public static void main string arg privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read system out println main nav drv d new nav drv d start 
public boolean process option system out println nav drv process option privileg manag enabl privileg univers file access privileg manag enabl privileg univers properti read window jsobject jsobject get window thi get paramet string d get paramet directori string o get paramet output http path get paramet http path test directori new file d output directori new file o system out println http path http path system out println directori test directori system out println output output directori if test directori is directori system err println error test directori get absolut path is not a directori return fals if output directori is directori system err println error output directori get absolut path is not a directori return fals return true 
public static void open log file file o privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read test driver open log file o 
public vector get suit string file privileg manag enabl privileg univers file access privileg manag enabl privileg univers properti read privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write return super get suit file 
public void get case test suit suit privileg manag enabl privileg univers file access privileg manag enabl privileg univers properti read privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write super get case suit 
public static test log get log file output string filenam privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read return test driver get log output filenam 
public void write log header file output privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read super write log header output 
public static void write suit result test suit suit file output privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read test driver write suit result suit output 
public static void write suit summari test suit suit file output privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read test driver write suit summari suit output 
public static void write file result test file file test suit suit file output privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read test driver write file result file suit output 
public static void write case result test file file test suit suit file output privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read test driver write case result file suit output 
public static void write date to log string separ file output privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read test driver write date to log separ output 
public synchron void execut suit test suit suit privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read nav env context test file file for int i 0 i suit size i synchron suit file test file suit element at i context new nav env file suit thi context run test write file result file suit output directori write case result file suit output directori context close context null if file pass suit pass fals write suit result suit output directori write suit summari suit output directori 
public void stop privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read super stop 
public void start privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read super start 
public class run script3 public static void main string arg context cx context enter try scriptabl scope cx init standard object collect the argument into a singl string string s for int i 0 i arg length i s arg i now evalu the string we ve colect we ll ignor the result cx evalu string scope s cmd 1 null print the valu of variabl x object x scope get x scope if x scriptabl not found system out println x is not defin els system out println x context to string x call function f my arg and print it result object f obj scope get f scope if f obj instanceof function system out println f is undefin or not a function els object function arg my arg function f function f obj object result f call cx scope scope function arg string report f my arg context to string result system out println report final context exit 
java member scriptabl scope class cl thi member new hashtabl 23 thi static member new hashtabl 7 thi cl cl reflect scope 
boolean ha string name boolean is static hashtabl ht is static static member member object obj ht get name if obj null return true els return null find explicit function name is static 
object get scriptabl scope string name object java object boolean is static hashtabl ht is static static member member object member ht get name if is static member null try to get static member from instanc lc3 member static member get name if member null member thi get explicit function scope name java object is static if member null return scriptabl not found if member instanceof scriptabl return member context cx context get context object rval class type try if member instanceof bean properti bean properti bp bean properti member if bp getter null return scriptabl not found rval bp getter invok java object context empti arg type bp getter method get return type els field field field member rval field get is static null java object type field get type catch except ex throw context throw as script runtim ex ex need to wrap the object befor we return it scope scriptabl object get top level scope scope return cx get wrap factori wrap cx scope rval type 
void put scriptabl scope string name object java object object valu boolean is static hashtabl ht is static static member member object member ht get name if is static member null try to get static member from instanc lc3 member static member get name if member null throw report member not found name if member instanceof field and method field and method fam field and method ht get name member fam field is thi a bean properti set if member instanceof bean properti bean properti bp bean properti member if bp setter null throw report member not found name if there s onli on setter or if the valu is null us the main setter otherwis let the nativ java method decid which setter to us if bp setter null valu null class set type bp setter arg type 0 object arg context js to java valu set type try bp setter invok java object arg catch except ex throw context throw as script runtim ex ex els object arg valu bp setter call context get context scriptabl object get top level scope scope scope arg els if member instanceof field string str member null msg java intern privat msg java method assign throw context report runtim error1 str name field field field member object java valu context js to java valu field get type try field set java object java valu catch illeg access except access ex throw new runtim except unexpect illeg access except access java field catch illeg argument except arg ex throw context report runtim error3 msg java intern field type valu get class get name field java object get class get name 
object get id boolean is static hashtabl ht is static static member member int len ht size object result new object len enumer kei ht kei for int i 0 i len i result i kei next element return result 
static string java signatur class type if type is arrai return type get name els int arrai dimens 0 do arrai dimens type type get compon type while type is arrai string name type get name string suffix if arrai dimens 1 return name concat suffix els int length name length arrai dimens suffix length string buffer sb new string buffer length sb append name while arrai dimens 0 arrai dimens sb append suffix return sb to string 
static string live connect signatur class arg type int n arg type length if n 0 return string buffer sb new string buffer sb append for int i 0 i n i if i 0 sb append sb append java signatur arg type i sb append return sb to string 
privat member box find explicit function string name boolean is static int sig start name index of if sig start 0 return null hashtabl ht is static static member member member box method or ctor null boolean is ctor is static sig start 0 if is ctor explicit request for an overload constructor method or ctor ctor els explicit request for an overload method string true name name substr 0 sig start object obj ht get true name if is static obj null try to get static member from instanc lc3 obj static member get true name if obj instanceof nativ java method nativ java method njm nativ java method obj method or ctor njm method if method or ctor null for int i 0 i method or ctor length i class type method or ctor i arg type string sig live connect signatur type if sig start sig length name length name region match sig start sig 0 sig length return method or ctor i return null 
privat object get explicit function scriptabl scope string name object java object boolean is static hashtabl ht is static static member member object member null member box method or ctor find explicit function name is static if method or ctor null scriptabl prototyp scriptabl object get function prototyp scope if method or ctor is ctor nativ java constructor fun new nativ java constructor method or ctor fun set prototyp prototyp member fun ht put name fun els string true name method or ctor get name member ht get true name if member instanceof nativ java method nativ java method member method length 1 nativ java method fun new nativ java method method or ctor name fun set prototyp prototyp ht put name fun member fun return member 
privat void reflect scriptabl scope we reflect method first becaus we want overload field method name to be alloc to the nativ java method befor the field get in the wai method method cl get method for int i 0 i method length i method method method i int mod method get modifi if modifi is public mod continu boolean is static modifi is static mod hashtabl ht is static static member member string name method get name object valu ht get name if valu null ht put name method els obj arrai overload method if valu instanceof obj arrai overload method obj arrai valu els if valu instanceof method kit code bug valu should be instanc of method as at thi stage static member and member can onli contain method overload method new obj arrai overload method add valu ht put name overload method overload method add method replac method instanc by wrap nativ java method object first in static member and then in member for int tabl cursor 0 tabl cursor 2 tabl cursor boolean is static tabl cursor 0 hashtabl ht is static static member member enumer e ht kei while e ha more element string name string e next element member box method box object valu ht get name if valu instanceof method method box new member box 1 method box 0 new member box method valu els obj arrai overload method obj arrai valu int n overload method size if n 2 kit code bug method box new member box n for int i 0 i n i method method method overload method get i method box i new member box method nativ java method fun new nativ java method method box if scope null script runtim set function proto and parent fun scope ht put name fun reflect field field field cl get field for int i 0 i field length i field field field i int mod field get modifi if modifi is public mod continu boolean is static modifi is static mod hashtabl ht is static static member member string name field get name object member ht get name if member null ht put name field els if member instanceof nativ java method nativ java method method nativ java method member field and method fam new field and method scope method method field hashtabl fmht is static static field and method field and method if fmht null fmht new hashtabl 4 if is static static field and method fmht els field and method fmht fmht put name fam ht put name fam els if member instanceof field field old field field member if thi newli reflect field shadow an inherit field then replac it otherwis sinc access to the field would be ambigu from java no field should be reflect for now the first field found win unless anoth field explicitli shadow it if old field get declar class is assign from field get declar class ht put name field els unknown member type kit code bug creat bean propeti from correspond get set method first for static member and then for instanc member for int tabl cursor 0 tabl cursor 2 tabl cursor boolean is static tabl cursor 0 hashtabl ht is static static member member hashtabl to add new hashtabl now for each member make bean properti for enumer e ht kei e ha more element is thi a getter string name string e next element boolean member is get method name start with get boolean member is set method name start with set boolean member is is method name start with is if member is get method member is is method member is set method doubl check name compon string name compon name substr member is is method 2 3 if name compon length 0 continu make the bean properti name string bean properti name name compon char ch0 name compon char at 0 if charact is upper case ch0 if name compon length 1 bean properti name name compon to lower case els char ch1 name compon char at 1 if charact is upper case ch1 bean properti name charact to lower case ch0 name compon substr 1 if we alreadi have a member by thi name don t do thi properti if ht contain kei bean properti name to add contain kei bean properti name continu find the getter method or if there is none the is method member box getter null string getter name get concat name compon string is name is concat name compon getter find getter is static ht getter name if there wa no valid getter check for an is method if getter null getter find getter is static ht is name setter member box setter null nativ java method setter null string setter name set concat name compon if ht contain kei setter name is thi valu a method object member ht get setter name if member instanceof nativ java method nativ java method njm set nativ java method member if getter null we have a getter now do we have a match setter class type getter method get return type setter extract set method type njm set method is static els no getter find ani set method setter extract set method njm set method is static if njm set method length 1 setter njm set make the properti bean properti bp new bean properti getter setter setter to add put bean properti name bp add the new bean properti for enumer e to add kei e ha more element object kei e next element object valu to add get kei ht put kei valu reflect constructor constructor constructor cl get constructor ctor new member box constructor length for int i 0 i constructor length i ctor i new member box constructor i 
privat member box find getter boolean is static hashtabl ht string getter name if ht contain kei getter name check that the getter is a method object member ht get getter name if member instanceof nativ java method nativ java method njm get nativ java method member return extract get method njm get method is static return null 
privat static member box extract get method member box method boolean is static inspect the list of all member box for the onli on have no paramet for int method idx 0 method idx method length method idx member box method method method idx doe getter method have an empti paramet list with a return valu eg a get someth or is someth if method arg type length 0 is static method is static class type method method get return type if type void type return method break return null 
privat static member box extract set method class type member box method boolean is static note it mai be prefer to allow nativ java method find function to find the appropri setter unfortun it requir an instanc of the target arg to determin that make two pass on to find a method with direct type assign and on to find a widen convers for int pass 1 pass 2 pass for int i 0 i method length i member box method method i if is static method is static if method method get return type void type class param method arg type if param length 1 if pass 1 if param 0 type return method els if pass 2 kit code bug if param 0 is assign from type return method return null 
privat static member box extract set method member box method boolean is static for int i 0 i method length i member box method method i if is static method is static if method method get return type void type if method arg type length 1 return method return null 
hashtabl get field and method object scriptabl scope object java object boolean is static hashtabl ht is static static field and method field and method if ht null return null int len ht size hashtabl result new hashtabl len enumer e ht element while len 0 field and method fam field and method e next element field and method fam new new field and method scope fam method fam field fam new java object java object result put fam field get name fam new return result 
static java member lookup class scriptabl scope class dynam type class static type java member member class cach cach class cach get scope hashtabl ct cach class tabl class cl dynam type for member java member ct get cl if member null return member try member new java member cach scope cl break catch secur except e reflect mai fail for object that ar in a restrict access packag e g sun if we get a secur except try again with the static type if it is interfac otherwis try superclass if static type null static type is interfac cl static type static type null try static type onli onc els class parent cl get superclass if parent null if cl is interfac last resort after fail static type interfac parent script runtim object class els throw e cl parent if cach is cach enabl ct put cl member return member 
runtim except report member not found string member name return context report runtim error2 msg java member not found cl get name member name 
bean properti member box getter member box setter nativ java method setter thi getter getter thi setter setter thi setter setter 
field and method scriptabl scope member box method field field super method thi field field set parent scope scope set prototyp scriptabl object get function prototyp scope 
public object get default valu class hint if hint script runtim function class return thi object rval class type try rval field get java object type field get type catch illeg access except acc ex throw context report runtim error1 msg java intern privat field get name context cx context get context rval cx get wrap factori wrap cx thi rval type if rval instanceof scriptabl rval scriptabl rval get default valu hint return rval 
protect boolean ha featur context cx int featur index switch featur index case context featur strict var case context featur strict eval return strict mode return super ha featur cx featur index 
protect void on context creat context cx cx set languag version languag version cx set optim level optim level if error report null cx set error report error report super on context creat cx 
public void set strict mode boolean flag check not seal thi strict mode flag 
public void set languag version int version context check languag version version check not seal thi languag version version 
public void set optim level int optim level context check optim level optim level check not seal thi optim level optim level 
public void set error report error report error report if error report null throw new illeg argument except thi error report error report 
replac item int begin int end string text thi begin begin thi end end thi replac text 
public char get buffer return buffer 
public void read data reader r throw ioexcept int capac buffer length int offset 0 for int n read r read buffer offset capac offset if n read 0 break offset n read if capac offset capac 2 char tmp new char capac system arraycopi buffer 0 tmp 0 offset buffer tmp buffer end offset 
public void write initi data writer w throw ioexcept w write buffer 0 buffer end 
public void write data writer w throw ioexcept int offset 0 for replac item x first replac x null x x next int befor replac x begin offset if befor replac 0 w write buffer offset befor replac w write x replac offset x end int tail buffer end offset if tail 0 w write buffer offset tail 
public boolean wa modifi return first replac null 
public boolean set replac int begin int end string text if equal text buffer begin end return fals replac item item new replac item begin end text if first replac null first replac last replac item els if begin first replac begin item next first replac first replac item els replac item cursor first replac replac item next cursor next while next null if begin next begin item next next cursor next item break cursor next next next next if next null last replac next item return true 
public int get line number return line number 
public int get line number return line number public int get line begin return line begin 
public int get line begin return line begin public int get line end return line end 
public int get line end return line end public void start line loop line number 0 line begin line end next line start 0 
public boolean next line if next line start buffer end line number 0 return fals int i int c 0 for i next line start i buffer end i c buffer i if c n c r break line begin next line start line end i if i buffer end next line start i els if c r i 1 buffer end buffer i 1 n next line start i 2 els next line start i 1 line number return true 
privat static boolean equal string str char arrai int begin int end if str length end begin for int i begin j 0 i end i j if arrai i str char at j return fals return true return fals 
privat namespac helper xmllib impl lib thi lib lib insert the default namespac prefix to uri put set prefix new hash set prefix add uri to prefix put prefix 
declar a new namespac param prefix param uri param declar privat void declar namespac string prefix string uri obj arrai declar set prefix set uri to prefix get uri if prefix null prefix new hash set uri to prefix put uri prefix if prefix contain prefix string old uri string prefix to uri get prefix add the new map prefix add prefix prefix to uri put prefix uri if declar null declar add new namespac lib prefix uri if old uri null updat the exist map prefix set uri to prefix get old uri prefix remov prefix 
updat the intern state of thi namespac helper to reflect the exist of the xml token point to by the cursor privat void process name xml cursor cursor obj arrai declar javax xml namespac qname qname cursor get name string uri qname get namespac uri set prefix set uri to prefix get uri if prefix null prefix size 0 undeclar add uri if declar null declar add new namespac lib uri 
updat the intern state of thi namespac helper with the namespac inform of the element point to by the cursor privat void updat xml cursor cursor obj arrai declar process the namespac declar cursor push while cursor to next token is ani attr if cursor is namespac javax xml namespac qname name cursor get name string prefix name get local part string uri name get namespac uri declar namespac prefix uri declar cursor pop process the element process name cursor declar process the attribut cursor push boolean ha next cursor to first attribut while ha next process name cursor declar ha next cursor to next attribut cursor pop 
return object arrai of namespac object in scope at the cursor public static object in scope namespac xmllib impl lib xml cursor cursor obj arrai namespac new obj arrai namespac helper helper new namespac helper lib cursor push int depth 0 while cursor ha prev token if cursor is contain cursor push depth cursor to parent for int i 0 i depth i cursor pop helper updat cursor null iter i helper prefix to uri entri set iter while i ha next map entri entri map entri i next namespac ns new namespac lib string entri get kei string entri get valu namespac add ns i helper undeclar iter while i ha next namespac ns new namespac lib string i next namespac add ns cursor pop return namespac to arrai 
static namespac get namespac xmllib impl lib xml cursor cursor object in scope namespac string uri string prefix if cursor is procinst uri prefix els javax xml namespac qname qname cursor get name uri qname get namespac uri prefix qname get prefix if in scope namespac null return new namespac lib prefix uri namespac result null for int i 0 i in scope namespac length i namespac ns namespac in scope namespac i if ns null continu string ns uri ns uri if ns uri equal uri if prefix equal ns prefix result ns break if result null result prefix null ns prefix null result ns if result null result new namespac lib prefix uri return result 
return list of namespac object that ar declar in the contain point to by the cursor public static object namespac declar xmllib impl lib xml cursor cursor obj arrai declar new obj arrai namespac helper helper new namespac helper lib cursor push int depth 0 while cursor ha prev token if cursor is contain cursor push depth cursor to parent for int i 0 i depth 1 i cursor pop helper updat cursor null if depth 0 cursor pop helper updat cursor declar cursor pop return declar to arrai 
return prefix to uri map of all namespac in scope at the cursor public static map get all namespac xmllib impl lib xml cursor cursor namespac helper helper new namespac helper lib cursor push int depth 0 while cursor ha prev token if cursor is contain cursor push depth cursor to parent for int i 0 i depth i cursor pop helper updat cursor null cursor pop return helper prefix to uri 
public static void get namespac xml cursor cursor map prefix to uri cursor push while cursor to next token is ani attr if cursor is namespac javax xml namespac qname name cursor get name string prefix name get local part string uri name get namespac uri prefix to uri put prefix uri cursor pop 
public static void remov namespac xml cursor cursor string prefix cursor push while cursor to next token is ani attr if cursor is namespac javax xml namespac qname name cursor get name if name get local part equal prefix cursor remov xml break cursor pop 
main entri point process argument as would a normal java program then set up the execut environ and begin to compil script public static void main string arg main main new main arg main process option arg if arg null if main print help system out println tool error report get messag msg jsc usag main class get name system exit 0 system exit 1 if main report ha report error main process sourc arg 
public main report new tool error report true compil env new compil environ compil env set error report report compil new class compil compil env 
pars argument public string process option string arg target packag default to no packag compil env set gener debug info fals default to no symbol for int i 0 i arg length i string arg arg i if arg start with int tail arg length i if target name null tail 1 add error msg multipl js to file target name return null string result new string tail for int j 0 j tail j result j arg i j return result if arg equal help arg equal h arg equal help print help true return null try if arg equal version i arg length int version integ pars int arg i compil env set languag version version continu if arg equal opt arg equal o i arg length int opt level integ pars int arg i compil env set optim level opt level continu catch number format except e bad usag arg i return null if arg equal nosourc compil env set gener sourc fals continu if arg equal debug arg equal g compil env set gener debug info true continu if arg equal main method class i arg length compil set main method class arg i continu if arg equal o i arg length string name arg i int end name length if end 0 charact is java identifi start name char at 0 add error msg invalid classfil name name continu for int j 1 j end j char c name char at j if charact is java identifi part c if c check if it is the dot in class if j end 6 name end with class name name substr 0 j break add error msg invalid classfil name name break target name name continu if arg equal packag i arg length string pkg arg i int end pkg length for int j 0 j end j char c pkg char at j if charact is java identifi start c for j j end j c pkg char at j if charact is java identifi part c break if j end break if c j end 1 continu add error msg packag name target packag return null target packag pkg continu if arg equal extend i arg length string target extend arg i class super class try super class class for name target extend catch class not found except e throw new error e to string todo better error compil set target extend super class continu if arg equal implement i arg length todo allow for multipl comma separ interfac string target implement arg i string token st new string token target implement vector v new vector while st ha more token string class name st next token try v add element class for name class name catch class not found except e throw new error e to string todo better error class implement class new class v size v copi into implement class compil set target implement implement class continu if arg equal d i arg length destin dir arg i continu bad usag arg return null no file name p tool error report get messag msg no file return null 
print a usag messag privat static void bad usag string s system err println tool error report get messag msg jsc bad usag main class get name s 
compil java script sourc public void process sourc string filenam for int i 0 i filenam length i string filenam filenam i if filenam end with js add error msg extens not js filenam return file f new file filenam string sourc read sourc f if sourc null return string main class name target name if main class name null string name f get name string noj name substr 0 name length 3 main class name get class name noj if target packag length 0 main class name target packag main class name object compil compil compil to class file sourc filenam 1 main class name if compil null compil length 0 return file target top dir null if destin dir null target top dir new file destin dir els string parent f get parent if parent null target top dir new file parent for int j 0 j compil length j 2 string class name string compil j byte byte byte compil j 1 file outfil get output file target top dir class name try file output stream os new file output stream outfil try os write byte final os close catch ioexcept ioe add format error ioe to string 
privat string read sourc file f if f exist add error msg jsfile not found f get absolut path return null try reader in new file reader f try return kit read reader in final in close catch file not found except ex add error msg couldnt open f get absolut path catch ioexcept ioe add format error ioe to string return null 
privat file get output file file parent dir string class name string path class name replac file separ char path path concat class file f new file parent dir path string dir path f get parent if dir path null file dir new file dir path if dir exist dir mkdir return f 
verifi that class file name ar legal java identifi substitut illeg charact with underscor and prepend the name with an underscor if the file name doe not begin with a java letter string get class name string name char s new char name length 1 char c int j 0 if charact is java identifi start name char at 0 s j for int i 0 i name length i j c name char at i if charact is java identifi part c s j c els s j return new string s trim 
privat static void p string s system out println s 
privat void add error string messag id string arg string msg if arg null msg tool error report get messag messag id els msg tool error report get messag messag id arg add format error msg 
privat void add format error string messag report error messag null 1 null 1 
public string float float public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl object 
public string ambigu doubl arg return doubl 
public string ambigu char arg return char 
public string ambigu object arg return object 
public string expect return object 
public string float float public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl object 
public string ambigu doubl arg return doubl 
public string float float public string ambigu float arg return float 
public string ambigu doubl arg return doubl 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu string arg return string 
public string ambigu object arg return object 
public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
return boolean public string expect return boolean 
public object compil compil environ compil env script or fn node tree string encod sourc boolean return function int serial synchron global lock serial global serial class counter string main class name org mozilla javascript gen c serial byte main class byte compil to class file compil env main class name tree encod sourc return function return new object main class name main class byte 
public script creat script object object bytecod object static secur domain class cl defin class bytecod static secur domain script script try script script cl new instanc catch except ex throw new runtim except unabl to instanti compil class ex to string return script 
public function creat function object context cx scriptabl scope object bytecod object static secur domain class cl defin class bytecod static secur domain nativ function f try constructor ctor cl get constructor 0 object init arg scope cx new integ 0 f nativ function ctor new instanc init arg catch except ex throw new runtim except unabl to instanti compil class ex to string return f 
privat class defin class object bytecod object static secur domain object name byte pair object bytecod string class name string name byte pair 0 byte class byte byte name byte pair 1 the gener class in thi case refer onli to rhino class which must be access through thi class loader class loader rhino loader get class get class loader gener class loader loader loader secur control creat loader rhino loader static secur domain except e try class cl loader defin class class name class byte loader link class cl return cl catch secur except x e x catch illeg argument except x e x throw new runtim except malform optim packag e 
byte compil to class file compil environ compil env string main class name script or fn node script or fn string encod sourc boolean return function thi compil env compil env transform script or fn if token print tree system out println script or fn to string tree script or fn if return function script or fn script or fn get function node 0 init script or fn node data script or fn thi main class name main class name main class signatur class file writer class name to signatur main class name return gener code encod sourc 
privat void transform script or fn node tree init opt function r tree int opt level compil env get optim level hashtabl possibl direct call null if opt level 0 collect all of the contain function into a hashtabl so that the call optim can access the class name paramet count for ani call it encount if tree get type token script int function count tree get function count for int i 0 i function count i opt function node ofn opt function node get tree i if ofn fnode get function type function node function statement string name ofn fnode get function name if name length 0 if possibl direct call null possibl direct call new hashtabl possibl direct call put name ofn if possibl direct call null direct call target new obj arrai opt transform ot new opt transform possibl direct call direct call target ot transform tree if opt level 0 new optim optim tree opt level 
privat static void init opt function r script or fn node script or fn for int i 0 n script or fn get function count i n i function node fn script or fn get function node i new opt function node fn init opt function r fn 
privat void init script or fn node data script or fn node script or fn obj arrai x new obj arrai collect script or fn node r script or fn x int count x size script or fn node new script or fn node count x to arrai script or fn node script or fn index new obj to int map count for int i 0 i count i script or fn index put script or fn node i i 
privat static void collect script or fn node r script or fn node n obj arrai x x add n int nest count n get function count for int i 0 i nest count i collect script or fn node r n get function node i x 
privat byte gener code string encod sourc boolean ha script script or fn node 0 get type token script boolean ha function script or fn node length 1 ha script string sourc file null if compil env is gener debug info sourc file script or fn node 0 get sourc name class file writer cfw new class file writer main class name super class name sourc file cfw add field id field name i class file writer acc privat cfw add field direct call parent field main class signatur class file writer acc privat cfw add field regexp arrai field name regexp arrai field type class file writer acc privat if ha function gener function constructor cfw if ha script script or fn node script script or fn node 0 cfw add interfac org mozilla javascript script gener script ctor cfw script gener main cfw gener execut cfw script gener call method cfw gener nativ function overrid cfw encod sourc int count script or fn node length for int i 0 i count i script or fn node n script or fn node i bodi codegen bodygen new bodi codegen bodygen cfw cfw bodygen codegen thi bodygen compil env compil env bodygen script or fn n bodygen gener bodi code if n get type token function opt function node ofn opt function node get n gener function init cfw ofn if ofn is target of direct call emit direct constructor cfw ofn if direct call target null int n direct call target size for int j 0 j n j cfw add field get direct target field name j main class signatur class file writer acc privat emit reg exp init cfw emit constant dude initi cfw return cfw to byte arrai 
privat void emit direct constructor class file writer cfw opt function node ofn we gener scriptabl direct construct direct call arg scriptabl new instanc creat object cx scope object val bodi name cx scope new instanc direct call arg if val instanceof scriptabl return scriptabl val return new instanc cfw start method get direct ctor name ofn fnode get bodi method signatur ofn fnode short class file writer acc static class file writer acc privat int arg count ofn fnode get param count int first local 4 arg count 3 1 cfw add aload 0 thi cfw add aload 1 cx cfw add aload 2 scope cfw add invok byte code invokevirtu org mozilla javascript base function creat object lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl cfw add astor first local cfw add aload 0 cfw add aload 1 cfw add aload 2 cfw add aload first local for int i 0 i arg count i cfw add aload 4 i 3 cfw add dload 5 i 3 cfw add aload 4 arg count 3 cfw add invok byte code invokestat main class name get bodi method name ofn fnode get bodi method signatur ofn fnode int exit label cfw acquir label cfw add byte code dup make a copi of direct call result cfw add byte code instanceof org mozilla javascript scriptabl cfw add byte code ifeq exit label cast direct call result cfw add byte code checkcast org mozilla javascript scriptabl cfw add byte code areturn cfw mark label exit label cfw add aload first local cfw add byte code areturn cfw stop method short first local 1 
privat void gener call method class file writer cfw cfw start method call lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl ljava lang object ljava lang object short class file writer acc public class file writer acc final gener code for if script runtim ha top call cx return script runtim do top call thi cx scope thi obj arg int non top call label cfw acquir label cfw add aload 1 cx cfw add invok byte code invokestat org mozilla javascript script runtim ha top call lorg mozilla javascript context z cfw add byte code ifn non top call label cfw add aload 0 cfw add aload 1 cfw add aload 2 cfw add aload 3 cfw add aload 4 cfw add invok byte code invokestat org mozilla javascript script runtim do top call lorg mozilla javascript callabl lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl ljava lang object ljava lang object cfw add byte code areturn cfw mark label non top call label no gener switch to call the real method cfw add aload 0 cfw add aload 1 cfw add aload 2 cfw add aload 3 cfw add aload 4 int end script or fn node length boolean gener switch 2 end int switch start 0 int switch stack top 0 if gener switch cfw add load thi cfw add byte code getfield cfw get class name id field name i do switch from 1 end 1 map 0 to the default case switch start cfw add tabl switch 1 end 1 for int i 0 i end i script or fn node n script or fn node i if gener switch if i 0 cfw mark tabl switch default switch start switch stack top cfw get stack top els cfw mark tabl switch case switch start i 1 switch stack top if n get type token function opt function node ofn opt function node get n if ofn is target of direct call int pcount ofn fnode get param count if pcount 0 loop invari stack top argument arrai from add aload4 for int p 0 p pcount p cfw add byte code arraylength cfw add push p int undef arg cfw acquir label int beyond cfw acquir label cfw add byte code if icmpl undef arg get arrai p cfw add aload 4 cfw add push p cfw add byte code aaload cfw add byte code goto beyond cfw mark label undef arg push undefin cfw cfw mark label beyond onli on push cfw adjust stack top 1 cfw add push 0 0 restor invari cfw add aload 4 cfw add invok byte code invokestat main class name get bodi method name n get bodi method signatur n cfw add byte code areturn cfw stop method short 5 5 thi cx scope js thi arg 
privat void gener main class file writer cfw cfw start method main ljava lang string v short class file writer acc public class file writer acc static load new script impl cfw add byte code new cfw get class name cfw add byte code dup cfw add invok byte code invokespeci cfw get class name init v load arg cfw add byte code aload 0 call main method class main script script string arg cfw add invok byte code invokestat main method class main lorg mozilla javascript script ljava lang string v cfw add byte code return 1 string arg cfw stop method short 1 
privat void gener execut class file writer cfw script or fn node script cfw start method exec lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object short class file writer acc public class file writer acc final final int context arg 1 final int scope arg 2 cfw add load thi cfw add aload context arg cfw add aload scope arg cfw add byte code dup cfw add byte code aconst null cfw add invok byte code invokevirtu cfw get class name call lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl ljava lang object ljava lang object cfw add byte code areturn 3 thi context scope cfw stop method short 3 
privat void gener script ctor class file writer cfw script or fn node script cfw start method init v class file writer acc public cfw add load thi cfw add invok byte code invokespeci super class name init v set id to 0 cfw add load thi cfw add push 0 cfw add byte code putfield cfw get class name id field name i cfw add byte code return 1 paramet thi cfw stop method short 1 
privat void gener function constructor class file writer cfw final int scope arg 1 final int context arg 2 final int id arg 3 cfw start method init function constructor signatur class file writer acc public cfw add aload 0 cfw add invok byte code invokespeci super class name init v cfw add load thi cfw add iload id arg cfw add byte code putfield cfw get class name id field name i cfw add load thi cfw add aload context arg cfw add aload scope arg int start script or fn node 0 get type token script 1 0 int end script or fn node length if start end throw bad tree boolean gener switch 2 end start int switch start 0 int switch stack top 0 if gener switch cfw add iload id arg do switch from start 1 end 1 map start to the default case switch start cfw add tabl switch start 1 end 1 for int i start i end i if gener switch if i start cfw mark tabl switch default switch start switch stack top cfw get stack top els cfw mark tabl switch case switch start i 1 start switch stack top opt function node ofn opt function node get script or fn node i cfw add invok byte code invokevirtu main class name get function init method name ofn function init signatur cfw add byte code return 4 thi scope context id cfw stop method short 4 
privat void gener function init class file writer cfw opt function node ofn final int context arg 1 final int scope arg 2 cfw start method get function init method name ofn function init signatur short class file writer acc privat class file writer acc final call nativ function init script function cfw add load thi cfw add aload context arg cfw add aload scope arg cfw add invok byte code invokevirtu org mozilla javascript nativ function init script function lorg mozilla javascript context lorg mozilla javascript scriptabl v precompil all regexp liter int regexp count ofn fnode get regexp count if regexp count 0 cfw add load thi push reg exp arrai cfw ofn fnode context arg scope arg cfw add byte code putfield main class name regexp arrai field name regexp arrai field type cfw add byte code return 3 script thi function ref scope context cfw stop method short 3 
privat void gener nativ function overrid class file writer cfw string encod sourc overrid nativ function get languag version with public int get languag version return version constant cfw start method get languag version i class file writer acc public cfw add push compil env get languag version cfw add byte code ireturn 1 thi and no argument or local cfw stop method short 1 the rest of nativ function overrid requir specif code for each script function id final int do get function name 0 final int do get param count 1 final int do get param and var count 2 final int do get param or var name 3 final int do get encod sourc 4 final int switch count 5 for int method index 0 method index switch count method index if method index do get encod sourc encod sourc null continu gener prologu switch over function id to implement function specif action epilogu short metod local switch method index case do get function name metod local 1 onli thi cfw start method get function name ljava lang string class file writer acc public break case do get param count metod local 1 onli thi cfw start method get param count i class file writer acc public break case do get param and var count metod local 1 onli thi cfw start method get param and var count i class file writer acc public break case do get param or var name metod local 1 1 thi param or var index cfw start method get param or var name i ljava lang string class file writer acc public break case do get encod sourc metod local 1 onli thi cfw start method get encod sourc ljava lang string class file writer acc public cfw add push encod sourc break default throw kit code bug int count script or fn node length int switch start 0 int switch stack top 0 if count 1 gener switch but onli if there is more then on script function cfw add load thi cfw add byte code getfield cfw get class name id field name i do switch from 1 count 1 map 0 to the default case switch start cfw add tabl switch 1 count 1 for int i 0 i count i script or fn node n script or fn node i if i 0 if count 1 cfw mark tabl switch default switch start switch stack top cfw get stack top els cfw mark tabl switch case switch start i 1 switch stack top impelemnet method specif switch code switch method index case do get function name push function name if n get type token script cfw add push els string name function node n get function name cfw add push name cfw add byte code areturn break case do get param count push number of defin paramet cfw add push n get param count cfw add byte code ireturn break case do get param and var count push number of defin paramet and declar variabl cfw add push n get param and var count cfw add byte code ireturn break case do get param or var name push name of paramet us anoth switch over param and var count int param and var count n get param and var count if param and var count 0 the runtim should never call the method in thi case but to make bytecod verifi happi return null as throw execpt take more code cfw add byte code aconst null cfw add byte code areturn els if param and var count 1 as abov do not check for valid index but alwai return the name of the first param cfw add push n get param or var name 0 cfw add byte code areturn els do switch over get param or var name cfw add iload 1 param or var index do switch from 1 param and var count 1 map 0 to the default case int param switch start cfw add tabl switch 1 param and var count 1 for int j 0 j param and var count j if cfw get stack top 0 kit code bug string s n get param or var name j if j 0 cfw mark tabl switch default param switch start els cfw mark tabl switch case param switch start j 1 0 cfw add push s cfw add byte code areturn break case do get encod sourc push number encod sourc start and end to prepar for encod sourc substr start end cfw add push n get encod sourc start cfw add push n get encod sourc end cfw add invok byte code invokevirtu java lang string substr ii ljava lang string cfw add byte code areturn break default throw kit code bug cfw stop method metod local 
privat void emit reg exp init class file writer cfw precompil all regexp liter int total reg count 0 for int i 0 i script or fn node length i total reg count script or fn node i get regexp count if total reg count 0 return cfw start method regexp init method name regexp init method signatur short class file writer acc static class file writer acc privat class file writer acc synchron cfw add field re init done z short class file writer acc static class file writer acc privat cfw add byte code getstat main class name re init done z int do init cfw acquir label cfw add byte code ifeq do init cfw add byte code return cfw mark label do init for int i 0 i script or fn node length i script or fn node n script or fn node i int reg count n get regexp count for int j 0 j reg count j string re field name get compil regexp name n j string re field type ljava lang object string re string n get regexp string j string re flag n get regexp flag j cfw add field re field name re field type short class file writer acc static class file writer acc privat cfw add aload 0 proxi cfw add aload 1 context cfw add push re string if re flag null cfw add byte code aconst null els cfw add push re flag cfw add invok byte code invokeinterfac org mozilla javascript reg exp proxi compil reg exp lorg mozilla javascript context ljava lang string ljava lang string ljava lang object cfw add byte code putstat main class name re field name re field type cfw add push 1 cfw add byte code putstat main class name re init done z cfw add byte code return cfw stop method short 2 
privat void emit constant dude initi class file writer cfw int n it constant list size if n 0 return cfw start method clinit v short class file writer acc static class file writer acc final doubl arrai it constant list for int i 0 i n i doubl num arrai i string constant name k i string constant type get static constant wrapper type num cfw add field constant name constant type short class file writer acc static class file writer acc privat int inum int num if inum num cfw add byte code new java lang integ cfw add byte code dup cfw add push inum cfw add invok byte code invokespeci java lang integ init i v els cfw add push num add doubl wrap cfw cfw add byte code putstat main class name constant name constant type cfw add byte code return cfw stop method short 0 
void push reg exp arrai class file writer cfw script or fn node n int context arg int scope arg int regexp count n get regexp count if regexp count 0 throw bad tree cfw add push regexp count cfw add byte code anewarrai java lang object cfw add aload context arg cfw add invok byte code invokestat org mozilla javascript script runtim check reg exp proxi lorg mozilla javascript context lorg mozilla javascript reg exp proxi stack proxi arrai cfw add byte code dup cfw add aload context arg cfw add invok byte code invokestat main class name regexp init method name regexp init method signatur for int i 0 i regexp count i stack proxi arrai cfw add byte code dup2 cfw add aload context arg cfw add aload scope arg cfw add byte code getstat main class name get compil regexp name n i ljava lang object stack compil reg exp scope cx proxi arrai proxi arrai cfw add invok byte code invokeinterfac org mozilla javascript reg exp proxi wrap reg exp lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript scriptabl stack wrap reg exp arrai proxi arrai cfw add push i cfw add byte code swap cfw add byte code aastor stack proxi arrai remov proxi cfw add byte code pop 
void push number as object class file writer cfw doubl num if num 0 0 if 1 num 0 0 0 cfw add byte code getstat org mozilla javascript optim opt runtim zero obj ljava lang doubl els cfw add push num add doubl wrap cfw els if num 1 0 cfw add byte code getstat org mozilla javascript optim opt runtim on obj ljava lang doubl return els if num 1 0 cfw add byte code getstat org mozilla javascript optim opt runtim minu on obj ljava lang doubl els if num num cfw add byte code getstat org mozilla javascript script runtim na nobj ljava lang doubl els if it constant list size 2000 there appear to be a limit in the jvm on either the number of static field in a class or the size of the class initi either wai we can t have ani more than 2000 static init d constant cfw add push num add doubl wrap cfw els int n it constant list size int index 0 if n 0 it constant list new doubl 64 els doubl arrai it constant list while index n arrai index num index if n arrai length arrai new doubl n 2 system arraycopi it constant list 0 arrai 0 n it constant list arrai if index n it constant list n num it constant list size n 1 string constant name k index string constant type get static constant wrapper type num cfw add byte code getstat main class name constant name constant type 
privat static void add doubl wrap class file writer cfw cfw add invok byte code invokestat org mozilla javascript optim opt runtim wrap doubl d ljava lang doubl 
privat static string get static constant wrapper type doubl num string constant type int inum int num if inum num return ljava lang integ els return ljava lang doubl 
static void push undefin class file writer cfw cfw add byte code getstat org mozilla javascript undefin instanc ljava lang object 
int get index script or fn node n return script or fn index get exist n 
static string get direct target field name int i return dt i 
string get direct ctor name script or fn node n return n get index n 
string get bodi method name script or fn node n return c get index n 
string get bodi method signatur script or fn node n string buffer sb new string buffer sb append sb append main class signatur sb append lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl if n get type token function opt function node ofn opt function node get n if ofn is target of direct call int p count ofn fnode get param count for int i 0 i p count i sb append ljava lang object d sb append ljava lang object ljava lang object return sb to string 
string get function init method name opt function node ofn return i get index ofn fnode 
string get compil regexp name script or fn node n int regexp index return re get index n regexp index 
static runtim except bad tree throw new runtim except bad tree in codegen 
void set main method class string class name main method class class name 
void gener bodi code init bodi gener cfw start method codegen get bodi method name script or fn codegen get bodi method signatur script or fn short class file writer acc static class file writer acc privat gener prologu node tree top if fn current null tree top script or fn get last child els tree top script or fn gener statement tree top null gener epilogu cfw stop method short local max 1 
privat void init bodi gener is top level script or fn codegen script or fn node 0 var regist null if script or fn get type token function fn current opt function node get script or fn ha var in reg fn current fnode requir activ if ha var in reg int n fn current fnode get param and var count if n 0 var regist new short n in direct call function fn current is target of direct call if in direct call function ha var in reg codegen bad tree els fn current null ha var in reg fals in direct call function fals local new boolean max local fun obj local 0 context local 1 variabl object local 2 thi obj local 3 local max short 4 number of parm thi first free local 4 popv local 1 arg local 1 it zero arg arrai 1 it on arg arrai 1 script regexp local 1 epilogu label 1 enter area start label 1 
gener the prologu for a function or script privat void gener prologu if in direct call function int direct paramet count script or fn get param count 0 is reserv for function object thi 1 is reserv for context 2 is reserv for parent scope 3 is reserv for script thi if first free local 4 kit code bug for int i 0 i direct paramet count i var regist i first free local 3 is 1 for object parm and 2 for doubl parm first free local 3 if fn current get paramet number context make sure that all paramet ar object it forc object paramet true for int i 0 i direct paramet count i short reg var regist i cfw add aload reg cfw add byte code getstat java lang void type ljava lang class int is object label cfw acquir label cfw add byte code if acmpn is object label cfw add dload reg 1 add doubl wrap cfw add astor reg cfw mark label is object label if fn current null in direct call function compil env is us dynam scope fn current fnode get ignor dynam scope unless we re either in a direct call or us dynam scope us the enclos scope of the function as our variabl object cfw add aload fun obj local cfw add invok byte code invokeinterfac org mozilla javascript scriptabl get parent scope lorg mozilla javascript scriptabl cfw add astor variabl object local reserv arg arg local first free local local max first free local if fn current null see comment in case token regexp if script or fn get regexp count 0 script regexp local get new word local codegen push reg exp arrai cfw script or fn context local variabl object local cfw add astor script regexp local if ha var in reg no need to creat activ pad argument if need be int parm count script or fn get param count if parm count 0 in direct call function set up arg arrai check length of argument pad if need be cfw add aload arg local cfw add byte code arraylength cfw add push parm count int label cfw acquir label cfw add byte code if icmpg label cfw add aload arg local cfw add push parm count add script runtim invok pad argument ljava lang object i ljava lang object cfw add astor arg local cfw mark label label int param count fn current fnode get param count int var count fn current fnode get param and var count remind onli need to initi the var that don t get a valu befor the next call and ar us in the function short first undef var 1 for int i 0 i var count i short reg 1 if i param count if in direct call function reg get new word local cfw add aload arg local cfw add push i cfw add byte code aaload cfw add astor reg els if fn current is number var i reg get new word pair local cfw add push 0 0 cfw add dstore reg els reg get new word local if first undef var 1 codegen push undefin cfw first undef var reg els cfw add aload first undef var cfw add astor reg if reg 0 var regist i reg add debug tabl enri if we re gener debug info if compil env is gener debug info string name fn current fnode get param or var name i string type fn current is number var i d ljava lang object int start pc cfw get current code offset if reg 0 reg var regist i cfw add variabl descriptor name type start pc reg skip creat activ object return string debug variabl name if fn current null debug variabl name activ cfw add aload fun obj local cfw add aload variabl object local cfw add aload arg local add script runtim invok creat function activ lorg mozilla javascript nativ function lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript scriptabl cfw add astor variabl object local cfw add aload context local cfw add aload variabl object local add script runtim invok enter activ function lorg mozilla javascript context lorg mozilla javascript scriptabl v els debug variabl name global cfw add aload fun obj local cfw add aload thi obj local cfw add aload context local cfw add aload variabl object local cfw add push 0 fals to indic it is not eval script add script runtim invok init script lorg mozilla javascript nativ function lorg mozilla javascript scriptabl lorg mozilla javascript context lorg mozilla javascript scriptabl z v enter area start label cfw acquir label epilogu label cfw acquir label cfw mark label enter area start label int function count script or fn get function count for int i 0 i function count i opt function node ofn opt function node get script or fn i if ofn fnode get function type function node function statement visit function ofn function node function statement default is to gener debug info if compil env is gener debug info cfw add variabl descriptor debug variabl name lorg mozilla javascript scriptabl cfw get current code offset variabl object local if fn current null opt us dataflow to prove that thi assign is dead popv local get new word local codegen push undefin cfw cfw add astor popv local int linenum script or fn get end lineno if linenum 1 cfw add line number entri short linenum els if fn current it contain calls0 it zero arg arrai get new word local cfw add byte code getstat org mozilla javascript script runtim empti arg ljava lang object cfw add astor it zero arg arrai if fn current it contain calls1 it on arg arrai get new word local cfw add push 1 cfw add byte code anewarrai java lang object cfw add astor it on arg arrai 
privat void gener epilogu if ha var in reg if epilogu label 1 cfw mark label epilogu label cfw add byte code areturn return cfw mark label epilogu label if fn current null cfw add aload popv local cfw add byte code areturn els gener activ exit cfw add byte code areturn gener catch block to catch all and rethrow to call exit code under except propag as well int final handler cfw acquir label cfw mark handler final handler short except object get new word local cfw add astor except object duplic gener activ exit in the catch block sinc it take less space then full fetur byte code jsr byte code ret gener activ exit cfw add aload except object releas word local except object rethrow cfw add byte code athrow mark the handler cfw add except handler enter area start label epilogu label final handler null catch ani 
privat void gener activ exit if fn current null ha var in reg throw kit code bug cfw add aload context local add script runtim invok exit activ function lorg mozilla javascript context v 
privat void gener statement node node node parent system out println gen code for node to string updat line number node int type node get type node child node get first child switch type case token loop case token label case token with case token script case token block case token empti no op while child null gener statement child node child child get next break case token local block int local get new word local node put int prop node local prop local while child null gener statement child node child child get next releas word local short local node remov prop node local prop break case token function int fn index node get exist int prop node function prop opt function node ofn opt function node get script or fn fn index int t ofn fnode get function type if t function node function express statement visit function ofn t els if t function node function statement throw codegen bad tree break case token try visit try catch final node jump node child break case token catch scope int local get local block regist node int scope index node get exist int prop node catch scope prop string name child get string name of except child child get next gener express child node load express object if scope index 0 cfw add byte code aconst null els load previou catch scope object cfw add aload local cfw add push name cfw add aload context local cfw add aload variabl object local add script runtim invok new catch scope ljava lang throwabl lorg mozilla javascript scriptabl ljava lang string lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl cfw add astor local break case token throw gener express child node cfw add byte code new org mozilla javascript java script except cfw add byte code dup x1 cfw add byte code swap cfw add push script or fn get sourc name cfw add push it line number cfw add invok byte code invokespeci org mozilla javascript java script except init ljava lang object ljava lang string i v cfw add byte code athrow break case token rethrow cfw add aload get local block regist node cfw add byte code athrow break case token return result case token return if child null gener express child node els if type token return codegen push undefin cfw els if popv local 0 throw codegen bad tree cfw add aload popv local if epilogu label 1 if ha var in reg throw codegen bad tree epilogu label cfw acquir label cfw add byte code goto epilogu label break case token switch visit switch node jump node child break case token enterwith gener express child node cfw add aload context local cfw add aload variabl object local add script runtim invok enter with ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl cfw add astor variabl object local break case token leavewith cfw add aload variabl object local add script runtim invok leav with lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl cfw add astor variabl object local break case token enum init kei case token enum init valu gener express child node cfw add aload context local cfw add push type token enum init valu add script runtim invok enum init ljava lang object lorg mozilla javascript context z ljava lang object cfw add astor get local block regist node break case token expr void if child get type token setvar special case thi so as to avoid unnecessari load s pop s visit set var child child get first child fals els gener express child node if node get int prop node isnumb prop 1 1 cfw add byte code pop2 els cfw add byte code pop break case token expr result gener express child node if popv local 0 popv local get new word local cfw add astor popv local break case token target int label get target label node cfw mark label label break case token jsr case token goto case token ifeq case token ifn visit goto node jump node type child break case token final save return address in a new local where int final regist get new word local cfw add astor final regist while child null gener statement child node child child get next cfw add byte code ret final regist releas word local short final regist break default throw codegen bad tree 
privat void gener express node node node parent int type node get type node child node get first child switch type case token us stack break case token function if fn current null parent get type token script int fn index node get exist int prop node function prop opt function node ofn opt function node get script or fn fn index int t ofn fnode get function type if t function node function express throw codegen bad tree visit function ofn t break case token name cfw add aload context local cfw add aload variabl object local cfw add push node get string add script runtim invok name lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang string ljava lang object break case token call case token new int special type node get int prop node specialcal prop node non specialcal if special type node non specialcal opt function node target target opt function node node get prop node directcal prop if target null visit optim call node target type child els if type token call visit standard call node child els visit standard new node child els visit special call node type special type child break case token ref call gener function and thi obj child node stack function obj thi obj child child get next gener call arg arrai node child fals cfw add aload context local add script runtim invok call ref lorg mozilla javascript callabl lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript context lorg mozilla javascript ref break case token number doubl num node get doubl if node get int prop node isnumb prop 1 1 cfw add push num els codegen push number as object cfw num break case token string cfw add push node get string break case token thi cfw add aload thi obj local break case token thisfn cfw add byte code aload 0 break case token null cfw add byte code aconst null break case token true cfw add byte code getstat java lang boolean true ljava lang boolean break case token fals cfw add byte code getstat java lang boolean fals ljava lang boolean break case token regexp int i node get exist int prop node regexp prop script can not us regexp arrai field name sinc it it will make script exec non reentrant so thei store regexp arrai in a local variabl while function alwai access precomput regexp arrai field name not to consum local if fn current null cfw add aload script regexp local els cfw add aload fun obj local cfw add byte code getfield codegen main class name codegen regexp arrai field name codegen regexp arrai field type cfw add push i cfw add byte code aaload break case token comma node next child get next while next null gener express child node cfw add byte code pop child next next next get next gener express child node break case token enum next case token enum id int local get local block regist node cfw add aload local if type token enum next add script runtim invok enum next ljava lang object ljava lang boolean els cfw add aload context local add script runtim invok enum id ljava lang object lorg mozilla javascript context ljava lang object break case token arraylit visit arrai liter node child break case token objectlit visit object liter node child break case token not int true target cfw acquir label int fals target cfw acquir label int beyond cfw acquir label gener if jump child node true target fals target cfw mark label true target cfw add byte code getstat java lang boolean fals ljava lang boolean cfw add byte code goto beyond cfw mark label fals target cfw add byte code getstat java lang boolean true ljava lang boolean cfw mark label beyond cfw adjust stack top 1 break case token bitnot gener express child node add script runtim invok to int32 ljava lang object i cfw add push 1 implement a as a 1 cfw add byte code ixor cfw add byte code i2d add doubl wrap break case token void gener express child node cfw add byte code pop codegen push undefin cfw break case token typeof gener express child node add script runtim invok typeof ljava lang object ljava lang string break case token typeofnam visit typeofnam node break case token inc case token dec visit inc dec node fals break case token or case token and gener express child node cfw add byte code dup add script runtim invok to boolean ljava lang object z int fals target cfw acquir label if type token and cfw add byte code ifeq fals target els cfw add byte code ifn fals target cfw add byte code pop gener express child get next node cfw mark label fals target break case token hook node if then child get next node if els if then get next gener express child node add script runtim invok to boolean ljava lang object z int els target cfw acquir label cfw add byte code ifeq els target short stack cfw get stack top gener express if then node int after hook cfw acquir label cfw add byte code goto after hook cfw mark label els target stack gener express if els node cfw mark label after hook break case token add gener express child node gener express child get next node switch node get int prop node isnumb prop 1 case node both cfw add byte code dadd break case node left add opt runtim invok add dljava lang object ljava lang object break case node right add opt runtim invok add ljava lang object d ljava lang object break default cfw add aload context local add script runtim invok add ljava lang object ljava lang object lorg mozilla javascript context ljava lang object break case token mul visit arithmet node byte code dmul child parent break case token sub visit arithmet node byte code dsub child parent break case token div case token mod visit arithmet node type token div byte code ddiv byte code drem child parent break case token bitor case token bitxor case token bitand case token lsh case token rsh case token ursh visit bit op node type child break case token po case token neg gener express child node add object to doubl if type token neg cfw add byte code dneg add doubl wrap break case token to doubl cnvt to doubl not doubl gener express child node add object to doubl break case token to object convert from doubl int prop 1 if child get type token number prop child get int prop node isnumb prop 1 if prop 1 child remov prop node isnumb prop gener express child node child put int prop node isnumb prop prop els gener express child node add doubl wrap break case token in case token instanceof case token le case token lt case token ge case token gt int true goto cfw acquir label int fals goto cfw acquir label visit if jump rel op node child true goto fals goto add jump boolean wrap true goto fals goto break case token eq case token ne case token sheq case token shne int true goto cfw acquir label int fals goto cfw acquir label visit if jump eq op node child true goto fals goto add jump boolean wrap true goto fals goto break case token getprop visit get prop node child break case token getelem gener express child node object gener express child get next node id cfw add aload context local if node get int prop node isnumb prop 1 1 add script runtim invok get object index ljava lang object d lorg mozilla javascript context ljava lang object els add script runtim invok get object elem ljava lang object ljava lang object lorg mozilla javascript context ljava lang object break case token get ref gener express child node refer cfw add aload context local add script runtim invok ref get lorg mozilla javascript ref lorg mozilla javascript context ljava lang object break case token getvar visit get var node break case token setvar visit set var node child true break case token setnam visit set name node child break case token setprop case token setprop op visit set prop type node child break case token setelem case token setelem op visit set elem type node child break case token set ref case token set ref op gener express child node child child get next if type token set ref op cfw add byte code dup cfw add aload context local add script runtim invok ref get lorg mozilla javascript ref lorg mozilla javascript context ljava lang object gener express child node cfw add aload context local add script runtim invok ref set lorg mozilla javascript ref ljava lang object lorg mozilla javascript context ljava lang object break case token del ref gener express child node cfw add aload context local add script runtim invok ref del lorg mozilla javascript ref lorg mozilla javascript context ljava lang object break case token delprop gener express child node child child get next gener express child node cfw add aload context local add script runtim invok delet ljava lang object ljava lang object lorg mozilla javascript context ljava lang object break case token bindnam while child null gener express child node child child get next gener code for script runtim bind var obj s cfw add aload context local cfw add aload variabl object local cfw add push node get string add script runtim invok bind lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang string lorg mozilla javascript scriptabl break case token local load cfw add aload get local block regist node break case token ref special string special string node get prop node name prop gener express child node cfw add push special cfw add aload context local add script runtim invok special ref ljava lang object ljava lang string lorg mozilla javascript context lorg mozilla javascript ref break case token ref member case token ref ns member case token ref name case token ref ns name int member type flag node get int prop node member type prop 0 gener possibl target possibl namespac and member do gener express child node child child get next while child null cfw add aload context local string method name signatur switch type case token ref member method name member ref signatur ljava lang object ljava lang object lorg mozilla javascript context i lorg mozilla javascript ref break case token ref ns member method name member ref signatur ljava lang object ljava lang object ljava lang object lorg mozilla javascript context i lorg mozilla javascript ref break case token ref name method name name ref signatur ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl i lorg mozilla javascript ref cfw add aload variabl object local break case token ref ns name method name name ref signatur ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl i lorg mozilla javascript ref cfw add aload variabl object local break default throw kit code bug cfw add push member type flag add script runtim invok method name signatur break case token dotqueri visit dot queri node child break case token escxmlattr gener express child node cfw add aload context local add script runtim invok escap attribut valu ljava lang object lorg mozilla javascript context ljava lang string break case token escxmltext gener express child node cfw add aload context local add script runtim invok escap text valu ljava lang object lorg mozilla javascript context ljava lang string break case token defaultnamespac gener express child node cfw add aload context local add script runtim invok set default namespac ljava lang object lorg mozilla javascript context ljava lang object break default throw new runtim except unexpect node type type 
privat void gener if jump node node node parent int true label int fals label system out println gen code for node to string int type node get type node child node get first child switch type case token not gener if jump child node fals label true label break case token or case token and int inter label cfw acquir label if type token and gener if jump child node inter label fals label els gener if jump child node true label inter label cfw mark label inter label child child get next gener if jump child node true label fals label break case token in case token instanceof case token le case token lt case token ge case token gt visit if jump rel op node child true label fals label break case token eq case token ne case token sheq case token shne visit if jump eq op node child true label fals label break default gener gener code for non optim jump gener express node parent add script runtim invok to boolean ljava lang object z cfw add byte code ifn true label cfw add byte code goto fals label 
privat void visit function opt function node ofn int function type int fn index codegen get index ofn fnode cfw add byte code new codegen main class name call function constructor cfw add byte code dup cfw add aload variabl object local cfw add aload context local load cx cfw add push fn index cfw add invok byte code invokespeci codegen main class name init codegen function constructor signatur init main script field cfw add byte code dup if is top level cfw add byte code aload 0 els cfw add byte code aload 0 cfw add byte code getfield codegen main class name codegen direct call parent field codegen main class signatur cfw add byte code putfield codegen main class name codegen direct call parent field codegen main class signatur int direct target index ofn get direct target index if direct target index 0 cfw add byte code dup if is top level cfw add byte code aload 0 els cfw add byte code aload 0 cfw add byte code getfield codegen main class name codegen direct call parent field codegen main class signatur cfw add byte code swap cfw add byte code putfield codegen main class name codegen get direct target field name direct target index codegen main class signatur if function type function node function express leav closur object on stack and do not pass it to init function which suppos to connect statement to scope return cfw add push function type cfw add aload variabl object local cfw add aload context local load cx add opt runtim invok init function lorg mozilla javascript nativ function i lorg mozilla javascript scriptabl lorg mozilla javascript context v 
privat int get target label node target int label id target label id if label id 1 label id cfw acquir label target label id label id return label id 
privat void visit goto node jump node int type node child node target node target if type token ifeq type token ifn if child null throw codegen bad tree int target label get target label target int fall thru label cfw acquir label if type token ifeq gener if jump child node target label fall thru label els gener if jump child node fall thru label target label cfw mark label fall thru label els if type token jsr add goto target byte code jsr els add goto target byte code goto 
privat void visit arrai liter node node node child int count 0 for node cursor child cursor null cursor cursor get next count load arrai to store arrai liter object add new object arrai count for int i 0 i count i cfw add byte code dup cfw add push i gener express child node cfw add byte code aastor child child get next int skip index int node get prop node skip index prop if skip index null cfw add byte code aconst null cfw add byte code iconst 0 els cfw add push opt runtim encod int arrai skip index cfw add push skip index length cfw add aload context local cfw add aload variabl object local add opt runtim invok new arrai liter ljava lang object ljava lang string i lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl 
privat void visit object liter node node node child object properti object node get prop node object id prop int count properti length load arrai with properti id add new object arrai count for int i 0 i count i cfw add byte code dup cfw add push i object id properti i if id instanceof string cfw add push string id els cfw add push integ id int valu add script runtim invok wrap int i ljava lang integ cfw add byte code aastor load arrai with properti valu add new object arrai count for int i 0 i count i cfw add byte code dup cfw add push i gener express child node cfw add byte code aastor child child get next cfw add aload context local cfw add aload variabl object local add script runtim invok new object liter ljava lang object ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl 
privat void visit special call node node int type int special type node child cfw add aload context local if type token new gener express child node stack cx function obj els gener function and thi obj child node stack cx function obj thi obj child child get next gener call arg arrai node child fals string method name string call signatur if type token new method name new object special call signatur lorg mozilla javascript context ljava lang object ljava lang object lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl i call type ljava lang object cfw add aload variabl object local cfw add aload thi obj local cfw add push special type els method name call special call signatur lorg mozilla javascript context lorg mozilla javascript callabl lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl i call type ljava lang string i filenam linenumb ljava lang object cfw add aload variabl object local cfw add aload thi obj local cfw add push special type string sourc name script or fn get sourc name cfw add push sourc name null sourc name cfw add push it line number add opt runtim invok method name call signatur 
privat void visit standard call node node node child if node get type token call throw codegen bad tree node first arg child child get next int child type child get type string method name string signatur if first arg child null if child type token name name call string name child get string cfw add push name method name call name0 signatur ljava lang string lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object els if child type token getprop x name call node prop target child get first child gener express prop target node node id prop target get next string properti id get string cfw add push properti method name call prop0 signatur ljava lang object ljava lang string lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object els gener function and thi obj child node method name call0 signatur lorg mozilla javascript callabl lorg mozilla javascript scriptabl lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object els if child type token name xxx thi optim is onli possibl if name resolut is not affect by argument evalu and current there ar no check for it string name child get string gener call arg arrai node first arg child fals cfw add push name method name call name signatur ljava lang object ljava lang string lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object els int arg count 0 for node arg first arg child arg null arg arg get next arg count gener function and thi obj child node stack function obj thi obj if arg count 1 gener express first arg child node method name call1 signatur lorg mozilla javascript callabl lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object els if arg count 2 gener express first arg child node gener express first arg child get next node method name call2 signatur lorg mozilla javascript callabl lorg mozilla javascript scriptabl ljava lang object ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object els gener call arg arrai node first arg child fals method name call n signatur lorg mozilla javascript callabl lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object cfw add aload context local cfw add aload variabl object local add opt runtim invok method name signatur 
privat void visit standard new node node node child if node get type token new throw codegen bad tree node first arg child child get next gener express child node stack function obj cfw add aload context local cfw add aload variabl object local stack function obj cx scope gener call arg arrai node first arg child fals add script runtim invok new object ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript scriptabl 
privat void visit optim call node node opt function node target int type node child node first arg child child get next short thi obj local 0 if type token new gener express child node els gener function and thi obj child node thi obj local get new word local cfw add astor thi obj local stack function obj int beyond cfw acquir label int direct target index target get direct target index if is top level cfw add byte code aload 0 els cfw add byte code aload 0 cfw add byte code getfield codegen main class name codegen direct call parent field codegen main class signatur cfw add byte code getfield codegen main class name codegen get direct target field name direct target index codegen main class signatur cfw add byte code dup2 stack function obj direct funct function obj direct funct int regular call cfw acquir label cfw add byte code if acmpn regular call stack function obj direct funct short stack height cfw get stack top cfw add byte code swap cfw add byte code pop stack direct funct if compil env is us dynam scope cfw add aload context local cfw add aload variabl object local els cfw add byte code dup stack direct funct direct funct cfw add invok byte code invokeinterfac org mozilla javascript scriptabl get parent scope lorg mozilla javascript scriptabl stack direct funct scope cfw add aload context local stack direct funct scope cx cfw add byte code swap stack direct func cx scope if type token new cfw add byte code aconst null els cfw add aload thi obj local stack direct func cx scope thi obj rememb that direct call paramet ar pair in 1 a reg and 1 d reg if the argument is an incom arg just pass the orgin pair thru els if the argument is known to be type number pass void type in the a reg and the number is the d reg els pass the js object in the a reg and 0 0 in the d reg node arg child first arg child while arg child null int dcp regist node is direct call paramet arg child if dcp regist 0 cfw add aload dcp regist cfw add dload dcp regist 1 els if arg child get int prop node isnumb prop 1 node both cfw add byte code getstat java lang void type ljava lang class gener express arg child node els gener express arg child node cfw add push 0 0 arg child arg child get next cfw add byte code getstat org mozilla javascript script runtim empti arg ljava lang object cfw add invok byte code invokestat codegen main class name type token new codegen get direct ctor name target fnode codegen get bodi method name target fnode codegen get bodi method signatur target fnode cfw add byte code goto beyond cfw mark label regular call stack height stack function obj direct funct cfw add byte code pop cfw add aload context local cfw add aload variabl object local stack function obj cx scope if type token new cfw add aload thi obj local releas word local thi obj local stack function obj cx scope thi obj xxx thi will gener code for the child arrai the second time so express code gener better not to alter tree structur gener call arg arrai node first arg child true if type token new add script runtim invok new object ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript scriptabl els cfw add invok byte code invokeinterfac org mozilla javascript callabl call lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl ljava lang object ljava lang object cfw mark label beyond 
privat void gener call arg arrai node node node arg child boolean direct call int arg count 0 for node child arg child child null child child get next arg count load arrai object to set argument if arg count 1 it on arg arrai 0 cfw add aload it on arg arrai els add new object arrai arg count copi argument into it for int i 0 i arg count i cfw add byte code dup cfw add push i if direct call gener express arg child node els if thi ha also been a direct call sequenc the number flag will have remain set for ani paramet so that the valu could be copi directli into the outgo arg here we want to forc it to be treat as not in a number context so we set the flag off int dcp regist node is direct call paramet arg child if dcp regist 0 dcp load as object dcp regist els gener express arg child node int child number flag arg child get int prop node isnumb prop 1 if child number flag node both add doubl wrap cfw add byte code aastor arg child arg child get next 
privat void gener function and thi obj node node node parent place on stack function object function thi pair int type node get type switch node get type case token getprop case token getelem node target node get first child gener express target node node id target get next if type token getprop string properti id get string cfw add push properti cfw add aload context local add script runtim invok get prop function and thi ljava lang object ljava lang string lorg mozilla javascript context lorg mozilla javascript callabl els optim do not optim thi case for now if node get int prop node isnumb prop 1 1 throw codegen bad tree gener express id node id cfw add aload context local add script runtim invok get elem function and thi ljava lang object ljava lang object lorg mozilla javascript context lorg mozilla javascript callabl break case token name string name node get string cfw add push name cfw add aload context local cfw add aload variabl object local add script runtim invok get name function and thi ljava lang string lorg mozilla javascript context lorg mozilla javascript scriptabl lorg mozilla javascript callabl break default includ getvar gener express node parent cfw add aload context local add script runtim invok get valu function and thi ljava lang object lorg mozilla javascript context lorg mozilla javascript callabl break get thi obj prepar by get name prop elem valu function and thi cfw add aload context local add script runtim invok last store scriptabl lorg mozilla javascript context lorg mozilla javascript scriptabl 
privat void updat line number node node it line number node get lineno if it line number 1 return cfw add line number entri short it line number 
privat void visit try catch final node jump node node child save the variabl object in case there ar with statement enclos by the try block and we catch some except we ll restor it for the catch block so that catch block statement get the right scope opt we onli need to do thi if there ar enclos with statement could static check and omit thi if there aren t ani xxx opt mayb instead do syntact transform to associ each with with a try final block that doe the exitwith short save variabl object get new word local cfw add aload variabl object local cfw add astor save variabl object gener the code for the tree most of the work is done in irfactori and node transform codegen just add the java handler for the javascript catch and final claus need to set the stack top to 1 to account for the incom except int start label cfw acquir label cfw mark label start label short 1 while child null gener statement child node child child get next node catch target node target node final target node get final control flow skip the handler int real end cfw acquir label cfw add byte code goto real end int except local get local block regist node javascript handler unwrap except and goto to javascript catch area if catch target null get the label to goto int catch label catch target label id gener catch block javascript except save variabl object catch label start label except local catch wrap except see if thei ar wrap java script except otherwis rethrow gener catch block evalu except save variabl object catch label start label except local we also need to catch ecma error and feed the associ error object to the handler gener catch block ecmaerror except save variabl object catch label start label except local final handler catch all except store to a local jsr to the final then re throw if final target null int final handler cfw acquir label cfw mark handler final handler cfw add astor except local reset the variabl object local cfw add aload save variabl object cfw add astor variabl object local get the label to jsr to int final label final target label id cfw add byte code jsr final label rethrow cfw add aload except local cfw add byte code athrow mark the handler cfw add except handler start label final label final handler null catch ani releas word local save variabl object cfw mark label real end 
privat void gener catch block int except type short save variabl object int catch label int start label int except local int handler cfw acquir label cfw mark handler handler ms jvm get cranki if the except object is left on the stack cfw add astor except local reset the variabl object local cfw add aload save variabl object cfw add astor variabl object local string except name if except type javascript except except name org mozilla javascript java script except els if except type evalu except except name org mozilla javascript evalu except els if except type ecmaerror except kit code bug except name org mozilla javascript ecma error mark the handler cfw add except handler start label catch label handler except name cfw add byte code goto catch label 
privat void visit switch node jump switch node node child see comment in irfactori creat switch for descript of switch node gener express child switch node save selector valu short selector get new word local cfw add astor selector for node jump case node node jump child get next case node null case node node jump case node get next if case node get type token case throw codegen bad tree node test case node get first child gener express test case node cfw add aload selector add script runtim invok shallow eq ljava lang object ljava lang object z add goto case node target byte code ifn releas word local selector 
privat void visit typeofnam node node string name node get string if ha var in reg int var index fn current fnode get param or var index name if var index 0 if fn current is number var var index cfw add push number els if var is direct call paramet var index int dcp regist var regist var index cfw add aload dcp regist cfw add byte code getstat java lang void type ljava lang class int is number label cfw acquir label cfw add byte code if acmpeq is number label short stack cfw get stack top cfw add aload dcp regist add script runtim invok typeof ljava lang object ljava lang string int beyond cfw acquir label cfw add byte code goto beyond cfw mark label is number label stack cfw add push number cfw mark label beyond els cfw add aload var regist var index add script runtim invok typeof ljava lang object ljava lang string return cfw add aload variabl object local cfw add push name add script runtim invok typeof name lorg mozilla javascript scriptabl ljava lang string ljava lang string 
privat void visit inc dec node node boolean is inc int incr decr mask node get exist int prop node incrdecr prop node child node get first child switch child get type case token getvar if ha var in reg kit code bug if node get int prop node isnumb prop 1 1 boolean post incr decr mask node post flag 0 int var index fn current get var index child short reg var regist var index cfw add dload reg if post cfw add byte code dup2 cfw add push 1 0 if incr decr mask node decr flag 0 cfw add byte code dadd els cfw add byte code dsub if post cfw add byte code dup2 cfw add dstore reg els boolean post incr decr mask node post flag 0 int var index fn current get var index child short reg var regist var index cfw add aload reg if post cfw add byte code dup add object to doubl cfw add push 1 0 if incr decr mask node decr flag 0 cfw add byte code dadd els cfw add byte code dsub add doubl wrap if post cfw add byte code dup cfw add astor reg break break case token name cfw add aload variabl object local cfw add push child get string push name cfw add push incr decr mask add script runtim invok name incr decr lorg mozilla javascript scriptabl ljava lang string i ljava lang object break case token getprop node get prop child child get first child gener express get prop child node gener express get prop child get next node cfw add aload context local cfw add push incr decr mask add script runtim invok prop incr decr ljava lang object ljava lang string lorg mozilla javascript context i ljava lang object break case token getelem node elem child child get first child gener express elem child node gener express elem child get next node cfw add aload context local cfw add push incr decr mask add script runtim invok elem incr decr ljava lang object ljava lang object lorg mozilla javascript context i ljava lang object break case token get ref node ref child child get first child gener express ref child node cfw add aload context local cfw add push incr decr mask add script runtim invok ref incr decr lorg mozilla javascript ref lorg mozilla javascript context i ljava lang object break default codegen bad tree 
privat static boolean is arithmet node node node int type node get type return type token sub type token mod type token div type token mul 
privat void visit arithmet node node int op code node child node parent int child number flag node get int prop node isnumb prop 1 if child number flag 1 gener express child node gener express child get next node cfw add op code els boolean child of arithmet is arithmet node parent gener express child node if is arithmet node child add object to doubl gener express child get next node if is arithmet node child get next add object to doubl cfw add op code if child of arithmet add doubl wrap 
privat void visit bit op node node int type node child int child number flag node get int prop node isnumb prop 1 gener express child node special case ursh work with the target arg as a long so that we can return a 32 bit unsign valu and call to uint32 instead of to int32 if type token ursh add script runtim invok to uint32 ljava lang object j gener express child get next node add script runtim invok to int32 ljava lang object i look like we need to explicitli mask the shift to 5 bit lushr take 6 bit cfw add push 31 cfw add byte code iand cfw add byte code lushr cfw add byte code l2d add doubl wrap return if child number flag 1 add script runtim invok to int32 ljava lang object i gener express child get next node add script runtim invok to int32 ljava lang object i els add script runtim invok to int32 d i gener express child get next node add script runtim invok to int32 d i switch type case token bitor cfw add byte code ior break case token bitxor cfw add byte code ixor break case token bitand cfw add byte code iand break case token rsh cfw add byte code ishr break case token lsh cfw add byte code ishl break default throw codegen bad tree cfw add byte code i2d if child number flag 1 add doubl wrap 
privat int node is direct call paramet node node if node get type token getvar in direct call function it forc object paramet int var index fn current get var index node if fn current is paramet var index return var regist var index return 1 
privat boolean var is direct call paramet int var index return fn current is paramet var index in direct call function it forc object paramet 
privat void gen simpl compar int type int true goto int fals goto if true goto 1 throw codegen bad tree switch type case token le cfw add byte code dcmpg cfw add byte code ifl true goto break case token ge cfw add byte code dcmpl cfw add byte code ifg true goto break case token lt cfw add byte code dcmpg cfw add byte code iflt true goto break case token gt cfw add byte code dcmpl cfw add byte code ifgt true goto break default throw codegen bad tree if fals goto 1 cfw add byte code goto fals goto 
privat void visit if jump rel op node node node child int true goto int fals goto if true goto 1 fals goto 1 throw codegen bad tree int type node get type node r child child get next if type token instanceof type token in gener express child node gener express r child node cfw add aload context local add script runtim invok type token instanceof instanc of in ljava lang object ljava lang object lorg mozilla javascript context z cfw add byte code ifn true goto cfw add byte code goto fals goto return int child number flag node get int prop node isnumb prop 1 int left dcp regist node is direct call paramet child int right dcp regist node is direct call paramet r child if child number flag 1 forc numer context on both paramet and optim direct call case as optim current doe not handl it if child number flag node right left alreadi ha number content gener express child node els if left dcp regist 1 dcp load as number left dcp regist els gener express child node add object to doubl if child number flag node left right alreadi ha number content gener express r child node els if right dcp regist 1 dcp load as number right dcp regist els gener express r child node add object to doubl gen simpl compar type true goto fals goto els if left dcp regist 1 right dcp regist 1 gener code to dynam check for number content if both operand ar dcp short stack cfw get stack top int left is not number cfw acquir label cfw add aload left dcp regist cfw add byte code getstat java lang void type ljava lang class cfw add byte code if acmpn left is not number cfw add dload left dcp regist 1 dcp load as number right dcp regist gen simpl compar type true goto fals goto if stack cfw get stack top throw codegen bad tree cfw mark label left is not number int right is not number cfw acquir label cfw add aload right dcp regist cfw add byte code getstat java lang void type ljava lang class cfw add byte code if acmpn right is not number cfw add aload left dcp regist add object to doubl cfw add dload right dcp regist 1 gen simpl compar type true goto fals goto if stack cfw get stack top throw codegen bad tree cfw mark label right is not number load both regist as object to call gener cmp cfw add aload left dcp regist cfw add aload right dcp regist els gener express child node gener express r child node if type token ge type token gt cfw add byte code swap string routin type token lt type token gt cmp lt cmp le add script runtim invok routin ljava lang object ljava lang object z cfw add byte code ifn true goto cfw add byte code goto fals goto 
privat void visit if jump eq op node node node child int true goto int fals goto if true goto 1 fals goto 1 throw codegen bad tree short stack initi cfw get stack top int type node get type node r child child get next optim if on of operand is null if child get type token null r child get type token null eq is symmetr in thi case if child get type token null child r child gener express child node if type token sheq type token shne int test code type token sheq byte code ifnul byte code ifnonnul cfw add test code true goto els if type token eq swap fals true target for if type token ne throw codegen bad tree int tmp true goto true goto fals goto fals goto tmp cfw add byte code dup int undef check label cfw acquir label cfw add byte code ifnonnul undef check label short stack cfw get stack top cfw add byte code pop cfw add byte code goto true goto cfw mark label undef check label stack codegen push undefin cfw cfw add byte code if acmpeq true goto cfw add byte code goto fals goto els int child dcp regist node is direct call paramet child if child dcp regist 1 r child get type token to object node convert child r child get first child if convert child get type token number cfw add aload child dcp regist cfw add byte code getstat java lang void type ljava lang class int not number label cfw acquir label cfw add byte code if acmpn not number label cfw add dload child dcp regist 1 cfw add push convert child get doubl cfw add byte code dcmpl if type token eq cfw add byte code ifeq true goto els cfw add byte code ifn true goto cfw add byte code goto fals goto cfw mark label not number label fall thru into gener handl gener express child node gener express r child node string name int test code switch type case token eq name eq test code byte code ifn break case token ne name eq test code byte code ifeq break case token sheq name shallow eq test code byte code ifn break case token shne name shallow eq test code byte code ifeq break default throw codegen bad tree add script runtim invok name ljava lang object ljava lang object z cfw add test code true goto cfw add byte code goto fals goto if stack initi cfw get stack top throw codegen bad tree 
privat void visit set name node node node child string name node get first child get string while child null gener express child node child child get next cfw add aload context local cfw add aload variabl object local cfw add push name add script runtim invok set name lorg mozilla javascript scriptabl ljava lang object lorg mozilla javascript context lorg mozilla javascript scriptabl ljava lang string ljava lang object 
privat void visit get var node node if ha var in reg kit code bug int var index fn current get var index node short reg var regist var index if var is direct call paramet var index rememb that here the is number flag mean that we want to us the incom paramet in a number context so test the object type and convert the valu as necessari if node get int prop node isnumb prop 1 1 dcp load as number reg els dcp load as object reg els if fn current is number var var index cfw add dload reg els cfw add aload reg 
privat void visit set var node node node child boolean need valu if ha var in reg kit code bug int var index fn current get var index node gener express child get next node boolean is number node get int prop node isnumb prop 1 1 short reg var regist var index if var is direct call paramet var index if is number if need valu cfw add byte code dup2 cfw add aload reg cfw add byte code getstat java lang void type ljava lang class int is number label cfw acquir label int beyond cfw acquir label cfw add byte code if acmpeq is number label short stack cfw get stack top add doubl wrap cfw add astor reg cfw add byte code goto beyond cfw mark label is number label stack cfw add dstore reg 1 cfw mark label beyond els if need valu cfw add byte code dup cfw add astor reg els if is number cfw add dstore reg if need valu cfw add dload reg els cfw add astor reg if need valu cfw add aload reg 
privat void visit get prop node node node child gener express child node object node name child child get next gener express name child node the name for thi foo we call get object prop scriptabl which can skip some cast overhead int child type child get type if child type token thi name child get type token string cfw add aload context local add script runtim invok get object prop lorg mozilla javascript scriptabl ljava lang string lorg mozilla javascript context ljava lang object els cfw add aload context local add script runtim invok get object prop ljava lang object ljava lang string lorg mozilla javascript context ljava lang object 
privat void visit set prop int type node node node child node object child child gener express child node child child get next if type token setprop op cfw add byte code dup node name child child gener express child node child child get next if type token setprop op stack object object name object name object name cfw add byte code dup x1 for thi foo we call thi get which can skip some cast overhead if object child get type token thi name child get type token string cfw add aload context local add script runtim invok get object prop lorg mozilla javascript scriptabl ljava lang string lorg mozilla javascript context ljava lang object els cfw add aload context local add script runtim invok get object prop ljava lang object ljava lang string lorg mozilla javascript context ljava lang object gener express child node cfw add aload context local add script runtim invok set object prop ljava lang object ljava lang string ljava lang object lorg mozilla javascript context ljava lang object 
privat void visit set elem int type node node node child gener express child node child child get next if type token setelem op cfw add byte code dup gener express child node child child get next boolean index is number node get int prop node isnumb prop 1 1 if type token setelem op if index is number stack object object number object number object number cfw add byte code dup2 x1 cfw add aload context local add opt runtim invok get object index ljava lang object d lorg mozilla javascript context ljava lang object els stack object object index object object index object object index object cfw add byte code dup x1 cfw add aload context local add script runtim invok get object elem ljava lang object ljava lang object lorg mozilla javascript context ljava lang object gener express child node cfw add aload context local if index is number add script runtim invok set object index ljava lang object d ljava lang object lorg mozilla javascript context ljava lang object els add script runtim invok set object elem ljava lang object ljava lang object ljava lang object lorg mozilla javascript context ljava lang object 
privat void visit dot queri node node node child updat line number node gener express child node cfw add aload variabl object local add script runtim invok enter dot queri ljava lang object lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl cfw add astor variabl object local add push null pop with label in between to simplifi code for loop continu when it is necessari to pop the null result from updat dot queri cfw add byte code aconst null int queri loop start cfw acquir label cfw mark label queri loop start loop continu jump here cfw add byte code pop gener express child get next node add script runtim invok to boolean ljava lang object z cfw add aload variabl object local add script runtim invok updat dot queri z lorg mozilla javascript scriptabl ljava lang object cfw add byte code dup cfw add byte code ifnul queri loop start stack non null result of updat dot queri cfw add aload variabl object local add script runtim invok leav dot queri lorg mozilla javascript scriptabl lorg mozilla javascript scriptabl cfw add astor variabl object local 
privat int get local block regist node node node local block node node get prop node local block prop int local slot local block get exist int prop node local prop return local slot 
privat void dcp load as number int dcp regist cfw add aload dcp regist cfw add byte code getstat java lang void type ljava lang class int is number label cfw acquir label cfw add byte code if acmpeq is number label short stack cfw get stack top cfw add aload dcp regist add object to doubl int beyond cfw acquir label cfw add byte code goto beyond cfw mark label is number label stack cfw add dload dcp regist 1 cfw mark label beyond 
privat void dcp load as object int dcp regist cfw add aload dcp regist cfw add byte code getstat java lang void type ljava lang class int is number label cfw acquir label cfw add byte code if acmpeq is number label short stack cfw get stack top cfw add aload dcp regist int beyond cfw acquir label cfw add byte code goto beyond cfw mark label is number label stack cfw add dload dcp regist 1 add doubl wrap cfw mark label beyond 
privat void add goto node target int jumpcod int target label get target label target cfw add jumpcod target label 
privat void add object to doubl add script runtim invok to number ljava lang object d 
privat void add new object arrai int size if size 0 if it zero arg arrai 0 cfw add aload it zero arg arrai els cfw add byte code getstat org mozilla javascript script runtim empti arg ljava lang object els cfw add push size cfw add byte code anewarrai java lang object 
privat void add script runtim invok string method name string method signatur cfw add invok byte code invokestat org mozilla javascript script runtim method name method signatur 
privat void add opt runtim invok string method name string method signatur cfw add invok byte code invokestat org mozilla javascript optim opt runtim method name method signatur 
privat void add jump boolean wrap int true label int fals label cfw mark label fals label int skip cfw acquir label cfw add byte code getstat java lang boolean fals ljava lang boolean cfw add byte code goto skip cfw mark label true label cfw add byte code getstat java lang boolean true ljava lang boolean cfw mark label skip cfw adjust stack top 1 onli have 1 of true fals 
privat void add doubl wrap add opt runtim invok wrap doubl d ljava lang doubl 
privat short get new word pair local short result first free local while true if result max local 1 break if local result local result 1 break result if result max local 1 local result true local result 1 true if result first free local for int i first free local 2 i max local i if local i first free local short i if local max first free local local max first free local return result els return result throw context report runtim error program too complex out of local 
privat short get new word local short result first free local local result true for int i first free local 1 i max local i if local i first free local short i if local max first free local local max first free local return result throw context report runtim error program too complex out of local 
privat void releas wordpair local short local if local first free local first free local local local local fals local local 1 fals 
privat void releas word local short local if local first free local first free local local local local fals 
static void init scriptabl scope boolean seal nativ date obj new nativ date set the valu of the prototyp date to na n invalid date obj date script runtim na n obj export as jsclass max prototyp id scope seal 
privat nativ date if thi time zone null j u time zone is synchron so set class static from it should be ok thi time zone java util time zone get default local tza thi time zone get raw offset 
public string get class name return date 
public object get default valu class type hint if type hint null type hint script runtim string class return super get default valu type hint 
doubl get jstime valu return date 
protect void fill constructor properti id function object ctor add id function properti ctor date tag constructor id now now 0 add id function properti ctor date tag constructor id pars pars 1 add id function properti ctor date tag constructor id utc utc 1 super fill constructor properti ctor 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 0 s to string break case id to time string ariti 0 s to time string break case id to date string ariti 0 s to date string break case id to local string ariti 0 s to local string break case id to local time string ariti 0 s to local time string break case id to local date string ariti 0 s to local date string break case id to utcstr ariti 0 s to utcstr break case id to sourc ariti 0 s to sourc break case id valu of ariti 0 s valu of break case id get time ariti 0 s get time break case id get year ariti 0 s get year break case id get full year ariti 0 s get full year break case id get utcful year ariti 0 s get utcful year break case id get month ariti 0 s get month break case id get utcmonth ariti 0 s get utcmonth break case id get date ariti 0 s get date break case id get utcdat ariti 0 s get utcdat break case id get dai ariti 0 s get dai break case id get utcdai ariti 0 s get utcdai break case id get hour ariti 0 s get hour break case id get utchour ariti 0 s get utchour break case id get minut ariti 0 s get minut break case id get utcminut ariti 0 s get utcminut break case id get second ariti 0 s get second break case id get utcsecond ariti 0 s get utcsecond break case id get millisecond ariti 0 s get millisecond break case id get utcmillisecond ariti 0 s get utcmillisecond break case id get timezon offset ariti 0 s get timezon offset break case id set time ariti 1 s set time break case id set millisecond ariti 1 s set millisecond break case id set utcmillisecond ariti 1 s set utcmillisecond break case id set second ariti 2 s set second break case id set utcsecond ariti 2 s set utcsecond break case id set minut ariti 3 s set minut break case id set utcminut ariti 3 s set utcminut break case id set hour ariti 4 s set hour break case id set utchour ariti 4 s set utchour break case id set date ariti 1 s set date break case id set utcdat ariti 1 s set utcdat break case id set month ariti 2 s set month break case id set utcmonth ariti 2 s set utcmonth break case id set full year ariti 3 s set full year break case id set utcful year ariti 3 s set utcful year break case id set year ariti 1 s set year break default throw new illeg argument except string valu of id init prototyp method date tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag date tag return super exec id call f cx scope thi obj arg int id f method id switch id case constructor id now return script runtim wrap number now case constructor id pars string data str script runtim to string arg 0 return script runtim wrap number date pars string data str case constructor id utc return script runtim wrap number js static function utc arg case id constructor if call as a function just return a string repres the current time if thi obj null return date format now id to string return js constructor arg the rest of date prototyp method requir thi obj to be date if thi obj instanceof nativ date throw incompat call error f nativ date real thi nativ date thi obj doubl t real thi date switch id case id to string case id to time string case id to date string if t t return date format t id return js na n date str case id to local string case id to local time string case id to local date string if t t return to local helper t id return js na n date str case id to utcstr if t t return js to utcstr t return js na n date str case id to sourc return new date script runtim to string t case id valu of case id get time return script runtim wrap number t case id get year case id get full year case id get utcful year if t t if id id get utcful year t local time t t year from time t if id id get year if cx ha featur context featur non ecma get year if 1900 t t 2000 t 1900 els t 1900 return script runtim wrap number t case id get month case id get utcmonth if t t if id id get month t local time t t month from time t return script runtim wrap number t case id get date case id get utcdat if t t if id id get date t local time t t date from time t return script runtim wrap number t case id get dai case id get utcdai if t t if id id get dai t local time t t week dai t return script runtim wrap number t case id get hour case id get utchour if t t if id id get hour t local time t t hour from time t return script runtim wrap number t case id get minut case id get utcminut if t t if id id get minut t local time t t min from time t return script runtim wrap number t case id get second case id get utcsecond if t t if id id get second t local time t t sec from time t return script runtim wrap number t case id get millisecond case id get utcmillisecond if t t if id id get millisecond t local time t t ms from time t return script runtim wrap number t case id get timezon offset if t t t t local time t ms per minut return script runtim wrap number t case id set time t time clip script runtim to number arg 0 real thi date t return script runtim wrap number t case id set millisecond case id set utcmillisecond case id set second case id set utcsecond case id set minut case id set utcminut case id set hour case id set utchour t make time t arg id real thi date t return script runtim wrap number t case id set date case id set utcdat case id set month case id set utcmonth case id set full year case id set utcful year t make date t arg id real thi date t return script runtim wrap number t case id set year doubl year script runtim to number arg 0 if year year doubl is infinit year t script runtim na n els if t t t 0 els t local time t if year 0 year 99 year 1900 doubl dai make dai year month from time t date from time t t make date dai time within dai t t intern utc t t time clip t real thi date t return script runtim wrap number t default throw new illeg argument except string valu of id 
privat static final doubl ms per minut second per minut ms per second privat static doubl dai doubl t return math floor t ms per dai 
privat static doubl time within dai doubl t doubl result result t ms per dai if result 0 result ms per dai return result 
privat static boolean is leap year int year return year 4 0 year 100 0 year 400 0 
privat static doubl dai from year doubl y return 365 y 1970 math floor y 1969 4 0 math floor y 1901 100 0 math floor y 1601 400 0 
privat static doubl time from year doubl y return dai from year y ms per dai 
privat static int year from time doubl t int lo int math floor t ms per dai 366 1970 int hi int math floor t ms per dai 365 1970 int mid abov doesn t work for neg date if hi lo int temp lo lo hi hi temp us a simpl binari search algorithm to find the right year thi seem like brute forc but the comput of hi and lo year abov land within on year of the correct answer for year within a thousand year of 1970 the loop below onli requir six iter for year 270000 while hi lo mid hi lo 2 if time from year mid t hi mid 1 els lo mid 1 if time from year lo t return mid return lo 
privat static boolean in leap year doubl t return is leap year year from time t 
privat static doubl dai from month int m int year int dai m 30 if m 7 dai m 2 1 els if m 2 dai m 1 2 1 els dai m if m 2 is leap year year dai return dai 
privat static int month from time doubl t int year year from time t int d int dai t dai from year year d 31 28 if d 0 return d 28 0 1 if is leap year year if d 0 return 1 29 februari d d date count from 1 march int estim d 30 approx number of month sinc march int mstart switch estim case 0 return 2 case 1 mstart 31 break case 2 mstart 31 30 break case 3 mstart 31 30 31 break case 4 mstart 31 30 31 30 break case 5 mstart 31 30 31 30 31 break case 6 mstart 31 30 31 30 31 31 break case 7 mstart 31 30 31 30 31 31 30 break case 8 mstart 31 30 31 30 31 31 30 31 break case 9 mstart 31 30 31 30 31 31 30 31 30 break case 10 return 11 late decemb default throw kit code bug if d mstart then real month sinc march estim 1 return d mstart estim 2 estim 1 
privat static int date from time doubl t int year year from time t int d int dai t dai from year year d 31 28 if d 0 return d 28 d 31 28 1 d 28 1 if is leap year year if d 0 return 29 29 februari d d date count from 1 march int mdai mstart switch d 30 approx number of month sinc march case 0 return d 1 case 1 mdai 31 mstart 31 break case 2 mdai 30 mstart 31 30 break case 3 mdai 31 mstart 31 30 31 break case 4 mdai 30 mstart 31 30 31 30 break case 5 mdai 31 mstart 31 30 31 30 31 break case 6 mdai 31 mstart 31 30 31 30 31 31 break case 7 mdai 30 mstart 31 30 31 30 31 31 30 break case 8 mdai 31 mstart 31 30 31 30 31 31 30 31 break case 9 mdai 30 mstart 31 30 31 30 31 31 30 31 30 break case 10 return d 31 30 31 30 31 31 30 31 30 1 late decemb default throw kit code bug d mstart if d 0 wrong estim sfhift to previou month d mdai return d 1 
privat static int week dai doubl t doubl result result dai t 4 result result 7 if result 0 result 7 return int result 
privat static doubl now return doubl system current time milli 
privat final static boolean tzo workaround fals privat static doubl daylight save ta doubl t anoth workaround the jre doesn t seem to know about dst befor year 1 ad so we map to equival date for the purpos of find dst to be safe we do thi for year outsid 1970 2038 if t 0 0 t 2145916800000 0 int year equival year year from time t doubl dai make dai year month from time t date from time t t make date dai time within dai t if tzo workaround date date new date long t if thi time zone in daylight time date return ms per hour els return 0 els us get offset if in daylight time is broken becaus it seem to work accept we don t switch over to it entir becaus it requir expens explod date argument and the api make it imposs to handl dst changeov cleanli hardcod the assumpt that the changeov alwai happen at 2 00 am t local tza hour from time t 2 ms per hour 0 int year year from time t doubl offset thi time zone get offset year 0 1 0 year month from time t date from time t week dai t int time within dai t if offset local tza 0 return ms per hour els return 0 return offset local tza 
privat static int equival year int year int dai int dai from year year 4 dai dai 7 if dai 0 dai 7 year and leap year on which jan 1 is a sundai mondai etc if is leap year year switch dai case 0 return 1984 case 1 return 1996 case 2 return 1980 case 3 return 1992 case 4 return 1976 case 5 return 1988 case 6 return 1972 els switch dai case 0 return 1978 case 1 return 1973 case 2 return 1974 case 3 return 1975 case 4 return 1981 case 5 return 1971 case 6 return 1977 unreach throw kit code bug 
privat static doubl local time doubl t return t local tza daylight save ta t 
privat static doubl intern utc doubl t return t local tza daylight save ta t local tza 
privat static int hour from time doubl t doubl result result math floor t ms per hour hour per dai if result 0 result hour per dai return int result 
privat static int min from time doubl t doubl result result math floor t ms per minut minut per hour if result 0 result minut per hour return int result 
privat static int sec from time doubl t doubl result result math floor t ms per second second per minut if result 0 result second per minut return int result 
privat static int ms from time doubl t doubl result result t ms per second if result 0 result ms per second return int result 
privat static doubl make time doubl hour doubl min doubl sec doubl ms return hour minut per hour min second per minut sec ms per second ms 
privat static doubl make dai doubl year doubl month doubl date year math floor month 12 month month 12 if month 0 month 12 doubl yeardai math floor time from year year ms per dai doubl monthdai dai from month int month int year return yeardai monthdai date 1 
privat static doubl make date doubl dai doubl time return dai ms per dai time 
privat static doubl time clip doubl d if d d d doubl posit infin d doubl neg infin math ab d half time domain return script runtim na n if d 0 0 return math floor d 0 els return math ceil d 0 
find utc time from given date no 1900 correct privat static doubl date msec from date doubl year doubl mon doubl mdai doubl hour doubl min doubl sec doubl msec doubl dai doubl time doubl result dai make dai year mon mdai time make time hour min sec msec result make date dai time return result 
privat static final int maxarg 7 privat static doubl js static function utc object arg doubl arrai new doubl maxarg int loop doubl d for loop 0 loop maxarg loop if loop arg length d script runtim to number arg loop if d d doubl is infinit d return script runtim na n arrai loop script runtim to integ arg loop els arrai loop 0 adjust 2 digit year into the 20th centuri if arrai 0 0 arrai 0 99 arrai 0 1900 if we got a 0 for date which is out of rang pretend it s a 1 so date utc 1972 5 work if arrai 2 1 arrai 2 1 d date msec from date arrai 0 arrai 1 arrai 2 arrai 3 arrai 4 arrai 5 arrai 6 d time clip d return d 
privat static doubl date pars string string s int year 1 int mon 1 int mdai 1 int hour 1 int min 1 int sec 1 char c 0 char si 0 int i 0 int n 1 doubl tzoffset 1 char prevc 0 int limit 0 boolean seenplusminu fals limit s length while i limit c s char at i i if c c c if i limit si s char at i if c 0 si si 9 prevc c continu if c comment int depth 1 while i limit c s char at i i if c depth els if c if depth 0 break continu if 0 c c 9 n c 0 while i limit 0 c s char at i c 9 n n 10 c 0 i allow tza befor the year so wed nov 05 21 49 11 gmt 0800 1997 work us of seenplusminu allow in tza so java no timezon style of gmt 4 30 work if prevc prevc year 0 make case below chang tzoffset seenplusminu true offset if n 24 n n 60 eg gmt 3 els n n 100 n 100 60 eg gmt 0430 if prevc plu mean east of gmt n n if tzoffset 0 tzoffset 1 return script runtim na n tzoffset n els if n 70 prevc mon 0 mdai 0 year 0 if year 0 return script runtim na n els if c c c i limit year n 100 n 1900 n els return script runtim na n els if c if hour 0 hour byte n els if min 0 min byte n els return script runtim na n els if c if mon 0 mon byte n 1 els if mdai 0 mdai byte n els return script runtim na n els if i limit c c c return script runtim na n els if seenplusminu n 60 handl gmt 3 30 if tzoffset 0 tzoffset n els tzoffset n els if hour 0 min 0 min byte n els if min 0 sec 0 sec byte n els if mdai 0 mdai byte n els return script runtim na n prevc 0 els if c c c c prevc c els int st i 1 while i limit c s char at i if a c c z a c c z break i int letter count i st if letter count 2 return script runtim na n us port code from jsdate c rather than the local specif date pars code from java to keep js and rhino consist is thi the right strategi string wtb am pm mondai tuesdai wednesdai thursdai fridai saturdai sundai januari februari march april mai june juli august septemb octob novemb decemb gmt ut utc est edt cst cdt mst mdt pst pdt int index 0 for int wtb offset 0 int wtb next wtb index of wtb offset if wtb next 0 return script runtim na n if wtb region match true wtb offset s st letter count break wtb offset wtb next 1 index if index 2 am pm count 12 30 am as 00 30 12 30 pm as 12 30 instead of blindli ad 12 if pm if hour 12 hour 0 return script runtim na n els if index 0 am if hour 12 hour 0 els pm if hour 12 hour 12 els if index 2 7 ignor week dai els if index 7 12 month if mon 0 mon index els return script runtim na n els index 12 timezon switch index case 0 gmt tzoffset 0 break case 1 ut tzoffset 0 break case 2 utc tzoffset 0 break case 3 est tzoffset 5 60 break case 4 edt tzoffset 4 60 break case 5 cst tzoffset 6 60 break case 6 cdt tzoffset 5 60 break case 7 mst tzoffset 7 60 break case 8 mdt tzoffset 6 60 break case 9 pst tzoffset 8 60 break case 10 pdt tzoffset 7 60 break default kit code bug if year 0 mon 0 mdai 0 return script runtim na n if sec 0 sec 0 if min 0 min 0 if hour 0 hour 0 doubl msec date msec from date year mon mdai hour min sec 0 if tzoffset 1 no time zone specifi have to us local return intern utc msec els return msec tzoffset ms per minut 
privat static string date format doubl t int method id string buffer result new string buffer 60 doubl local local time t tue oct 31 09 41 40 gmt 0800 pst 2000 tue oct 31 2000 09 41 40 gmt 0800 pst if method id id to time string append week dai name result week dai local result append append month name result month from time local result append append0pad uint result date from time local 2 result append int year year from time local if year 0 result append year year append0pad uint result year 4 if method id id to date string result append if method id id to date string append0pad uint result hour from time local 2 result append append0pad uint result min from time local 2 result append append0pad uint result sec from time local 2 offset from gmt in minut the offset includ daylight save if it appli int minut int math floor local tza daylight save ta t ms per minut map 510 minut to 0830 hour int offset minut 60 100 minut 60 if offset 0 result append gmt els result append gmt offset offset append0pad uint result offset 4 if time zone formatt null time zone formatt new java text simpl date format zzz find an equival year befor get the timezon comment see daylight save ta if t 0 0 t 2145916800000 0 int equiv equival year year from time local doubl dai make dai equiv month from time t date from time t t make date dai time within dai t result append java util date date new date long t result append time zone formatt format date result append return result to string 
the javascript constructor privat static object js constructor object arg nativ date obj new nativ date if call as a constructor with no arg return a new date with the current time if arg length 0 obj date now return obj if call with just on arg if arg length 1 object arg0 arg 0 if arg0 instanceof scriptabl arg0 scriptabl arg0 get default valu null doubl date if arg0 instanceof string it s a string pars it date date pars string string arg0 els if it s not a string us it as a millisecond date date script runtim to number arg0 obj date time clip date return obj multipl argument year month dai etc doubl arrai new doubl maxarg int loop doubl d for loop 0 loop maxarg loop if loop arg length d script runtim to number arg loop if d d doubl is infinit d obj date script runtim na n return obj arrai loop script runtim to integ arg loop els arrai loop 0 adjust 2 digit year into the 20th centuri if arrai 0 0 arrai 0 99 arrai 0 1900 if we got a 0 for date which is out of rang pretend it s a 1 if arrai 2 1 arrai 2 1 doubl dai make dai arrai 0 arrai 1 arrai 2 doubl time make time arrai 3 arrai 4 arrai 5 arrai 6 time make date dai time time intern utc time obj date time clip time return obj 
privat static string to local helper doubl t int method id java text date format formatt switch method id case id to local string if local date time formatt null local date time formatt date format get date time instanc date format long date format long formatt local date time formatt break case id to local time string if local time formatt null local time formatt date format get time instanc date format long formatt local time formatt break case id to local date string if local date formatt null local date formatt date format get date instanc date format long formatt local date formatt break default formatt null unreach return formatt format new date long t 
privat static string js to utcstr doubl date string buffer result new string buffer 60 append week dai name result week dai date result append append0pad uint result date from time date 2 result append append month name result month from time date result append int year year from time date if year 0 result append year year append0pad uint result year 4 result append append0pad uint result hour from time date 2 result append append0pad uint result min from time date 2 result append append0pad uint result sec from time date 2 result append gmt return result to string 
privat static void append0pad uint string buffer sb int i int min width if i 0 kit code bug int scale 1 min width if i 10 if i 1000 1000 1000 for int new scale scale 10 if i new scale break min width scale new scale els separ case not to check against 10 10 9 overflow min width 9 scale 1000 1000 1000 while min width 0 sb append 0 min width while scale 1 sb append char 0 i scale i scale scale 10 sb append char 0 i 
privat static void append month name string buffer sb int index take advantag of the fact that all month abbrevi have the same length to minim amount of string runtim ha to keep in memori string month jan feb mar apr mai jun jul aug sep oct nov dec index 3 for int i 0 i 3 i sb append month char at index i 
privat static void append week dai name string buffer sb int index string dai sun mon tue wed thu fri sat index 3 for int i 0 i 3 i sb append dai char at index i 
privat static doubl make time doubl date object arg int method id int maxarg boolean local true switch method id case id set utcmillisecond local fals fallthrough case id set millisecond maxarg 1 break case id set utcsecond local fals fallthrough case id set second maxarg 2 break case id set utcminut local fals fallthrough case id set minut maxarg 3 break case id set utchour local fals fallthrough case id set hour maxarg 4 break default kit code bug maxarg 0 int i doubl conv new doubl 4 doubl hour min sec msec doubl lorutim local or utc version of date doubl time doubl result just return na n if the date is alreadi na n if date date return date satisfi the ecma rule that if a function is call with fewer argument than the specifi formal argument the remain argument ar set to undefin seem like all the date set whatev function in ecma ar onli vararg beyond the first argument thi should be set to undefin if it s not given thi mean that d new date d set millisecond return na n blech if arg length 0 arg script runtim pad argument arg 1 for i 0 i arg length i maxarg i conv i script runtim to number arg i limit check that happen in make time in ecma if conv i conv i doubl is infinit conv i return script runtim na n conv i script runtim to integ conv i if local lorutim local time date els lorutim date i 0 int stop arg length if maxarg 4 i stop hour conv i els hour hour from time lorutim if maxarg 3 i stop min conv i els min min from time lorutim if maxarg 2 i stop sec conv i els sec sec from time lorutim if maxarg 1 i stop msec conv i els msec ms from time lorutim time make time hour min sec msec result make date dai lorutim time if local result intern utc result date time clip result return date 
privat static doubl make date doubl date object arg int method id int maxarg boolean local true switch method id case id set utcdat local fals fallthrough case id set date maxarg 1 break case id set utcmonth local fals fallthrough case id set month maxarg 2 break case id set utcful year local fals fallthrough case id set full year maxarg 3 break default kit code bug maxarg 0 int i doubl conv new doubl 3 doubl year month dai doubl lorutim local or utc version of date doubl result see arg pad comment in make time if arg length 0 arg script runtim pad argument arg 1 for i 0 i arg length i maxarg i conv i script runtim to number arg i limit check that happen in make date in ecma if conv i conv i doubl is infinit conv i return script runtim na n conv i script runtim to integ conv i return na n if date is na n and we re not set the year if we ar us 0 as the time if date date if arg length 3 return script runtim na n els lorutim 0 els if local lorutim local time date els lorutim date i 0 int stop arg length if maxarg 3 i stop year conv i els year year from time lorutim if maxarg 2 i stop month conv i els month month from time lorutim if maxarg 1 i stop dai conv i els dai date from time lorutim dai make dai year month dai dai within year result make date dai time within dai lorutim if local result intern utc result date time clip result return date 
protect int find prototyp id string s int id gener last updat 2004 03 17 13 33 23 cet l0 id 0 string x null int c l switch s length case 6 x get dai id id get dai break l case 7 switch s char at 3 case d c s char at 0 if c g x get date id id get date els if c s x set date id id set date break l case t c s char at 0 if c g x get time id id get time els if c s x set time id id set time break l case y c s char at 0 if c g x get year id id get year els if c s x set year id id set year break l case u x valu of id id valu of break l break l case 8 switch s char at 3 case h c s char at 0 if c g x get hour id id get hour els if c s x set hour id id set hour break l case m c s char at 0 if c g x get month id id get month els if c s x set month id id set month break l case o x to sourc id id to sourc break l case t x to string id id to string break l break l case 9 x get utcdai id id get utcdai break l case 10 c s char at 3 if c m c s char at 0 if c g x get minut id id get minut els if c s x set minut id id set minut els if c s c s char at 0 if c g x get second id id get second els if c s x set second id id set second els if c u c s char at 0 if c g x get utcdat id id get utcdat els if c s x set utcdat id id set utcdat break l case 11 switch s char at 3 case f c s char at 0 if c g x get full year id id get full year els if c s x set full year id id set full year break l case m x to gmtstring id id to gmtstring break l case t x to utcstr id id to utcstr break l case u c s char at 0 if c g c s char at 9 if c r x get utchour id id get utchour els if c t x get utcmonth id id get utcmonth els if c s c s char at 9 if c r x set utchour id id set utchour els if c t x set utcmonth id id set utcmonth break l case s x constructor id id constructor break l break l case 12 c s char at 2 if c d x to date string id id to date string els if c t x to time string id id to time string break l case 13 c s char at 0 if c g c s char at 6 if c m x get utcminut id id get utcminut els if c s x get utcsecond id id get utcsecond els if c s c s char at 6 if c m x set utcminut id id set utcminut els if c s x set utcsecond id id set utcsecond break l case 14 c s char at 0 if c g x get utcful year id id get utcful year els if c s x set utcful year id id set utcful year els if c t x to local string id id to local string break l case 15 c s char at 0 if c g x get millisecond id id get millisecond els if c s x set millisecond id id set millisecond break l case 17 x get timezon offset id id get timezon offset break l case 18 c s char at 0 if c g x get utcmillisecond id id get utcmillisecond els if c s x set utcmillisecond id id set utcmillisecond els if c t c s char at 8 if c d x to local date string id id to local date string els if c t x to local time string id id to local time string break l if x null x s x equal s id 0 gener return id 
main entri point process argument as would a normal java program also creat a new context and associ it with the current thread then set up the execut environ and begin to execut script public static void main string arg context cx context enter try set version to java script1 2 so that we get object liter style print instead of object object cx set languag version context version 1 2 initi the standard object object function etc thi must be done befor script can be execut scriptabl scope cx init standard object now we can evalu a script let s creat a new object us the object liter notat object result cx evalu string scope obj a 1 b x y my sourc 1 null scriptabl obj scriptabl scope get obj scope should print obj result sinc the result of an assign express is the valu that wa assign system out println obj obj result result should print obj a 1 system out println obj a obj get a obj scriptabl b scriptabl obj get b obj should print obj b 0 x system out println obj b 0 b get 0 b should print obj b 1 y system out println obj b 1 b get 1 b should print a 1 b x y function fn function scriptabl object get properti obj to string system out println fn call cx scope obj new object 0 final context exit 
string script text iproxi int type thi type type 
public object run context cx if type process file process file cx arg els if type eval inlin script script script load script from sourc cx script text command 1 null if script null evalu script script cx get global els throw kit code bug return null 
public void quit context cx int exit code if type system exit system exit exit code return throw kit code bug 
main entri point process argument as would a normal java program also creat a new context and associ it with the current thread then set up the execut environ and begin to execut script public static void main string arg try if boolean get boolean rhino us java polici secur init java polici secur support catch secur except ex ex print stack trace system err int result exec arg if result 0 system exit result 
execut the given argument but don t system exit at the end public static int exec string orig arg error report new tool error report fals global get err shell context factori set error report error report string arg process option orig arg if process stdin file list add element null if global initi global init shell context factori iproxi iproxi new iproxi iproxi process file iproxi arg arg shell context factori call iproxi return exit code 
static void process file context cx string arg defin argument arrai in the top level object need to alloc new arrai sinc new arrai requir instanc of exactli object not object subclass object arrai new object arg length system arraycopi arg 0 arrai 0 arg length scriptabl arg obj cx new arrai global arrai global defin properti argument arg obj scriptabl object dontenum for int i 0 i file list size i process sourc cx string file list element at i 
public static global get global return global 
pars argument public static string process option string arg string usag error good usag for int i 0 i if i arg length return new string 0 string arg arg i if arg start with process stdin fals file list add element arg string result new string arg length i 1 system arraycopi arg i 1 result 0 arg length i 1 return result if arg equal version if i arg length usag error arg break good usag int version try version integ pars int arg i catch number format except ex usag error arg i break good usag if context is valid languag version version usag error arg i break good usag shell context factori set languag version version continu if arg equal opt arg equal o if i arg length usag error arg break good usag int opt try opt integ pars int arg i catch number format except ex usag error arg i break good usag if opt 2 compat with cocoon rhino fork opt 1 els if context is valid optim level opt usag error arg i break good usag shell context factori set optim level opt continu if arg equal strict shell context factori set strict mode true continu if arg equal e process stdin fals if i arg length usag error arg break good usag if global initi global init shell context factori iproxi iproxi new iproxi iproxi eval inlin script iproxi script text arg i shell context factori call iproxi continu if arg equal w error report set is report warn true continu if arg equal f process stdin fals if i arg length usag error arg break good usag file list add element arg i equal null arg i continu if arg equal sealedlib global set seal std lib true continu usag error arg break good usag print usag messag global get out println tool error report get messag msg shell usag usag error system exit 1 return null 
privat static void init java polici secur support throwabl ex obj try class cl class for name org mozilla javascript tool shell java polici secur secur impl secur proxi cl new instanc secur control init global secur impl return catch class not found except ex ex obj ex catch illeg access except ex ex obj ex catch instanti except ex ex obj ex catch linkag error ex ex obj ex throw kit init caus new illeg state except can not load secur support ex obj ex obj 
evalu java script sourc param cx the current context param filenam the name of the file to compil or null for interact mode public static void process sourc context cx string filenam if filenam null filenam equal print stream ps global get err if filenam null print implement version ps println cx get implement version us the interpret for interact input cx set optim level 1 buffer reader in new buffer reader new input stream reader global get in int lineno 1 boolean hit eof fals while hit eof int startlin lineno if filenam null ps print js ps flush string sourc collect line of sourc to compil while true string newlin try newlin in read line catch ioexcept ioe ps println ioe to string break if newlin null hit eof true break sourc sourc newlin n lineno if cx string is compil unit sourc break script script load script from sourc cx sourc stdin lineno null if script null object result evalu script script cx global if result context get undefin valu try ps println context to string result catch rhino except rex tool error report report except cx get error report rex nativ arrai h global histori h put int h get length h sourc ps println els process file cx global filenam system gc 
public static void process file context cx scriptabl scope string filenam if secur impl null process file secur cx scope filenam null els secur impl call process file secur cx scope filenam 
static void process file secur context cx scriptabl scope string path object secur domain script script if path end with class script load compil script cx path secur domain els string sourc string read file or url path true if sourc null exit code exitcod file not found return support the execut script syntax if the first line begin with a treat the whole line as a comment if sourc length 0 sourc char at 0 for int i 1 i sourc length i int c sourc char at i if c n c r sourc sourc substr i break script load script from sourc cx sourc path 1 secur domain if script null evalu script script cx scope 
public static script load script from sourc context cx string script sourc string path int lineno object secur domain try return cx compil string script sourc path lineno secur domain catch evalu except ee alreadi print messag exit code exitcod runtim error catch rhino except rex tool error report report except cx get error report rex exit code exitcod runtim error catch virtual machin error ex treat stack overflow and out of memori as runtim error ex print stack trace string msg tool error report get messag msg uncaught jsexcept ex to string exit code exitcod runtim error context report error msg return null 
privat static script load compil script context cx string path object secur domain byte data byte read file or url path fals if data null exit code exitcod file not found return null xxx for now extract class name of compil script from path instead of pars class byte int name start path last index of if name start 0 name start 0 els name start int name end path last index of if name end name start doe not exist in path name end 0 or it come befor name start name end path length string name path substr name start name end try gener class loader loader secur control creat loader cx get applic class loader secur domain class clazz loader defin class name data loader link class clazz if script class is assign from clazz throw context report runtim error msg must implement script return script clazz new instanc catch rhino except rex tool error report report except cx get error report rex exit code exitcod runtim error catch illeg access except iaex exit code exitcod runtim error context report error iaex to string catch instanti except inex exit code exitcod runtim error context report error inex to string return null 
public static object evalu script script script context cx scriptabl scope try return script exec cx scope catch rhino except rex tool error report report except cx get error report rex exit code exitcod runtim error catch virtual machin error ex treat stack overflow and out of memori as runtim error ex print stack trace string msg tool error report get messag msg uncaught jsexcept ex to string exit code exitcod runtim error context report error msg return context get undefin valu 
public static input stream get in return get global get in 
public static void set in input stream in get global set in in 
public static print stream get out return get global get out 
public static void set out print stream out get global set out out 
public static print stream get err return get global get err 
public static void set err print stream err get global set err err 
read file or url specifi by tt path tt return file or url content as tt byte tt or as tt string tt if tt convert to string tt is true privat static object read file or url string path boolean convert to string url url null assum path is url if it contain dot and there ar at least 2 charact in the protocol part the later allow under window to interpret path with driver letter as file not url if path index of 2 try url new url path catch malform urlexcept ex input stream is null int capac hint 0 if url null file file new file path capac hint int file length try is new file input stream file catch ioexcept ex context report error tool error report get messag msg couldnt open path return null els try urlconnect uc url open connect is uc get input stream capac hint uc get content length ignor insan valu for content length if capac hint 1 20 capac hint 1 catch ioexcept ex context report error tool error report get messag msg couldnt open url url to string ex to string return null if capac hint 0 capac hint 4096 byte data try try data kit read stream is capac hint final is close catch ioexcept ex context report error ex to string return null object result if convert to string result data els convert to string us the default encod xxx us charset argument of content type if url result new string data return result 
public class except 001 extend live connect test public except 001 super 
public static void main string arg except 001 test new except 001 test start 
public void execut test string result no except thrown try the follow statement should throw a java script except sinc foo is not defin global eval foo bar 999 catch except e if e instanceof jsexcept result jsexcept thrown els result some random except thrown file except e to string e print stack trace final add test case global eval foo bar 999 should throw a java script except jsexcept thrown result file except 
public class data type 006 extend live connect test public data type 006 super 
public static void main string arg data type 006 test new data type 006 test start 
public void execut test do method test dt get boolean object java lang boolean object new boolean data type class pub static final boolean do method test dt get boolean java lang boolean object new boolean data type class pub static final boolean do method test dt get byte java lang doubl object new doubl data type class pub static final byte do method test dt get byte object java lang byte object new byte data type class pub static final byte do method test dt get short java lang doubl object new doubl data type class pub static final short do method test dt get short object java lang short object new short data type class pub static final short do method test dt get integ java lang doubl object new doubl data type class pub static final int do method test dt get integ object java lang integ object new integ data type class pub static final int do method test dt get long java lang doubl object new doubl data type class pub static final long do method test dt get long object java lang long object new long data type class pub static final long do method test dt get float java lang doubl object new doubl data type class pub static final float do method test dt get float object java lang float object new float data type class pub static final float do method test dt get doubl java lang doubl object new doubl data type class pub static final doubl do method test dt get doubl object java lang doubl object new doubl data type class pub static final doubl do method test dt get char java lang doubl object new doubl data type class pub static final char do method test dt get charact java lang charact object new charact data type class pub static final char do method test dt get string object java lang string object new string data type class pub static final string 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void do method test string method string class name object valu get public method method class name valu 
set the valu of a java script variabl to a java valu get the valu of that variabl public void get public method string method string class name object valu string descript method string except null object actual null string expect null check the class try actual global eval method expect class for name class name get name catch class not found except e catch except e except e to string might want to do all the interest stuff here in a try catch block add test case descript get class expect actual get class get name except add test case descript valu to string true actual equal valu except add test case actual to string equal valu to string true actual to string equal valu to string except 
try to set the valu of a public static field us jsobject set member which should succe public void set public field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try befor global eval descript need to quot string if class name equal java lang string global eval descript new valu to string els global eval descript new valu after global eval descript expect class for name class name get name catch except e except e to string add test case global eval descript new valu to string after global eval descript after get class get name expect after get class get name except add test case after to string equal new valu to string true after equal new valu except add test case after to string equal new valu to string true after to string equal new valu to string except assign a valu to a public static final java field the assign should fail the valu should not chang but there should be no error messag public void set public field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try expect class for name class name get name catch except e except e to string befor global eval descript global eval descript new valu to string after global eval descript check the class of the result which should be the same as expect add test case descript get class expect after get class get name except the valu of the actual result should be the origin valu add test case descript valu to string true after equal valu except the string represent of the actual result should be the same as the string represent of the expect valu add test case after to string equal valu to string true after to string equal valu to string except get member field should return the same valu befor and after the assign add test case befor equal after true befor equal after except 
annot list v new vector 
void add xml xscript annot n v add n 
xml xscript annot item int index return xml xscript annot v get index 
void remov int index v remov index 
int length return v size 
xmllist xmllib impl lib super lib lib xml list prototyp anno new annot list 
param input object xmllist xmllib impl lib object input object super lib lib xml list prototyp string frag if input object null input object instanceof undefin frag els if input object instanceof xml xml xml xml input object anno new annot list anno add xml get annot els if input object instanceof xmllist xmllist xmll xmllist input object anno new annot list for int i 0 i xmll anno length i anno add xmll anno item i els frag script runtim to string input object trim if frag start with frag frag frag fragment frag substr 2 if frag end with throw script runtim type error xml with anonym tag miss end anonym tag frag frag substr 0 frag length 3 fragment xml org xml xml creat from js lib frag now orphan the children and add them to our xmllist xmllist children xmllist org xml children anno new annot list for int i 0 i children anno length i copi here is so that thei ll be orphan parent will be undefin anno add xml children item i copi get annot 
param object param properti void set target xmlobject impl object javax xml namespac qname properti target object object target properti properti 
param index return xml get xml from annot int index xml ret val if index 0 index length xml xscript annot anno anno item index ret val xml get from annot lib anno els ret val null return ret val 
param index privat void intern remov from list int index anno remov index 
param index param xml void replac int index xml xml if index length annot list new anno list new annot list copi upto item to replac for int i 0 i index i new anno list add anno item i new anno list add xml get annot skip over old item we re go to replac we ve alreadi add new item on abov line for int i index 1 i length i new anno list add anno item i anno new anno list 
param index param xml privat void insert int index xml xml if index length annot list new anno list new annot list copi upto item to insert for int i 0 i index i new anno list add anno item i new anno list add xml get annot for int i index i length i new anno list add anno item i anno new anno list 
public string get class name return xmllist 
param index param start return public object get int index scriptabl start log get index index if index 0 index length return get xml from annot index els return scriptabl not found 
param name param start return boolean ha xmlproperti xmlname xml name boolean result fals ha now should return true if the properti would have result 0 or if it s a method name string name xml name local name if get properti list xml name length 0 get method name not found result true return result 
param index param start return public boolean ha int index scriptabl start return 0 index index length 
param name param valu void put xmlproperti xmlname xml name object valu log put properti name special case check for undefin and null if valu null valu null els if valu instanceof undefin valu undefin if length 1 throw script runtim type error assign to list with more that on item is not support els if length 0 secret sauc for super expando we set an element here and then add ourselv to our target if target object null target properti null target properti get local part equal add an empti element with our target properti name and then set it xml xml valu xml creat text element lib target properti add to list xml valu if xml name is attribut name set attribut xml name valu els xml xml xml item 0 xml put xmlproperti xml name valu updat the list with the new item at locat 0 replac 0 xml item 0 now add us to our parent xmlname name2 xmlname form properti target properti get namespac uri target properti get local part target object put xmlproperti name2 thi els throw script runtim type error assign to empti xmllist without target not support els if xml name is attribut name set attribut xml name valu els xml xml xml item 0 xml put xmlproperti xml name valu updat the list with the new item at locat 0 replac 0 xml item 0 
param name return object get xmlproperti xmlname name return get properti list name 
param index param valu public void put int index scriptabl start object valu object parent undefin instanc convert text into xml if need xmlobject xml valu special case check for undefin and null if valu null valu null els if valu instanceof undefin valu undefin if valu instanceof xmlobject xml valu xmlobject valu els if target properti null xml valu xml creat from js lib valu to string els xml valu xml creat text element lib target properti valu to string find the parent if index length parent item index parent els append parent parent if parent instanceof xml found parent alter doc xml xml parent xml parent if index length we re replac the the node xml xml node get xml from annot index if xml valu instanceof xml xml node replac all xml xml valu replac index xml node els if xml valu instanceof xmllist replac the first on and add the rest on the list xmllist list xmllist xml valu if list length 0 int last index ad xml node child index xml node replac all xml list item 0 replac index xml list item 0 for int i 1 i list length i xml parent insert child after xml parent get xml child last index ad list item i last index ad insert index i xml list item i els append xml parent append child xml valu add to list xml parent get xml child index els don t all have same parent no underli doc to alter if index length xml xml node xml get from annot lib anno item index if xml valu instanceof xml xml node replac all xml xml valu replac index xml node els if xml valu instanceof xmllist replac the first on and add the rest on the list xmllist list xmllist xml valu if list length 0 xml node replac all xml list item 0 replac index xml list item 0 for int i 1 i list length i insert index i xml list item i els add to list xml valu 
param name void delet xmlproperti xmlname name for int i 0 i length i xml xml get xml from annot i if xml token type xml cursor token type start xml delet xmlproperti name 
param index public void delet int index if index 0 index length xml xml get xml from annot index xml remov intern remov from list index 
return public object get id object enum obj if prototyp flag enum obj new object 0 els enum obj new object length for int i 0 i enum obj length i enum obj i new integ i return enum obj 
return public object get id for debug return get id 
xmllist will remov will delet all item in the list a set delet thi differ from the xmllist delet oper void remov int n len length for int i n len 1 i 0 i xml xml get xml from annot i if xml null xml remov intern remov from list i 
param index return xml item int index return anno null get xml from annot index xml creat empti xml lib 
param name param valu privat void set attribut xmlname xml name object valu for int i 0 i length i xml xml get xml from annot i xml set attribut xml name valu 
param to add void add to list object to add if to add instanceof undefin miss argument do noth return if to add instanceof xmllist xmllist xml src xmllist to add for int i 0 i xml src length i anno add xml xml src item i get annot els if to add instanceof xml anno add xml to add get annot els if to add instanceof xml xscript annot anno add xml xscript annot to add 
param to add xml add namespac namespac ns if length 1 return get xml from annot 0 add namespac ns els throw script runtim type error the add namespac method work onli on list contain on item 
param xml return xml append child object xml if length 1 return get xml from annot 0 append child xml els throw script runtim type error the append child method work onli on list contain on item 
param attr return xmllist attribut xmlname xml name xmllist result new xmllist lib for int i 0 i length i xml xml get xml from annot i result add to list xml attribut xml name return result 
return xmllist attribut xmllist result new xmllist lib for int i 0 i length i xml xml get xml from annot i result add to list xml attribut return result 
xmllist child long index xmllist result new xmllist lib for int i 0 i length i result add to list get xml from annot i child index return result 
xmllist child xmlname xml name xmllist result new xmllist lib for int i 0 i length i result add to list get xml from annot i child xml name return result 
return int child index if length 1 return get xml from annot 0 child index els throw script runtim type error the child index method work onli on list contain on item 
return xmllist children vector v new vector for int i 0 i length i xml xml get xml from annot i if xml null object o xml children if o instanceof xmllist xmllist child list xmllist o int c children child list length for int j 0 j c children j v add element child list item j xmllist all children new xmllist lib int sz v size for int i 0 i sz i all children add to list v get i return all children 
return xmllist comment xmllist result new xmllist lib for int i 0 i length i xml xml get xml from annot i result add to list xml comment return result 
param xml return boolean contain object xml boolean result fals for int i 0 i length i xml member get xml from annot i if member equival xml xml result true break return result 
return object copi xmllist result new xmllist lib for int i 0 i length i xml xml get xml from annot i result add to list xml copi return result 
return xmllist descend xmlname xml name xmllist result new xmllist lib for int i 0 i length i xml xml get xml from annot i result add to list xml descend xml name return result 
return object in scope namespac if length 1 return get xml from annot 0 in scope namespac els throw script runtim type error the in scope namespac method work onli on list contain on item 
param child param xml xml insert child after object child object xml if length 1 return get xml from annot 0 insert child after child xml els throw script runtim type error the insert child after method work onli on list contain on item 
param child param xml xml insert child befor object child object xml if length 1 return get xml from annot 0 insert child after child xml els throw script runtim type error the insert child befor method work onli on list contain on item 
return boolean ha own properti xmlname xml name boolean ha properti fals if prototyp flag string properti xml name local name ha properti 0 find prototyp id properti els ha properti get properti list xml name length 0 return ha properti 
return boolean ha complex content boolean complex content int length length if length 0 complex content fals els if length 1 complex content get xml from annot 0 ha complex content els complex content fals for int i 0 i length i xml next element get xml from annot i if next element token type xml cursor token type start complex content true break return complex content 
return boolean ha simpl content boolean simpl content int length length if length 0 simpl content true els if length 1 simpl content get xml from annot 0 ha simpl content els simpl content true for int i 0 i length i xml next element get xml from annot i if next element token type xml cursor token type start simpl content fals break return simpl content 
return int length int result 0 if anno null result anno length return result 
return string local name if length 1 return name local name els throw script runtim type error the local name method work onli on list contain on item 
return qname name if length 1 return get xml from annot 0 name els throw script runtim type error the name method work onli on list contain on item 
param prefix return object namespac string prefix if length 1 return get xml from annot 0 namespac prefix els throw script runtim type error the namespac method work onli on list contain on item 
return object namespac declar if length 1 return get xml from annot 0 namespac declar els throw script runtim type error the namespac declar method work onli on list contain on item 
return object node kind if length 1 return get xml from annot 0 node kind els throw script runtim type error the node kind method work onli on list contain on item 
void normal for int i 0 i length i get xml from annot i normal 
if list is empti return undefin if element have differ parent return undefin if thei all have the same parent return that parent return object parent object same parent undefin instanc if length 0 target object null target object instanceof xml same parent target object els for int i 0 i length i object curr parent get xml from annot i parent if i 0 set the first for the rest to compar to same parent curr parent els if same parent curr parent same parent undefin instanc break if everyth in the list is the same parent then return that as the parent return same parent 
param xml return xml prepend child object xml if length 1 return get xml from annot 0 prepend child xml els throw script runtim type error the prepend child method work onli on list contain on item 
return object process instruct xmlname xml name xmllist result new xmllist lib for int i 0 i length i xml xml get xml from annot i result add to list xml process instruct xml name return result 
param name return boolean properti is enumer object name long index if name instanceof integ index integ name int valu els if name instanceof number doubl x number name doubl valu index long x if doubl index x return fals if index 0 1 0 x 0 neg 0 return fals els string s script runtim to string name index script runtim test uint32str s return 0 index index length 
param ns xml remov namespac namespac ns if length 1 return get xml from annot 0 remov namespac ns els throw script runtim type error the remov namespac method work onli on list contain on item 
xml replac long index object xml if length 1 return get xml from annot 0 replac index xml els throw script runtim type error the replac method work onli on list contain on item 
param properti name param xml return xml replac xmlname xml name object xml if length 1 return get xml from annot 0 replac xml name xml els throw script runtim type error the replac method work onli on list contain on item 
param xml xml set children object xml if length 1 return get xml from annot 0 set children xml els throw script runtim type error the set children method work onli on list contain on item 
param name void set local name string local name if length 1 get xml from annot 0 set local name local name els throw script runtim type error the set local name method work onli on list contain on item 
param name void set name qname qname if length 1 get xml from annot 0 set name qname els throw script runtim type error the set name method work onli on list contain on item 
param ns void set namespac namespac ns if length 1 get xml from annot 0 set namespac ns els throw script runtim type error the set namespac method work onli on list contain on item 
return xmllist text xmllist result new xmllist lib for int i 0 i length i result add to list get xml from annot i text return result 
return public string to string if ha simpl content string buffer sb new string buffer for int i 0 i length i xml next get xml from annot i sb append next to string return sb to string els return to xmlstring 0 
string to sourc int indent xxx indent is ignor return to xmlstring 0 
return string to xmlstring int indent string buffer sb new string buffer for int i 0 i length i if i 0 sb append n sb append get xml from annot i to xmlstring indent return sb to string 
return object valu of return thi 
param target return boolean equival xml object target boolean result fals zero length list should equat to undefin if target instanceof undefin length 0 result true els if length 1 result get xml from annot 0 equival xml target els if target instanceof xmllist xmllist other list xmllist target if other list length length result true for int i 0 i length i if get xml from annot i equival xml other list get xml from annot i result fals break return result 
param name param start return privat xmllist get properti list xmlname name xmllist properti list new xmllist lib javax xml namespac qname qname null if name is descend name is attribut name onli set the target properti if thi is a regular child get and not a descend or attribut get qname new javax xml namespac qname name uri name local name properti list set target thi qname for int i 0 i length i properti list add to list get xml from annot i get properti list name return properti list 
privat object appli or call boolean is appli context cx scriptabl scope scriptabl thi obj object arg string method name is appli appli call if thi obj instanceof xmllist xmllist thi obj target properti null throw script runtim type error1 msg isnt function method name return script runtim appli or call is appli cx scope thi obj arg 
protect object js constructor context cx boolean in new expr object arg if arg length 0 return new xmllist lib els object arg0 arg 0 if in new expr arg0 instanceof xmllist xmllist xmllist return the same object return arg0 return new xmllist lib arg0 
org apach xmlbean xml object get xml object if length 1 return get xml from annot 0 get xml object els throw script runtim type error get xml object method work onli on list contain on item 
see ecma 357 11 2 2 1 semant 3 e public scriptabl get extra method sourc context cx if length 1 return get xml from annot 0 return null 
public object call context cx scriptabl scope scriptabl thi obj object arg thi xmllist is be call as a function let s find the real function object if target properti null throw script runtim not function error thi string method name target properti get local part boolean is appli method name equal appli if is appli method name equal call return appli or call is appli cx scope thi obj arg callabl method script runtim get elem function and thi thi method name cx call last store scriptabl to clear store thi obj but ignor the result as the method should us the suppli thi obj not on from redirect call script runtim last store scriptabl cx return method call cx scope thi obj arg 
public scriptabl construct context cx scriptabl scope object arg throw script runtim type error1 msg not ctor xmllist 
data flow bit set int size it size size it bit new int size 31 5 
void set int n if 0 n n it size bad index n it bit n 5 1 n 31 
boolean test int n if 0 n n it size bad index n return it bit n 5 1 n 31 0 
void not int bit length it bit length for int i 0 i bit length i it bit i it bit i 
void clear int n if 0 n n it size bad index n it bit n 5 1 n 31 
void clear int bit length it bit length for int i 0 i bit length i it bit i 0 
void or data flow bit set b int bit length it bit length for int i 0 i bit length i it bit i b it bit i 
public string to string string buffer sb new string buffer sb append data flow bit set size sb append it size sb append n int bit length it bit length for int i 0 i bit length i sb append integ to hex string it bit i sb append return sb to string 
boolean df data flow bit set in data flow bit set gen data flow bit set not kill int bit length it bit length boolean chang fals for int i 0 i bit length i int old bit it bit i it bit i in it bit i gen it bit i not kill it bit i chang old bit it bit i return chang 
boolean df2 data flow bit set in data flow bit set gen data flow bit set not kill int bit length it bit length boolean chang fals for int i 0 i bit length i int old bit it bit i it bit i in it bit i not kill it bit i gen it bit i chang old bit it bit i return chang 
privat void bad index int n throw new runtim except data flow bit set bad index n 
public object wrap context cx scriptabl scope object obj class static type if obj instanceof string obj instanceof number obj instanceof boolean return obj els if obj instanceof charact char a charact obj char valu return new string a return super wrap cx scope obj static type 
the method must not be public or protect static secur control global return global 
check if global link secur control wa alreadi instal see init global secur control control public static boolean ha global return global null 
initi global control that will be us for all secur relat oper the global control take preced over alreadi instal link context specif control and caus ani subsequ call to link context set secur control secur control to throw an except p the method can onli be call onc see ha global public static void init global secur control control if control null throw new illeg argument except if global null throw new secur except cannot overwrit alreadi instal global secur control global control 
get class loader like object that can be us to defin class with the given secur context param parent loader parent class loader to deleg search for class not defin by the class loader itself param secur domain some object specifi the secur context of the code that is defin by the return class loader public abstract gener class loader creat class loader 
creat link gener class loader with restrict impos by static domain and all current stack frame the method us the secur control instanc associ with the current link context to construct proper dynam domain and creat correspond class loader par if no secur control is associ with the current link context the method call link context creat class loader class loader parent param parent parent class loader if null link context get applic class loader will be us param static domain static secur domain public static gener class loader creat loader class loader parent object static domain context cx context get context if parent null parent cx get applic class loader secur control sc cx get secur control gener class loader loader if sc null loader cx creat class loader parent els object dynam domain sc get dynam secur domain static domain loader sc creat class loader parent dynam domain return loader 
get dynam secur domain that allow an action onli if it is allow by the current java stack and i secur domain i if i secur domain i is null return domain repres permiss allow by the current stack 
call link callabl call context cx scriptabl scope scriptabl thi obj object arg of i callabl i under restrict secur domain where an action is allow onli if it is allow accord to the java stack on the moment of the i exec with domain i call and i secur domain i ani call to link get dynam secur domain object dure execut of tt callabl call cx scope thi obj arg tt should return a domain incorpor restrict impos by i secur domain i and java stack on the moment of call with domain invoc p the method should alwai be overridden it is not declar abstract for compat reason public object call with domain object secur domain context cx final callabl callabl scriptabl scope final scriptabl thi obj final object arg return exec with domain cx scope new script public object exec context cx scriptabl scope return callabl call cx scope thi obj arg secur domain 
return exec with domain cx scope new script public object exec context cx scriptabl scope return callabl call cx scope thi obj arg 
deprec the applic should not overrid thi method and instead overrid link call with domain object secur domain context cx callabl callabl scriptabl scope scriptabl thi obj object arg public object exec with domain context cx scriptabl scope script script object secur domain throw new illeg state except call with domain should be overridden 
follow the art of comput program by donald e knuth public uint map thi 4 
public uint map int initi capac if initi capac 0 kit code bug tabl grow when number of store kei 3 4 of max capac int minim capac initi capac 4 3 int i for i 2 1 i minim capac i power i if check power 2 kit code bug 
public boolean is empti return kei count 0 
public int size return kei count 
public boolean ha int kei if kei 0 kit code bug return 0 find index kei 
get object valu assign with kei return kei object valu or null if kei is absent public object get object int kei if kei 0 kit code bug if valu null int index find index kei if 0 index return valu index return null 
get integ valu assign with kei return kei integ valu or default valu if kei is absent public int get int int kei int default valu if kei 0 kit code bug int index find index kei if 0 index if ivalu shift 0 return kei ivalu shift index return 0 return default valu 
get integ valu assign with kei return kei integ valu or default valu if kei doe not exist or doe not have int valu throw runtim except if kei doe not exist public int get exist int int kei if kei 0 kit code bug int index find index kei if 0 index if ivalu shift 0 return kei ivalu shift index return 0 kei must exist kit code bug return 0 
set object valu of the kei if kei doe not exist also set it int valu to 0 public void put int kei object valu if kei 0 kit code bug int index ensur index kei fals if valu null valu new object 1 power valu index valu 
set int valu of the kei if kei doe not exist also set it object valu to null public void put int kei int valu if kei 0 kit code bug int index ensur index kei true if ivalu shift 0 int n 1 power kei length can be n 2 after clear which set ivalu shift to 0 if kei length n 2 int tmp new int n 2 system arraycopi kei 0 tmp 0 n kei tmp ivalu shift n kei ivalu shift index valu 
public void remov int kei if kei 0 kit code bug int index find index kei if 0 index kei index delet kei count allow to gc valu and make sure that new kei with the delet slot shall get proper default valu if valu null valu index null if ivalu shift 0 kei ivalu shift index 0 
public void clear int n 1 power if kei null for int i 0 i n i kei i empti if valu null for int i 0 i n i valu i null ivalu shift 0 kei count 0 occupi count 0 
return arrai of present kei public int get kei int kei thi kei int n kei count int result new int n for int i 0 n 0 i int entri kei i if entri empti entri delet result n entri return result 
privat static int tabl lookup step int fraction int mask int power int shift 32 2 power if shift 0 return fraction shift mask 1 els return fraction mask shift 1 
privat int find index int kei int kei thi kei if kei null int fraction kei a int index fraction 32 power int entri kei index if entri kei return index if entri empti search in tabl after first fail attempt int mask 1 power 1 int step tabl lookup step fraction mask power int n 0 do if check if n occupi count kit code bug n index index step mask entri kei index if entri kei return index while entri empti return 1 
and enough free space privat int insert new kei int kei if check occupi count kei count kit code bug if check kei count 1 power kit code bug int kei thi kei int fraction kei a int index fraction 32 power if kei index empti int mask 1 power 1 int step tabl lookup step fraction mask power int first index index do if check kei index delet kit code bug index index step mask if check first index index kit code bug while kei index empti kei index kei occupi count kei count return index 
privat void rehash tabl boolean ensur int space if kei null check if remov delet entri would free enough space if kei count 2 occupi count need to grow less then half of delet entri power int n 1 power int old kei int old shift ivalu shift if old shift 0 ensur int space kei new int n els ivalu shift n kei new int n 2 for int i 0 i n i kei i empti object old valu valu if old valu null valu new object n int old count kei count occupi count 0 if old count 0 kei count 0 for int i 0 remain old count remain 0 i int kei old i if kei empti kei delet int index insert new kei kei if old valu null valu index old valu i if old shift 0 kei ivalu shift index old old shift i remain 
ensur kei index creat on if necessari privat int ensur index int kei boolean int type int index 1 int first delet 1 int kei thi kei if kei null int fraction kei a index fraction 32 power int entri kei index if entri kei return index if entri empti if entri delet first delet index search in tabl after first fail attempt int mask 1 power 1 int step tabl lookup step fraction mask power int n 0 do if check if n occupi count kit code bug n index index step mask entri kei index if entri kei return index if entri delet first delet 0 first delet index while entri empti insert of new kei if check kei null kei index empti kit code bug if first delet 0 index first delet els need to consum empti entri check occup level if kei null occupi count 4 1 power 3 too litl unus entri rehash rehash tabl int type kei thi kei return insert new kei kei occupi count kei index kei kei count return index 
privat void write object object output stream out throw ioexcept out default write object int count kei count if count 0 boolean ha int valu ivalu shift 0 boolean ha object valu valu null out write boolean ha int valu out write boolean ha object valu for int i 0 count 0 i int kei kei i if kei empti kei delet count out write int kei if ha int valu out write int kei ivalu shift i if ha object valu out write object valu i 
privat void read object object input stream in throw ioexcept class not found except in default read object int written kei count kei count if written kei count 0 kei count 0 boolean ha int valu in read boolean boolean ha object valu in read boolean int n 1 power if ha int valu kei new int 2 n ivalu shift n els kei new int n for int i 0 i n i kei i empti if ha object valu valu new object n for int i 0 i written kei count i int kei in read int int index insert new kei kei if ha int valu int ivalu in read int kei ivalu shift index ivalu if ha object valu valu index in read object 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl 
public string ambigu string arg return string 
public string ambigu object arg return object 
public string ambigu jsobject arg return jsobject 
scriptabl output stream constructor creat a scriptabl output stream for us in serial java script object call exclud standard object name param out the output stream to write to param scope the scope contain the object public scriptabl output stream output stream out scriptabl scope throw ioexcept super out thi scope scope tabl new hashtabl 31 tabl put scope enabl replac object true exclud standard object name 
add a qualifi name to the list of object to be exclud from serial name exclud from serial ar look up in the new scope and replac upon deseri param name a fulli qualifi name of the form a b c where a must be a properti of the top level object the object need not exist in which case the name is ignor throw illeg argument except if the object is not a link scriptabl public void add option exclud name string name object obj lookup qualifi name scope name if obj null obj uniqu tag not found if obj instanceof scriptabl throw new illeg argument except object for exclud name name is not a scriptabl it is obj get class get name tabl put obj name 
add a qualifi name to the list of object to be exclud from serial name exclud from serial ar look up in the new scope and replac upon deseri param name a fulli qualifi name of the form a b c where a must be a properti of the top level object throw illeg argument except if the object is not found or is not a link scriptabl public void add exclud name string name object obj lookup qualifi name scope name if obj instanceof scriptabl throw new illeg argument except object for exclud name name not found tabl put obj name 
return true if the name is exclud from serial public boolean ha exclud name string name return tabl get name null 
remov a name from the list of name to exclud public void remov exclud name string name tabl remov name 
add the name of the standard object and their prototyp to the list of exclud name public void exclud standard object name string name object object prototyp function function prototyp string string prototyp math no math prototyp arrai arrai prototyp error error prototyp number number prototyp date date prototyp reg exp reg exp prototyp script script prototyp continu continu prototyp for int i 0 i name length i add exclud name name i string option name xml xml prototyp xmllist xmllist prototyp for int i 0 i option name length i add option exclud name option name i 
static object lookup qualifi name scriptabl scope string qualifi name string token st new string token qualifi name object result scope while st ha more token string s st next token result scriptabl object get properti scriptabl result s if result null result instanceof scriptabl break return result 
static final long serial version uid 2692990309789917727l pend lookup string name thi name name 
pend lookup string name thi name name string get name return name 
protect object replac object object obj throw ioexcept string name string tabl get obj if name null return obj return new pend lookup name 
public static void init scriptabl scope boolean seal continu obj new continu obj export as jsclass max prototyp id scope seal 
public object get implement return implement 
public void init implement object implement thi implement implement 
public string get class name return continu 
public scriptabl construct context cx scriptabl scope object arg throw context report runtim error direct call is not support 
public object call context cx scriptabl scope scriptabl thi obj object arg return interpret restart continu thi cx scope arg 
public static boolean is continu constructor id function object f if f ha tag ftag f method id id constructor return true return fals 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 0 s constructor break default throw new illeg argument except string valu of id init prototyp method ftag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag ftag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor throw context report runtim error direct call is not support throw new illeg argument except string valu of id 
protect int find prototyp id string s int id gener last updat 2004 09 08 12 02 41 cest l0 id 0 string x null if s length 11 x constructor id id constructor if x null x s x equal s id 0 gener return id 
privat int offset public string get line termin return line termin 
public string get line termin return line termin public void set line termin string valu line termin valu 
public void set line termin string valu line termin valu public int get indent step return indent step 
public int get indent step return indent step public void set indent step int char count indent step char count 
public void set indent step int char count indent step char count public int get indent tab size return indent tab size 
public int get indent tab size return indent tab size public void set indent tab size int tab size indent tab size tab size 
public void set indent tab size int tab size indent tab size tab size public void clear offset 0 
privat int ensur area int area size int begin offset int end begin area size if end buffer length int new capac buffer length 2 if end new capac new capac end char tmp new char new capac system arraycopi buffer 0 tmp 0 begin buffer tmp return begin 
privat int add area int area size int po ensur area area size offset po area size return po 
public int get offset return offset 
public int get last char return offset 0 1 buffer offset 1 
public void p char c int po add area 1 buffer po c 
public void p string s int l s length int po add area l s get char 0 l buffer po 
public final void p char arrai p arrai 0 arrai length 
public void p char arrai int begin int end int l end begin int po add area l system arraycopi arrai begin buffer po l 
public void p int i p integ to string i 
public void qchar int c int po ensur area 2 liter char max size buffer po po put string liter char po 1 c fals buffer po offset po 1 
public void qstring string s int l s length int po ensur area 2 liter char max size l buffer po po for int i 0 i l i po put string liter char po s char at i true buffer po offset po 1 
privat int put string liter char int po int c boolean in string boolean backslash symbol true switch c case b c b break case t c t break case n c n break case f c f break case r c r break case backslash symbol in string break case backslash symbol in string break default backslash symbol fals if backslash symbol buffer po buffer po 1 char c po 2 els if c c 126 buffer po char c po els buffer po buffer po 1 u buffer po 2 digit to hex letter 0x f c 12 buffer po 3 digit to hex letter 0x f c 8 buffer po 4 digit to hex letter 0x f c 4 buffer po 5 digit to hex letter 0x f c po 6 return po 
privat static char digit to hex letter int d return char d 10 0 d a 10 d 
public void indent int level int visibl size indent step level int indent size tab count if indent tab size 0 tab count 0 indent size visibl size els tab count visibl size indent tab size indent size tab count visibl size indent tab size int po add area indent size int tab end po tab count int indent end po indent size for po tab end po buffer po t for po indent end po buffer po 
public void nl p n 
public void line int indent level string s indent indent level p s nl 
public void eras int begin int end system arraycopi buffer end buffer begin offset end offset end begin 
public string to string return new string buffer 0 offset 
creat a java script function object from a java method p the code member code argument must be either a java lang reflect method or a java lang reflect constructor and must match on of two form p the first form is a member with zero or more paramet of the follow type object string boolean scriptabl int or doubl the long type is not support becaus the doubl represent of a long which is the emca mandat storag type for number mai lose precis if the member is a method the return valu must be void or on of the type allow for paramet p the runtim will perform appropri convers base upon the type of the paramet a paramet type of object specifi that no convers ar to be done a paramet of type string will us context to string to convert argument similarli paramet of type doubl boolean and scriptabl will caus context to number context to boolean and context to object respect to be call p if the method is not static the java thi valu will correspond to the java script thi valu ani attempt to call the function with a thi valu that is not of the right java type will result in an error p the second form is the variabl argument or vararg form if the function object will be us as a constructor the member must have the follow paramet pre context cx object arg function ctor obj boolean in new expr pre and if it is a method be static and return an object result p otherwis if the function object will i not i be us to defin a constructor the member must be a static method with paramet context cx scriptabl thi obj object arg function fun obj pre pre and an object result p when the function vararg form is call as part of a function call the code arg code paramet contain the argument with code thi obj code set to the java script thi valu code fun obj code is the function object for the invok function p when the constructor vararg form is call or invok while evalu a code new code express code arg code contain the argument code ctor obj code refer to thi function object and code in new expr code is true if and onli if a code new code express caus the call thi support defin a function that ha differ behavior when call as a constructor than when invok as a normal function call for exampl the boolean constructor when call as a function will convert to boolean rather than creat a new object p param name the name of the function param method or constructor a java lang reflect method or a java lang reflect constructor that defin the object param scope enclos scope of function see org mozilla javascript scriptabl public function object string name member method or constructor scriptabl scope if method or constructor instanceof constructor member new member box constructor method or constructor is static true well doesn t take a thi els member new member box method method or constructor is static member is static string method name member get name thi function name name class type member arg type int ariti type length if ariti 4 type 1 is arrai type 2 is arrai either variabl arg or an error if type 1 is arrai if is static type 0 script runtim context class type 1 get compon type script runtim object class type 2 script runtim function class type 3 boolean type throw context report runtim error1 msg vararg ctor method name parm length vararg ctor els if is static type 0 script runtim context class type 1 script runtim scriptabl class type 2 get compon type script runtim object class type 3 script runtim function class throw context report runtim error1 msg vararg fun method name parm length vararg method els parm length ariti if ariti 0 type tag new byte ariti for int i 0 i ariti i int tag get type tag type i if tag java unsupport type throw context report runtim error2 msg bad parm type i get name method name type tag i byte tag if member is method method method member method class return type method get return type if return type void type ha void return true els return type tag get type tag return type els class ctor type member get declar class if script runtim scriptabl class is assign from ctor type throw context report runtim error1 msg bad ctor return ctor type get name script runtim set function proto and parent thi scope 
return on of tt java type tt constant to indic desir type or link java unsupport type if the convert is not possibl public static int get type tag class type if type script runtim string class return java string type if type script runtim integ class type integ type return java int type if type script runtim boolean class type boolean type return java boolean type if type script runtim doubl class type doubl type return java doubl type if script runtim scriptabl class is assign from type return java scriptabl type if type script runtim object class return java object type note that the long type is not support see the javadoc for the constructor for thi class return java unsupport type 
public static object convert arg context cx scriptabl scope object arg int type tag switch type tag case java string type if arg instanceof string return arg return script runtim to string arg case java int type if arg instanceof integ return arg return new integ script runtim to int32 arg case java boolean type if arg instanceof boolean return arg return script runtim to boolean arg boolean true boolean fals case java doubl type if arg instanceof doubl return arg return new doubl script runtim to number arg case java scriptabl type if arg instanceof scriptabl return arg return script runtim to object cx scope arg case java object type return arg default throw new illeg argument except 
return the valu defin by the method us to construct the object number of paramet of the method or 1 if the method is a vararg form public int get ariti return parm length 0 1 parm length 
return the same valu as link get ariti public int get length return get ariti 
public string get function name return function name null function name 
get java method or constructor thi function repres public member get method or constructor if member is method return member method els return member ctor 
static method find singl method method method string name method found null for int i 0 n method length i n i method method method i if method null name equal method get name if found null throw context report runtim error2 msg no overload name method get declar class get name found method return found 
return all public method declar by the specifi class thi exclud inherit method param clazz the class from which to pull public declar method return the public method declar in the specifi class see class get declar method static method get method list class clazz method method null try get declar method mai be reject by the secur manag but get method is more expens if saw secur except method clazz get declar method catch secur except e if we get an except onc give up on get declar method saw secur except true if method null method clazz get method int count 0 for int i 0 i method length i if saw secur except method i get declar class clazz modifi is public method i get modifi method i null els count method result new method count int j 0 for int i 0 i method length i if method i null result j method i return result 
defin thi function as a java script constructor p set up the prototyp and constructor properti also call set parent and set prototyp with appropri valu then add the function object as a properti of the given scope us code prototyp get class name code as the name of the properti param scope the scope in which to defin the constructor typic the global object param prototyp the prototyp object see org mozilla javascript scriptabl set parent scope see org mozilla javascript scriptabl set prototyp see org mozilla javascript scriptabl get class name public void add as constructor scriptabl scope scriptabl prototyp script runtim set function proto and parent thi scope set immun prototyp properti prototyp prototyp set parent scope thi final int attr scriptabl object dontenum scriptabl object perman scriptabl object readonli defin properti prototyp constructor thi attr string name prototyp get class name defin properti scope name thi scriptabl object dontenum set parent scope scope 
deprec us link get type tag class and link convert arg context scriptabl object int for type convert public static object convert arg context cx scriptabl scope object arg class desir int tag get type tag desir if tag java unsupport type throw context report runtim error1 msg cant convert desir get name return convert arg cx scope arg tag 
perform convers on argument type if need and invok the underli java method or constructor p implement function call see org mozilla javascript function call context scriptabl scriptabl object public object call context cx scriptabl scope scriptabl thi obj object arg object result boolean check method result fals if parm length 0 if parm length vararg method object invok arg cx thi obj arg thi result member invok null invok arg check method result true els boolean in new expr thi obj null boolean b in new expr boolean true boolean fals object invok arg cx arg thi b result member is ctor member new instanc invok arg member invok null invok arg els if is static class clazz member get declar class if clazz is instanc thi obj boolean compat fals if thi obj scope scriptabl parent scope get parent scope if scope parent scope call with dynam scope for standalon function us parent scope as thi obj compat clazz is instanc parent scope if compat thi obj parent scope if compat couldn t find an object to call thi on throw script runtim type error1 msg incompat call function name object invok arg if parm length arg length do not alloc new argument arrai if java argument ar the same as the origin js on invok arg arg for int i 0 i parm length i object arg arg i object convert convert arg cx scope arg type tag i if arg convert if invok arg arg invok arg object arg clone invok arg i convert els if parm length 0 invok arg script runtim empti arg els invok arg new object parm length for int i 0 i parm length i object arg i arg length arg i undefin instanc invok arg i convert arg cx scope arg type tag i if member is method result member invok thi obj invok arg check method result true els result member new instanc invok arg if check method result if ha void return result undefin instanc els if return type tag java unsupport type result cx get wrap factori wrap cx scope result null xxx the code assum that if return type tag java object type then the java method did a proper job of convert the result to js primit or scriptabl to avoid potenti costli context java to js call return result 
return new link scriptabl instanc us the default constructor for the class of the underli java method return null to indic that the call method should be us to creat new object public scriptabl creat object context cx scriptabl scope if member is ctor parm length vararg ctor return null scriptabl result try result scriptabl member get declar class new instanc catch except ex throw context throw as script runtim ex ex result set prototyp get class prototyp result set parent scope get parent scope return result 
boolean is var arg method return parm length vararg method 
boolean is var arg constructor return parm length vararg ctor 
privat void read object object input stream in throw ioexcept class not found except in default read object if parm length 0 class type member arg type type tag new byte parm length for int i 0 i parm length i type tag i byte get type tag type i if member is method method method member method class return type method get return type if return type void type ha void return true els return type tag get type tag return type 
public class run script4 public static void main string arg throw except context cx context enter try scriptabl scope cx init standard object us the counter class to defin a counter constructor and prototyp in java script scriptabl object defin class scope counter class creat an instanc of counter and assign it to the top level variabl my counter thi is equival to the java script code my counter new counter 7 object arg new integ 7 scriptabl my counter cx new object scope counter arg scope put my counter scope my counter string s for int i 0 i arg length i s arg i object result cx evalu string scope s cmd 1 null system err println cx to string result final context exit 
static void init scriptabl scope boolean seal nativ math obj new nativ math obj activ prototyp map max id obj set prototyp get object prototyp scope obj set parent scope scope if seal obj seal object scriptabl object defin properti scope math obj scriptabl object dontenum 
privat nativ math 
public string get class name return math 
protect void init prototyp id int id if id last method id string name int ariti switch id case id to sourc ariti 0 name to sourc break case id ab ariti 1 name ab break case id aco ariti 1 name aco break case id asin ariti 1 name asin break case id atan ariti 1 name atan break case id atan2 ariti 2 name atan2 break case id ceil ariti 1 name ceil break case id co ariti 1 name co break case id exp ariti 1 name exp break case id floor ariti 1 name floor break case id log ariti 1 name log break case id max ariti 2 name max break case id min ariti 2 name min break case id pow ariti 2 name pow break case id random ariti 0 name random break case id round ariti 1 name round break case id sin ariti 1 name sin break case id sqrt ariti 1 name sqrt break case id tan ariti 1 name tan break default throw new illeg state except string valu of id init prototyp method math tag id name ariti els string name doubl x switch id case id e x math e name e break case id pi x math pi name pi break case id ln10 x 2 302585092994046 name ln10 break case id ln2 x 0 6931471805599453 name ln2 break case id log2 x 1 4426950408889634 name log2 break case id log10 x 0 4342944819032518 name log10 break case id sqrt1 2 x 0 7071067811865476 name sqrt1 2 break case id sqrt2 x 1 4142135623730951 name sqrt2 break default throw new illeg state except string valu of id init prototyp valu id name script runtim wrap number x dontenum readonli perman 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag math tag return super exec id call f cx scope thi obj arg doubl x int method id f method id switch method id case id to sourc return math case id ab x script runtim to number arg 0 ab 0 0 should be 0 0 but 0 0 0 0 fals x x 0 0 0 0 x 0 0 x x break case id aco case id asin x script runtim to number arg 0 if x x 1 0 x x 1 0 x method id id aco math aco x math asin x els x doubl na n break case id atan x script runtim to number arg 0 x math atan x break case id atan2 x script runtim to number arg 0 x math atan2 x script runtim to number arg 1 break case id ceil x script runtim to number arg 0 x math ceil x break case id co x script runtim to number arg 0 x x doubl posit infin x doubl neg infin doubl na n math co x break case id exp x script runtim to number arg 0 x x doubl posit infin x x doubl neg infin 0 0 math exp x break case id floor x script runtim to number arg 0 x math floor x break case id log x script runtim to number arg 0 java s log 0 infin we need na n x x 0 doubl na n math log x break case id max case id min x method id id max doubl neg infin doubl posit infin for int i 0 i arg length i doubl d script runtim to number arg i if d d x d na n break if method id id max if x d x d doe not work due to 0 0 0 0 x math max x d els x math min x d break case id pow x script runtim to number arg 0 x js pow x script runtim to number arg 1 break case id random x math random break case id round x script runtim to number arg 0 if x x x doubl posit infin x doubl neg infin round onli finit x long l math round x if l 0 x doubl l els we must propag the sign of d into the result if x 0 0 x script runtim neg zero els if x 0 0 x 0 0 break case id sin x script runtim to number arg 0 x x doubl posit infin x doubl neg infin doubl na n math sin x break case id sqrt x script runtim to number arg 0 x math sqrt x break case id tan x script runtim to number arg 0 x math tan x break default throw new illeg state except string valu of method id return script runtim wrap number x 
see ecma 15 8 2 13 privat doubl js pow doubl x doubl y doubl result if y y y is na n result is alwai na n result y els if y 0 java s pow na n 0 na n we need 1 result 1 0 els if x 0 mani dirrer from java s math pow if 1 x 0 result y 0 0 doubl posit infin els x is 0 need to check if y is an odd integ long y long long y if y long y y long 0x1 0 result y 0 0 0 doubl neg infin els result y 0 0 0 doubl posit infin els result math pow x y if result result check for broken java implement that give na n when thei should return someth els if y doubl posit infin if x 1 0 1 0 x result doubl posit infin els if 1 0 x x 1 0 result 0 els if y doubl neg infin if x 1 0 1 0 x result 0 els if 1 0 x x 1 0 result doubl posit infin els if x doubl posit infin result y 0 doubl posit infin 0 0 els if x doubl neg infin long y long long y if y long y y long 0x1 0 y is odd integ result y 0 doubl neg infin 0 0 els result y 0 doubl posit infin 0 0 return result 
protect int find prototyp id string s int id gener last updat 2004 03 17 13 51 32 cet l0 id 0 string x null int c l switch s length case 1 if s char at 0 e id id e break l0 break l case 2 if s char at 0 p s char at 1 i id id pi break l0 break l case 3 switch s char at 0 case l if s char at 2 2 s char at 1 n id id ln2 break l0 break l case a if s char at 2 s s char at 1 b id id ab break l0 break l case c if s char at 2 s s char at 1 o id id co break l0 break l case e if s char at 2 p s char at 1 x id id exp break l0 break l case l if s char at 2 g s char at 1 o id id log break l0 break l case m c s char at 2 if c n if s char at 1 i id id min break l0 els if c x if s char at 1 a id id max break l0 break l case p if s char at 2 w s char at 1 o id id pow break l0 break l case s if s char at 2 n s char at 1 i id id sin break l0 break l case t if s char at 2 n s char at 1 a id id tan break l0 break l break l case 4 switch s char at 1 case n x ln10 id id ln10 break l case c x aco id id aco break l case e x ceil id id ceil break l case q x sqrt id id sqrt break l case s x asin id id asin break l case t x atan id id atan break l break l case 5 switch s char at 0 case l x log2 id id log2 break l case s x sqrt2 id id sqrt2 break l case a x atan2 id id atan2 break l case f x floor id id floor break l case r x round id id round break l break l case 6 c s char at 0 if c l x log10 id id log10 els if c r x random id id random break l case 7 x sqrt1 2 id id sqrt1 2 break l case 8 x to sourc id id to sourc break l if x null x s x equal s id 0 gener return id 
public class call 001 extend live connect test public call 001 super 
public static void main string arg call 001 test new call 001 test start 
public void setup test environ super setup test environ 
public void execut test object data get data arrai for int i 0 i data length i jsobject js object get jsobject object data i call js object object data i 
creat and return a jsobject us data in the data arrai param data object arrai contain name of jsobject and assign express return the jsobject public jsobject get jsobject object data string constructor data 0 data 1 jsobject the thi jsobject global eval constructor return the thi 
us jsobject call to invok a java script method verifi the valu and class of the object return param the thi jsobject whose method will be call will be check param data object arrai contain the name of the method argument to be pass to that method and the expect return valu of the method public void call jsobject the thi object data string except null string method string data 2 object arg object data 3 object e valu data 4 object a valu null class e class null class a class null try a valu the thi call method object arg if a valu null e class e valu get class a class a valu get class catch except e except the thi call method arg threw e to string file except except e print stack trace final if a valu null els check the valu of the properti add test case get member return a valu the thi call method arg equal e valu true a valu equal e valu except check the class of the properti add test case a valu get class return a class get name a class get name equal e class get name true a class get name equal e class get name except 
get the data arrai which is an object arrai data arrai which ar also object arrai ul li identifi for java script object li assign express to initi java script object li method of the java script object li argument to pass to the method li valu return by the method ul to add test case to thi test modifi thi method return the data arrai public object get data arrai object d0 new string boo 0 identifi new string new boolean 1 assign express new string valu of 2 method null 3 argument arrai new boolean fals 4 return valu object d1 new string date new string new date 0 new string get utcful year null new doubl 1970 object data arrai d0 d1 return data arrai 
interpret data int languag version string sourc file string encod sourc thi languag version languag version thi it sourc file sourc file thi encod sourc encod sourc init 
interpret data interpret data parent thi parent data parent thi languag version parent languag version thi it sourc file parent it sourc file thi encod sourc parent encod sourc init 
privat void init it icod new byte initi max icod length it string tabl new string initi stringtabl size 
boolean eval script flag true if script correspond to eval code public boolean is top level return top level 
public boolean is function return it function type 0 
public string get function name return it name 
public int get param count return arg count 
public int get param and var count return arg name length 
public string get param or var name int index return arg name index 
public string get sourc name return it sourc file 
public boolean is gener script return script runtim is gener script it sourc file 
public int get line number return interpret get line number thi 
public int get function count return it nest function null 0 it nest function length 
public debugg script get function int index return it nest function index 
public debugg script get parent return parent data 
privat static block reduc to arrai obj to int map map block result null if map is empti result new block map size int i 0 obj to int map iter iter map new iter for iter start iter done iter next fat block fb fat block iter get kei result i fb real block return result 
void add successor fat block b successor put b 0 
void add successor fat block b successor put b 0 void add predecessor fat block b predecessor put b 0 
void add predecessor fat block b predecessor put b 0 block get successor return reduc to arrai successor 
block get successor return reduc to arrai successor block get predecessor return reduc to arrai predecessor 
block int start node index int end node index it start node index start node index it end node index end node index 
static void run flow analyz opt function node fn node statement node int param count fn fnode get param count int var count fn fnode get param and var count int var type new int var count if the variabl is a paramet it could have ani type for int i 0 i param count i var type i optim ani type if the variabl is from a var statement it type event will be set when we see the set var node for int i param count i var count i var type i optim no type block the block build block statement node if debug debug block count system out println fn fnode get function name debug block count system out println to string the block statement node reach def data flow fn statement node the block var type type flow fn statement node the block var type if debug for int i 0 i the block length i system out println for block the block i it block id the block i print live on entri set fn system out println variabl tabl size var count for int i 0 i var count i system out println i type var type i for int i param count i var count i if var type i optim number type fn set is number var i 
privat static block build block node statement node a map from each target node to the block it begin hashtabl the target block new hashtabl obj arrai the block new obj arrai there s a block that start at index 0 int begin node index 0 for int i 0 i statement node length i switch statement node i get type case token target if i begin node index fat block fb new fat block begin node index i 1 if statement node begin node index get type token target the target block put statement node begin node index fb the block add fb start the next block at thi node begin node index i break case token ifn case token ifeq case token goto fat block fb new fat block begin node index i if statement node begin node index get type token target the target block put statement node begin node index fb the block add fb start the next block at the next node begin node index i 1 break if begin node index statement node length fat block fb new fat block begin node index statement node length 1 if statement node begin node index get type token target the target block put statement node begin node index fb the block add fb build successor and predecessor link for int i 0 i the block size i fat block fb fat block the block get i node block end node statement node fb real block it end node index int block end node type block end node get type if block end node type token goto i the block size 1 fat block fall thru target fat block the block get i 1 fb add successor fall thru target fall thru target add predecessor fb if block end node type token ifn block end node type token ifeq block end node type token goto node target node jump block end node target fat block branch target block fat block the target block get target target put prop node targetblock prop branch target block real block fb add successor branch target block branch target block add predecessor fb block result new block the block size for int i 0 i the block size i fat block fb fat block the block get i block b fb real block b it successor fb get successor b it predecessor fb get predecessor b it block id i result i b return result 
privat static fat block new fat block int start node index int end node index fat block fb new fat block fb real block new block start node index end node index return fb 
privat static string to string block block list node statement node if debug return null string writer sw new string writer print writer pw new print writer sw pw println block list length block for int i 0 i block list length i block b block list i pw println b it block id pw println from b it start node index statement node b it start node index to string pw println thru b it end node index statement node b it end node index to string pw print predecessor if b it predecessor null for int j 0 j b it predecessor length j pw print b it predecessor j it block id pw println els pw println none pw print successor if b it successor null for int j 0 j b it successor length j pw print b it successor j it block id pw println els pw println none return sw to string 
privat static void reach def data flow opt function node fn node statement node block the block int var type initi the live on entri and live on exit set then discov the variabl that ar def d by each function and those that ar us befor be def d henc live on entri for int i 0 i the block length i the block i init live on entri set fn statement node thi visit everi block start at the last re ad the predecessor of ani block whose input chang as a result of the dataflow remind better would be to visit in cfg postord boolean visit new boolean the block length boolean done onc new boolean the block length int v index the block length 1 boolean need rescan fals visit v index true while true if visit v index done onc v index done onc v index true visit v index fals if the block v index do reach us data flow block pred the block v index it predecessor if pred null for int i 0 i pred length i int index pred i it block id visit index true need rescan index v index if v index 0 if need rescan v index the block length 1 need rescan fals els break els v index if ani variabl is live on entri to block 0 we have to mark it as not j regabl sinc it mean that someon is try to access the undefin ness of that variabl the block 0 mark ani type variabl var type 
privat static void type flow opt function node fn node statement node block the block int var type boolean visit new boolean the block length boolean done onc new boolean the block length int v index 0 boolean need rescan fals visit v index true while true if visit v index done onc v index done onc v index true visit v index fals if the block v index do type flow fn statement node var type block succ the block v index it successor if succ null for int i 0 i succ length i int index succ i it block id visit index true need rescan index v index if v index the block length 1 if need rescan v index 0 need rescan fals els break els v index 
privat static boolean assign type int var type int index int type return type var type index type 
privat void mark ani type variabl int var type for int i 0 i var type length i if it live on entri set test i assign type var type i optim ani type 
privat void look for variabl access opt function node fn node n switch n get type case token dec case token inc node child n get first child if child get type token getvar int var index fn get var index child if it not def set test var index it us befor def set set var index it not def set set var index break case token setvar node lh n get first child node rh lh get next look for variabl access fn rh it not def set set fn get var index n break case token getvar int var index fn get var index n if it not def set test var index it us befor def set set var index break default node child n get first child while child null look for variabl access fn child child child get next break 
privat void init live on entri set opt function node fn node statement node int list length fn get var count it us befor def set new data flow bit set list length it not def set new data flow bit set list length it live on entri set new data flow bit set list length it live on exit set new data flow bit set list length for int i it start node index i it end node index i node n statement node i look for variabl access fn n it not def set not truth in advertis 
privat boolean do reach us data flow it live on exit set clear if it successor null for int i 0 i it successor length i it live on exit set or it successor i it live on entri set return it live on entri set df2 it live on exit set it us befor def set it not def set 
privat static int find express type opt function node fn node n int var type switch n get type case token number return optim number type case token call case token new case token ref call return optim ani type case token getelem return optim ani type case token getvar return var type fn get var index n case token inc case token dec case token div case token mod case token bitor case token bitxor case token bitand case token lsh case token rsh case token ursh case token sub return optim number type case token add if the lh rh ar known to be number we can be sure that s the result otherwis it could be a string node child n get first child int l type find express type fn child var type int r type find express type fn child get next var type return l type r type we re not distinguishng string yet node child n get first child if child null return optim ani type els int result optim no type while child null result find express type fn child var type child child get next return result 
privat static boolean find def point opt function node fn node n int var type boolean result fals node child n get first child switch n get type default while child null result find def point fn child var type child child get next break case token dec case token inc if child get type token getvar the var is a number now int i fn get var index child result assign type var type i optim number type break case token setprop case token setprop op if child get type token getvar int i fn get var index child assign type var type i optim ani type while child null result find def point fn child var type child child get next break case token setvar node r valu child get next int the type find express type fn r valu var type int i fn get var index n result assign type var type i the type break return result 
privat boolean do type flow opt function node fn node statement node int var type boolean chang fals for int i it start node index i it end node index i node n statement node i if n null chang find def point fn n var type return chang 
privat boolean is live on entri int index return it live on entri set null it live on entri set test index 
privat void print live on entri set opt function node fn if debug for int i 0 i fn get var count i string name fn fnode get param or var name i if it us befor def set test i system out println name is us befor def d if it not def set test i system out println name is not def d if it live on entri set test i system out println name is live on entri if it live on exit set test i system out println name is live on exit 
static final long serial version uid 5733330028285400526l nativ reg exp ctor 
public string get function name return reg exp 
public object call context cx scriptabl scope scriptabl thi obj object arg if arg length 0 arg 0 instanceof nativ reg exp arg length 1 arg 1 undefin instanc return arg 0 return construct cx scope arg 
public scriptabl construct context cx scriptabl scope object arg nativ reg exp re new nativ reg exp re compil cx scope arg script runtim set object proto and parent re scope return re 
privat static reg exp impl get impl context cx context get current context return reg exp impl script runtim get reg exp proxi cx 
max instanc id dollar id base 9 protect int get max instanc id return super get max instanc id max instanc id 
protect int find instanc id info string s int id gener last updat 2001 05 24 16 09 31 gmt 02 00 l0 id 0 string x null int c l switch s length case 2 switch s char at 1 case if s char at 0 id id ampersand break l0 break l case if s char at 0 id id quot break l0 break l case if s char at 0 id id star break l0 break l case if s char at 0 id id plu break l0 break l case 1 if s char at 0 id id dollar 1 break l0 break l case 2 if s char at 0 id id dollar 2 break l0 break l case 3 if s char at 0 id id dollar 3 break l0 break l case 4 if s char at 0 id id dollar 4 break l0 break l case 5 if s char at 0 id id dollar 5 break l0 break l case 6 if s char at 0 id id dollar 6 break l0 break l case 7 if s char at 0 id id dollar 7 break l0 break l case 8 if s char at 0 id id dollar 8 break l0 break l case 9 if s char at 0 id id dollar 9 break l0 break l case if s char at 0 id id underscor break l0 break l case if s char at 0 id id back quot break l0 break l break l case 5 x input id id input break l case 9 c s char at 4 if c m x last match id id last match els if c p x last paren id id last paren els if c i x multilin id id multilin break l case 11 x left context id id left context break l case 12 x right context id id right context break l if x null x s x equal s id 0 gener if id 0 return super find instanc id info s int attr switch id case id multilin case id star case id input case id underscor attr perman break default attr perman readonli break return instanc id info attr super get max instanc id id 
protect string get instanc id name int id int shift id super get max instanc id if 1 shift shift max instanc id switch shift case id multilin return multilin case id star return case id input return input case id underscor return case id last match return last match case id ampersand return case id last paren return last paren case id plu return case id left context return left context case id back quot return case id right context return right context case id quot return must be on of 1 9 convert to 0 8 int substr number shift dollar id base 1 char buf char 1 substr number return new string buf return super get instanc id name id 
protect object get instanc id valu int id int shift id super get max instanc id if 1 shift shift max instanc id reg exp impl impl get impl object string result switch shift case id multilin case id star return script runtim wrap boolean impl multilin case id input case id underscor string result impl input break case id last match case id ampersand string result impl last match break case id last paren case id plu string result impl last paren break case id left context case id back quot string result impl left context break case id right context case id quot string result impl right context break default must be on of 1 9 convert to 0 8 int substr number shift dollar id base 1 string result impl get paren sub string substr number break return string result null string result to string return super get instanc id valu id 
protect void set instanc id valu int id object valu int shift id super get max instanc id switch shift case id multilin case id star get impl multilin script runtim to boolean valu return case id input case id underscor get impl input script runtim to string valu return super set instanc id valu id valu 
deprec us link wrap except wrap except throwabl to report except in java code public java script except object valu thi valu 0 
creat a java script except wrap the given java script valu param valu the java script valu thrown public java script except object valu string sourc name int line number record error origin sourc name line number null 0 thi valu valu 
public string detail if valu instanceof scriptabl to prevent potenti of evalu and throw more except return script runtim default object to string scriptabl valu return script runtim to string valu 
return the valu wrap by thi except public object get valu return valu 
deprec us link rhino except sourc name from the super class public string get sourc name return sourc name 
deprec us link rhino except line number from the super class public int get line number return line number 
public class data type 012 extend live connect test public data type 012 super 
public static void main string arg data type 012 test new data type 012 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt static get long arrai true do arrai test dt pub static arrai long true do arrai test dt get long arrai true do arrai test dt pub arrai long fals 
assign a java long to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command the command to eval to get the arrai public void do arrai test string command boolean should equal long arrai data type class pub static arrai long long js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java object js arrai long global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai doubl item doubl global eval js arrai i add test case js arrai command global eval js arrai i equal arrai i true item equal new doubl arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal true fals js arrai arrai 
static final long serial version uid 6460763940409461664l public nativ java class 
public nativ java class scriptabl scope class cl thi parent scope thi java object cl init member 
protect void init member class cl class java object member java member lookup class parent cl cl static field and method member get field and method object thi cl true 
public string get class name return java class 
public boolean ha string name scriptabl start return member ha name true 
public object get string name scriptabl start when us as a constructor script runtim new object ask for our prototyp to creat an object of the correct type we don t realli care what the object is sinc we re return on construct out of whole cloth so we return null if name equal prototyp return null object result scriptabl not found if static field and method null result static field and method get name if result null return result if member ha name true result member get thi name java object true els experiment look for nest class by append name to current class name class nest class find nest class get class object name if nest class null throw member report member not found name nativ java class nest valu new nativ java class scriptabl object get top level scope thi nest class nest valu set parent scope thi result nest valu return result 
public void put string name scriptabl start object valu member put thi name java object valu true 
public object get id return member get id true 
public class get class object return class super unwrap 
public object get default valu class hint if hint null hint script runtim string class return thi to string if hint script runtim boolean class return boolean true if hint script runtim number class return script runtim na nobj return thi 
public object call context cx scriptabl scope scriptabl thi obj object arg if it look like a cast of an object to thi class type walk the prototyp chain to see if there s a wrapper of a object that s an instanceof thi class if arg length 1 arg 0 instanceof scriptabl class c get class object scriptabl p scriptabl arg 0 do if p instanceof wrapper object o wrapper p unwrap if c is instanc o return p p p get prototyp while p null return construct cx scope arg 
public scriptabl construct context cx scriptabl scope object arg class class object get class object int modifi class object get modifi if modifi is interfac modifi modifi is abstract modifi member box ctor member ctor int index nativ java method find function cx ctor arg if index 0 string sig nativ java method script signatur arg throw context report runtim error2 msg no java ctor class object get name sig found the constructor so try invok it return construct specif cx scope arg ctor index els scriptabl top level scriptabl object get top level scope thi string msg try try to construct an interfac us java adapt to construct a new class on the fly that implement thi interfac object v top level get java adapt top level if v not found function f function v object adapt arg thi arg 0 return scriptabl f construct cx top level adapt arg catch except ex fall through to error string m ex get messag if m null msg m throw context report runtim error2 msg cant instanti msg class object get name 
static scriptabl construct specif context cx scriptabl scope object arg member box ctor scriptabl top level scriptabl object get top level scope scope class class object ctor get declar class class arg type ctor arg type object orig arg arg for int i 0 i arg length i object arg arg i object x context js to java arg arg type i if x arg if arg orig arg arg object orig arg clone arg i x object instanc ctor new instanc arg we need to forc thi to be wrap becaus construct ha to return a scriptabl return cx get wrap factori wrap new object cx top level instanc 
public string to string return java class get class object get name 
determin if prototyp is a wrap java object and perform a java instanceof except if valu is an instanc of nativ java class it isn t consid an instanc of the java class thi forestal ani name conflict between java lang class s method and the static method expos by a java nativ class public boolean ha instanc scriptabl valu if valu instanceof wrapper valu instanceof nativ java class object instanc wrapper valu unwrap return get class object is instanc instanc valu wasn t someth we understand return fals 
privat static class find nest class class parent class string name string nest class name parent class get name name class loader loader parent class get class loader if loader null alert if loader is null nest class should be load via system class loader which can be differ from the loader that brought rhino class that class for name would us but class loader get system class loader is java 2 onli return kit class or null nest class name els return kit class or null loader nest class name 
public class data type 014 extend live connect test public data type 014 super 
public static void main string arg data type 014 test new data type 014 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt static get float arrai true do arrai test dt pub static arrai float true do arrai test dt get float arrai true do arrai test dt pub arrai float fals 
assign a java float arrai to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command the command to eval to get the float arrai public void do arrai test string command boolean should equal float arrai data type class pub static arrai float float js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java object js arrai float global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai doubl item doubl global eval js arrai i add test case js arrai command global eval js arrai i equal arrai i true item equal new doubl arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal true fals js arrai arrai 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string expect return object 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string expect return short 
public class function node extend script or fn node public function node string name super token function function name name 
public string get function name return function name 
public boolean requir activ return it need activ 
public boolean get ignor dynam scope return it ignor dynam scope 
public static final int function express statement 3 public int get function type return it function type 
call frame clone frozen if frozen kit code bug call frame copi try copi call frame clone catch clone not support except ex throw new illeg state except clone stack but keep var sourc to point to valu from thi frame to share variabl copi stack object stack clone copi s dbl doubl s dbl clone copi frozen fals return copi 
continu jump continu c call frame current thi captur frame call frame c get implement if thi captur frame null current null continu and current execut doe not share ani frame if there is noth to captur or if there is no current execut frame thi branch frame null els search for branch frame where parent frame chain start from captur and current meet call frame chain1 thi captur frame call frame chain2 current first work parent of chain1 or chain2 until the same frame depth int diff chain1 frame index chain2 frame index if diff 0 if diff 0 swap to make sure that chain1 frame index chain2 frame index and diff 0 chain1 current chain2 thi captur frame diff diff do chain1 chain1 parent frame while diff 0 if chain1 frame index chain2 frame index kit code bug now walk parent in parallel until a share frame is found or until the root is reach while chain1 chain2 chain1 null chain1 chain1 parent frame chain2 chain2 parent frame thi branch frame chain1 if thi branch frame null thi branch frame frozen kit code bug 
privat static string bytecod name int bytecod if valid bytecod bytecod throw new illeg argument except string valu of bytecod if token print icod return string valu of bytecod if valid token code bytecod return token name bytecod switch bytecod case icod dup return dup case icod dup2 return dup2 case icod swap return swap case icod pop return pop case icod pop result return pop result case icod ifeq pop return ifeq pop case icod var inc dec return var inc dec case icod name inc dec return name inc dec case icod prop inc dec return prop inc dec case icod elem inc dec return elem inc dec case icod ref inc dec return ref inc dec case icod scope load return scope load case icod scope save return scope save case icod typeofnam return typeofnam case icod name and thi return name and thi case icod prop and thi return prop and thi case icod elem and thi return elem and thi case icod valu and thi return valu and thi case icod closur expr return closur expr case icod closur stmt return closur stmt case icod callspeci return callspeci case icod retundef return retundef case icod gosub return gosub case icod startsub return startsub case icod retsub return retsub case icod line return line case icod shortnumb return shortnumb case icod intnumb return intnumb case icod liter new return liter new case icod liter set return liter set case icod spare arraylit return spare arraylit case icod reg ind c0 return reg ind c0 case icod reg ind c1 return reg ind c1 case icod reg ind c2 return reg ind c2 case icod reg ind c3 return reg ind c3 case icod reg ind c4 return reg ind c4 case icod reg ind c5 return reg ind c5 case icod reg ind1 return load ind1 case icod reg ind2 return load ind2 case icod reg ind4 return load ind4 case icod reg str c0 return reg str c0 case icod reg str c1 return reg str c1 case icod reg str c2 return reg str c2 case icod reg str c3 return reg str c3 case icod reg str1 return load str1 case icod reg str2 return load str2 case icod reg str4 return load str4 case icod getvar1 return getvar1 case icod setvar1 return setvar1 case icod undef return undef case icod zero return zero case icod on return on case icod enterdq return enterdq case icod leavedq return leavedq case icod tail call return tail call case icod local clear return local clear icod without name throw new illeg state except string valu of bytecod 
privat static boolean valid icod int icod return min icod icod icod 1 
privat static boolean valid token code int token return token first bytecod token token token token last bytecod token 
privat static boolean valid bytecod int bytecod return valid icod bytecod valid token code bytecod 
public object compil compil environ compil env script or fn node tree string encod sourc boolean return function thi compil env compil env new node transform transform tree if token print tree system out println tree to string tree tree if return function tree tree get function node 0 script or fn tree it data new interpret data compil env get languag version script or fn get sourc name encod sourc it data top level true if return function gener function icod els gener icod from tree script or fn return it data 
public script creat script object object bytecod object static secur domain interpret data idata interpret data bytecod return interpret function creat script it data static secur domain 
public function creat function object context cx scriptabl scope object bytecod object static secur domain interpret data idata interpret data bytecod return interpret function creat function cx scope it data static secur domain 
privat void gener function icod it in function flag true function node the function function node script or fn it data it function type the function get function type it data it need activ the function requir activ it data it name the function get function name if the function get ignor dynam scope if compil env is us dynam scope it data us dynam scope true gener icod from tree the function get last child 
privat void gener icod from tree node tree gener nest function gener reg exp liter visit statement tree fix label goto add return result onli to script as function alwai end with return if it data it function type 0 add token token return result if it data it icod length it icod top make it data it icod length exactli it icod top to save memori and catch bug with jump beyound icod as earli as possibl byte tmp new byte it icod top system arraycopi it data it icod 0 tmp 0 it icod top it data it icod tmp if it string size 0 it data it string tabl null els it data it string tabl new string it string size obj to int map iter iter it string new iter for iter start iter done iter next string str string iter get kei int index iter get valu if it data it string tabl index null kit code bug it data it string tabl index str if it doubl tabl top 0 it data it doubl tabl null els if it data it doubl tabl length it doubl tabl top doubl tmp new doubl it doubl tabl top system arraycopi it data it doubl tabl 0 tmp 0 it doubl tabl top it data it doubl tabl tmp if it except tabl top 0 it data it except tabl length it except tabl top int tmp new int it except tabl top system arraycopi it data it except tabl 0 tmp 0 it except tabl top it data it except tabl tmp it data it max var script or fn get param and var count it max frame arrai interpret method need thi amount for it stack and s dbl arrai it data it max frame arrai it data it max var it data it max local it data it max stack it data arg name script or fn get param and var name it data arg count script or fn get param count it data encod sourc start script or fn get encod sourc start it data encod sourc end script or fn get encod sourc end if it liter id size 0 it data liter id it liter id to arrai if token print icod dump icod it data 
privat void gener nest function int function count script or fn get function count if function count 0 return interpret data arrai new interpret data function count for int i 0 i function count i function node def script or fn get function node i interpret jsi new interpret jsi compil env compil env jsi script or fn def jsi it data new interpret data it data jsi gener function icod arrai i jsi it data it data it nest function arrai 
privat void gener reg exp liter int n script or fn get regexp count if n 0 return context cx context get context reg exp proxi rep script runtim check reg exp proxi cx object arrai new object n for int i 0 i n i string string script or fn get regexp string i string flag script or fn get regexp flag i arrai i rep compil reg exp cx string flag it data it reg exp liter arrai 
privat void updat line number node node int lineno node get lineno if lineno it line number lineno 0 if it data first line pc 0 it data first line pc lineno it line number lineno add icod icod line add uint16 lineno 0x ffff 
privat runtim except bad tree node node throw new runtim except node to string 
privat void visit statement node node int type node get type node child node get first child switch type case token function int fn index node get exist int prop node function prop int fn type script or fn get function node fn index get function type onli function express or function express statement need closur code creat new function object on stack as function statement ar initi at script function start in addit function express can not present here at statement level thei must onli present as express if fn type function node function express statement add index op icod closur stmt fn index els if fn type function node function statement throw kit code bug break case token script case token label case token loop case token block case token empti case token with updat line number node while child null visit statement child child child get next break case token enterwith visit express child 0 add token token enterwith stack chang 1 break case token leavewith add token token leavewith break case token local block int local alloc local node put int prop node local prop local updat line number node while child null visit statement child child child get next add index op icod local clear local releas local local break case token switch updat line number node see comment in irfactori creat switch for descript of switch node node switch node node jump node visit express child 0 for node jump case node node jump child get next case node null case node node jump case node get next if case node get type token case throw bad tree case node node test case node get first child add icod icod dup stack chang 1 visit express test 0 add token token sheq stack chang 1 if true icod ifeq pop will jump and remov case valu from stack add goto case node target icod ifeq pop stack chang 1 add icod icod pop stack chang 1 break case token target mark target label node break case token ifeq case token ifn node target node jump node target visit express child 0 add goto target type stack chang 1 break case token goto node target node jump node target add goto target type break case token jsr node target node jump node target add goto target icod gosub break case token final account for incom gotosub address stack chang 1 int final regist get local block ref node add index op icod startsub final regist stack chang 1 while child null visit statement child child child get next add index op icod retsub final regist break case token expr void case token expr result updat line number node visit express child 0 add icod type token expr void icod pop icod pop result stack chang 1 break case token try node jump try node node jump node int except object local get local block ref try node int scope local alloc local add index op icod scope save scope local int try start it icod top while child null visit statement child child child get next node catch target try node target if catch target null int catch start pc it label tabl get target label catch target add except handler try start catch start pc catch start pc fals except object local scope local node final target try node get final if final target null int final start pc it label tabl get target label final target add except handler try start final start pc final start pc true except object local scope local add index op icod local clear scope local releas local scope local break case token catch scope int local index get local block ref node int scope index node get exist int prop node catch scope prop string name child get string child child get next visit express child 0 load express object add string prefix name add index prefix local index add token token catch scope add uint8 scope index 0 1 0 stack chang 1 break case token throw updat line number node visit express child 0 add token token throw add uint16 it line number 0x ffff stack chang 1 break case token rethrow updat line number node add index op token rethrow get local block ref node break case token return updat line number node if child null visit express child ecf tail add token token return stack chang 1 els add icod icod retundef break case token return result updat line number node add token token return result break case token enum init kei case token enum init valu visit express child 0 add index op type get local block ref node stack chang 1 break default throw bad tree node if it stack depth 0 throw kit code bug 
privat void visit express node node int context flag int type node get type node child node get first child int save stack depth it stack depth switch type case token function int fn index node get exist int prop node function prop function node fn script or fn get function node fn index see comment in visit statement for token function case if fn get function type function node function express throw kit code bug add index op icod closur expr fn index stack chang 1 break case token local load int local index get local block ref node add index op token local load local index stack chang 1 break case token comma node last child node get last child while child last child visit express child 0 add icod icod pop stack chang 1 child child get next preserv tail context flag if ani visit express child context flag ecf tail break case token us stack indic that stack wa modifi extern like place catch object stack chang 1 break case token ref call case token call case token new if type token new visit express child 0 els gener call fun and thi child int arg count 0 while child child get next null visit express child 0 arg count int call type node get int prop node specialcal prop node non specialcal if call type node non specialcal emb line number and sourc filenam add index op icod callspeci arg count add uint8 call type add uint8 type token new 1 0 add uint16 it line number 0x ffff els if type token call if context flag ecf tail 0 type icod tail call add index op type arg count adjust stack if type token new new f arg result stack chang arg count els call f thi obj arg result ref call f thi obj arg ref stack chang 1 arg count if arg count it data it max calle arg it data it max calle arg arg count break case token and case token or visit express child 0 add icod icod dup stack chang 1 int after second jump start it icod top int jump type token and token ifn token ifeq add goto op jump stack chang 1 add icod icod pop stack chang 1 child child get next preserv tail context flag if ani visit express child context flag ecf tail resolv forward goto after second jump start break case token hook node if then child get next node if els if then get next visit express child 0 int els jump start it icod top add goto op token ifn stack chang 1 preserv tail context flag if ani visit express if then context flag ecf tail int after els jump start it icod top add goto op token goto resolv forward goto els jump start it stack depth save stack depth preserv tail context flag if ani visit express if els context flag ecf tail resolv forward goto after els jump start break case token getprop visit express child 0 child child get next add string op token getprop child get string break case token getelem case token delprop case token bitand case token bitor case token bitxor case token lsh case token rsh case token ursh case token add case token sub case token mod case token div case token mul case token eq case token ne case token sheq case token shne case token in case token instanceof case token le case token lt case token ge case token gt visit express child 0 child child get next visit express child 0 add token type stack chang 1 break case token po case token neg case token not case token bitnot case token typeof case token void visit express child 0 if type token void add icod icod pop add icod icod undef els add token type break case token get ref case token del ref visit express child 0 add token type break case token setprop case token setprop op visit express child 0 child child get next string properti child get string child child get next if type token setprop op add icod icod dup stack chang 1 add string op token getprop properti compens for the follow us stack stack chang 1 visit express child 0 add string op token setprop properti stack chang 1 break case token setelem case token setelem op visit express child 0 child child get next visit express child 0 child child get next if type token setelem op add icod icod dup2 stack chang 2 add token token getelem stack chang 1 compens for the follow us stack stack chang 1 visit express child 0 add token token setelem stack chang 2 break case token set ref case token set ref op visit express child 0 child child get next if type token set ref op add icod icod dup stack chang 1 add token token get ref compens for the follow us stack stack chang 1 visit express child 0 add token token set ref stack chang 1 break case token setnam string name child get string visit express child 0 child child get next visit express child 0 add string op token setnam name stack chang 1 break case token typeofnam string name node get string int index 1 us typeofnam if an activ frame exist sinc the var all exist there instead of in jreg if it in function flag it data it need activ index script or fn get param or var index name if index 1 add string op icod typeofnam name stack chang 1 els add var op token getvar index stack chang 1 add token token typeof break case token bindnam case token name case token string add string op type node get string stack chang 1 break case token inc case token dec visit inc dec node child break case token number doubl num node get doubl int inum int num if inum num if inum 0 add icod icod zero check for neg zero if 1 0 num 0 0 add token token neg els if inum 1 add icod icod on els if short inum inum add icod icod shortnumb write short as uin16 bit pattern add uint16 inum 0x ffff els add icod icod intnumb add int inum els int index get doubl index num add index op token number index stack chang 1 break case token getvar if it data it need activ kit code bug string name node get string int index script or fn get param or var index name add var op token getvar index stack chang 1 break case token setvar if it data it need activ kit code bug string name child get string child child get next visit express child 0 int index script or fn get param or var index name add var op token setvar index break case token null case token thi case token thisfn case token fals case token true add token type stack chang 1 break case token enum next case token enum id add index op type get local block ref node stack chang 1 break case token regexp int index node get exist int prop node regexp prop add index op token regexp index stack chang 1 break case token arraylit case token objectlit visit liter node child break case token ref special visit express child 0 add string op type string node get prop node name prop break case token ref member case token ref ns member case token ref name case token ref ns name int member type flag node get int prop node member type prop 0 gener possibl target possibl namespac and member int child count 0 do visit express child 0 child count child child get next while child null add index op type member type flag stack chang 1 child count break case token dotqueri int queri pc updat line number node visit express child 0 add icod icod enterdq stack chang 1 queri pc it icod top visit express child get next 0 add backward goto icod leavedq queri pc break case token defaultnamespac case token escxmlattr case token escxmltext visit express child 0 add token type break default throw bad tree node if save stack depth 1 it stack depth kit code bug 
privat void gener call fun and thi node left gener code to place on stack function and thi obj int type left get type switch type case token name string name left get string stack function thi obj add string op icod name and thi name stack chang 2 break case token getprop case token getelem node target left get first child visit express target 0 node id target get next if type token getprop string properti id get string stack target function thi obj add string op icod prop and thi properti stack chang 1 els visit express id 0 stack target id function thi obj add icod icod elem and thi break default includ token getvar visit express left 0 stack valu function thi obj add icod icod valu and thi stack chang 1 break 
privat void visit inc dec node node node child int incr decr mask node get exist int prop node incrdecr prop int child type child get type switch child type case token getvar if it data it need activ kit code bug string name child get string int i script or fn get param or var index name add var op icod var inc dec i add uint8 incr decr mask stack chang 1 break case token name string name child get string add string op icod name inc dec name add uint8 incr decr mask stack chang 1 break case token getprop node object child get first child visit express object 0 string properti object get next get string add string op icod prop inc dec properti add uint8 incr decr mask break case token getelem node object child get first child visit express object 0 node index object get next visit express index 0 add icod icod elem inc dec add uint8 incr decr mask stack chang 1 break case token get ref node ref child get first child visit express ref 0 add icod icod ref inc dec add uint8 incr decr mask break default throw bad tree node 
privat void visit liter node node node child int type node get type int count object properti id null if type token arraylit count 0 for node n child n null n n get next count els if type token objectlit properti id object node get prop node object id prop count properti id length els throw bad tree node add index op icod liter new count stack chang 1 while child null visit express child 0 add icod icod liter set stack chang 1 child child get next if type token arraylit int skip index int node get prop node skip index prop if skip index null add token token arraylit els int index it liter id size it liter id add skip index add index op icod spare arraylit index els int index it liter id size it liter id add properti id add index op token objectlit index 
privat int get local block ref node node node local block node node get prop node local block prop return local block get exist int prop node local prop 
privat int get target label node target int label target label id if label 1 return label label it label tabl top if it label tabl null label it label tabl length if it label tabl null it label tabl new int min label tabl size els int tmp new int it label tabl length 2 system arraycopi it label tabl 0 tmp 0 label it label tabl tmp it label tabl top label 1 it label tabl label 1 target label id label return label 
privat void mark target label node target int label get target label target if it label tabl label 1 can mark label onli onc kit code bug it label tabl label it icod top 
privat void add goto node target int goto op int label get target label target if label it label tabl top kit code bug int target pc it label tabl label if target pc 1 add backward goto goto op target pc els int goto pc it icod top add goto op goto op int top it fixup tabl top if it fixup tabl null top it fixup tabl length if it fixup tabl null it fixup tabl new long min fixup tabl size els long tmp new long it fixup tabl length 2 system arraycopi it fixup tabl 0 tmp 0 top it fixup tabl tmp it fixup tabl top top 1 it fixup tabl top long label 32 goto pc 
privat void fix label goto for int i 0 i it fixup tabl top i long fixup it fixup tabl i int label int fixup 32 int jump sourc int fixup int pc it label tabl label if pc 1 unloc label throw kit code bug resolv goto jump sourc pc it fixup tabl top 0 
privat void add backward goto int goto op int jump pc int from pc it icod top ensur that thi is a jump backward if from pc jump pc throw kit code bug add goto op goto op resolv goto from pc jump pc 
privat void resolv forward goto int from pc ensur that forward jump skip at least self bytecod if it icod top from pc 3 throw kit code bug resolv goto from pc it icod top 
privat void resolv goto int from pc int jump pc int offset jump pc from pc ensur that jump do not overlap if 0 offset offset 2 throw kit code bug int offset site from pc 1 if offset short offset if it data long jump null it data long jump new uint map it data long jump put offset site jump pc offset 0 byte arrai it data it icod arrai offset site byte offset 8 arrai offset site 1 byte offset 
privat void add token int token if valid token code token throw kit code bug add uint8 token 
privat void add icod int icod if valid icod icod throw kit code bug write neg icod as uint8 bit add uint8 icod 0x ff 
privat void add uint8 int valu if valu 0x ff 0 throw kit code bug byte arrai it data it icod int top it icod top if top arrai length arrai increas icod capas 1 arrai top byte valu it icod top top 1 
privat void add uint16 int valu if valu 0x ffff 0 throw kit code bug byte arrai it data it icod int top it icod top if top 2 arrai length arrai increas icod capas 2 arrai top byte valu 8 arrai top 1 byte valu it icod top top 2 
privat void add int int i byte arrai it data it icod int top it icod top if top 4 arrai length arrai increas icod capas 4 arrai top byte i 24 arrai top 1 byte i 16 arrai top 2 byte i 8 arrai top 3 byte i it icod top top 4 
privat int get doubl index doubl num int index it doubl tabl top if index 0 it data it doubl tabl new doubl 64 els if it data it doubl tabl length index doubl na new doubl index 2 system arraycopi it data it doubl tabl 0 na 0 index it data it doubl tabl na it data it doubl tabl index num it doubl tabl top index 1 return index 
privat void add goto op int goto op byte arrai it data it icod int top it icod top if top 3 arrai length arrai increas icod capas 3 arrai top byte goto op offset would written later it icod top top 1 2 
privat void add var op int op int var index switch op case token getvar case token setvar if var index 128 add icod op token getvar icod getvar1 icod setvar1 add uint8 var index return fallthrough case icod var inc dec add index op op var index return throw kit code bug 
privat void add string op int op string str add string prefix str if valid icod op add icod op els add token op 
privat void add index op int op int index add index prefix index if valid icod op add icod op els add token op 
privat void add string prefix string str int index it string get str 1 if index 1 index it string size it string put str index if index 4 add icod icod reg str c0 index els if index 0x ff add icod icod reg str1 add uint8 index els if index 0x ffff add icod icod reg str2 add uint16 index els add icod icod reg str4 add int index 
privat void add index prefix int index if index 0 kit code bug if index 6 add icod icod reg ind c0 index els if index 0x ff add icod icod reg ind1 add uint8 index els if index 0x ffff add icod icod reg ind2 add uint16 index els add icod icod reg ind4 add int index 
privat void add except handler int icod start int icod end int handler start boolean is final int except object local int scope local int top it except tabl top int tabl it data it except tabl if tabl null if top 0 kit code bug tabl new int except slot size 2 it data it except tabl tabl els if tabl length top tabl new int tabl length 2 system arraycopi it data it except tabl 0 tabl 0 top it data it except tabl tabl tabl top except try start slot icod start tabl top except try end slot icod end tabl top except handler slot handler start tabl top except type slot is final 1 0 tabl top except local slot except object local tabl top except scope slot scope local it except tabl top top except slot size 
privat byte increas icod capas int extra size int capac it data it icod length int top it icod top if top extra size capac throw kit code bug capac 2 if top extra size capac capac top extra size byte arrai new byte capac system arraycopi it data it icod 0 arrai 0 top it data it icod arrai return arrai 
privat void stack chang int chang if chang 0 it stack depth chang els int new depth it stack depth chang if new depth it data it max stack it data it max stack new depth it stack depth new depth 
privat int alloc local int local slot it local top it local top if it local top it data it max local it data it max local it local top return local slot 
privat void releas local int local slot it local top if local slot it local top kit code bug 
privat static int get short byte i code int pc return i code pc 8 i code pc 1 0x ff 
privat static int get index byte i code int pc return i code pc 0x ff 8 i code pc 1 0x ff 
privat static int get int byte i code int pc return i code pc 24 i code pc 1 0x ff 16 i code pc 2 0x ff 8 i code pc 3 0x ff 
privat static int get except handler call frame frame boolean onli final int except tabl frame idata it except tabl if except tabl null no except handler return 1 icod switch in the interpret increment pc immedi and it is necessari to subtract 1 from the save pc to point it befor the start of the next instruct int pc frame pc 1 opt us binari search int best 1 best start 0 best end 0 for int i 0 i except tabl length i except slot size int start except tabl i except try start slot int end except tabl i except try end slot if start pc pc end continu if onli final except tabl i except type slot 1 continu if best 0 sinc handler alwai nest and thei never have share end although thei can share start it is suffici to compar handler end if best end end continu check the abov assumpt if best start start kit code bug should be nest if best end end kit code bug no en share best i best start start best end end return best 
privat static void dump icod interpret data idata if token print icod return byte i code idata it icod int i code length i code length string string idata it string tabl print stream out system out out println icod dump for idata it name length i code length out println max stack idata it max stack int index reg 0 for int pc 0 pc i code length out flush out print pc int token i code pc int icod length bytecod span token string tname bytecod name token int old pc pc pc switch token default if icod length 1 kit code bug out println tname break case icod gosub case token goto case token ifeq case token ifn case icod ifeq pop case icod leavedq int new pc pc get short i code pc 1 out println tname new pc pc 2 break case icod var inc dec case icod name inc dec case icod prop inc dec case icod elem inc dec case icod ref inc dec int incr decr type i code pc out println tname incr decr type pc break case icod callspeci int call type i code pc 0x ff boolean is new i code pc 1 0 int line get index i code pc 2 out println tname call type is new index reg line pc 4 break case token catch scope boolean after fisrt flag i code pc 0 out println tname after fisrt flag pc break case token regexp out println tname idata it reg exp liter index reg break case token objectlit case icod spare arraylit out println tname idata liter id index reg break case icod closur expr case icod closur stmt out println tname idata it nest function index reg break case token call case icod tail call case token ref call case token new out println tname index reg break case token throw int line get index i code pc out println tname line pc 2 break case icod shortnumb int valu get short i code pc out println tname valu pc 2 break case icod intnumb int valu get int i code pc out println tname valu pc 4 break case token number doubl valu idata it doubl tabl index reg out println tname valu pc 2 break case icod line int line get index i code pc out println tname line pc 2 break case icod reg str1 string str string 0x ff i code pc out println tname str pc break case icod reg str2 string str string get index i code pc out println tname str pc 2 break case icod reg str4 string str string get int i code pc out println tname str pc 4 break case icod reg ind1 index reg 0x ff i code pc out println tname index reg pc break case icod reg ind2 index reg get index i code pc out println tname index reg pc 2 break case icod reg ind4 index reg get int i code pc out println tname index reg pc 4 break case icod getvar1 case icod setvar1 index reg i code pc out println tname index reg pc break if old pc icod length pc kit code bug int tabl idata it except tabl if tabl null out println except handler tabl length except slot size for int i 0 i tabl length i except slot size int try start tabl i except try start slot int try end tabl i except try end slot int handler start tabl i except handler slot int type tabl i except type slot int except local tabl i except local slot int scope local tabl i except scope slot out println try start try start try end try end handler start handler start type type 0 catch final except local except local out flush 
privat static int bytecod span int bytecod switch bytecod case token throw sourc line return 1 2 case icod gosub case token goto case token ifeq case token ifn case icod ifeq pop case icod leavedq target pc offset return 1 2 case icod callspeci call type is new line number return 1 1 1 2 case token catch scope scope flag return 1 1 case icod var inc dec case icod name inc dec case icod prop inc dec case icod elem inc dec case icod ref inc dec type of return 1 1 case icod shortnumb short number return 1 2 case icod intnumb int number return 1 4 case icod reg ind1 ubyt index return 1 1 case icod reg ind2 ushort index return 1 2 case icod reg ind4 int index return 1 4 case icod reg str1 ubyt string index return 1 1 case icod reg str2 ushort string index return 1 2 case icod reg str4 int string index return 1 4 case icod getvar1 case icod setvar1 byte var index return 1 1 case icod line line number return 1 2 if valid bytecod bytecod throw kit code bug return 1 
static int get line number interpret data data uint map present line new uint map byte i code data it icod int i code length i code length for int pc 0 pc i code length int bytecod i code pc int span bytecod span bytecod if bytecod icod line if span 3 kit code bug int line get index i code pc 1 present line put line 0 pc span return present line get kei 
static void captur interpret stack info rhino except ex context cx context get current context if cx null cx last interpret frame null no interpret invoc ex interpret stack info null ex interpret line data null return ha interpret frame on the stack call frame arrai if cx previou interpret invoc null cx previou interpret invoc size 0 arrai new call frame 1 els int previou count cx previou interpret invoc size if cx previou interpret invoc peek cx last interpret frame it can happen if except wa gener after frame wa push to cx previou interpret invoc but befor assign to cx last interpret frame in thi case frame ha to be ignor previou count arrai new call frame previou count 1 cx previou interpret invoc to arrai arrai arrai arrai length 1 call frame cx last interpret frame int interpret frame count 0 for int i 0 i arrai length i interpret frame count 1 arrai i frame index int line pc new int interpret frame count fill line pc with pc posit from all interpret frame start from the most nest frame int line pcindex interpret frame count for int i arrai length i 0 i call frame frame arrai i while frame null line pcindex line pc line pcindex frame pc sourc line start frame frame parent frame if line pcindex 0 kit code bug ex interpret stack info arrai ex interpret line data line pc 
static string get sourc posit from stack context cx int linep call frame frame call frame cx last interpret frame interpret data idata frame idata if frame pc sourc line start 0 linep 0 get index idata it icod frame pc sourc line start els linep 0 0 return idata it sourc file 
static string get patch stack rhino except ex string nativ stack trace string tag org mozilla javascript interpret interpret loop string buffer sb new string buffer nativ stack trace length 1000 string line separ system get properti line separ call frame arrai call frame ex interpret stack info int line pc ex interpret line data int arrai index arrai length int line pcindex line pc length int offset 0 while arrai index 0 arrai index int po nativ stack trace index of tag offset if po 0 break skip tag length po tag length skip until the end of line for po nativ stack trace length po char c nativ stack trace char at po if c n c r break sb append nativ stack trace substr offset po offset po call frame frame arrai arrai index while frame null if line pcindex 0 kit code bug line pcindex interpret data idata frame idata sb append line separ sb append tat script if idata it name null idata it name length 0 sb append sb append idata it name sb append sb append idata it sourc file int pc line pc line pcindex if pc 0 includ line info onli if avail sb append sb append get index idata it icod pc sb append frame frame parent frame sb append nativ stack trace substr offset return sb to string 
static string get encod sourc interpret data idata if idata encod sourc null return null return idata encod sourc substr idata encod sourc start idata encod sourc end 
privat static void init function context cx scriptabl scope interpret function parent int index interpret function fn fn interpret function creat function cx scope parent index script runtim init function cx scope fn fn idata it function type parent idata eval script flag 
static object interpret interpret function ifun context cx scriptabl scope scriptabl thi obj object arg if script runtim ha top call cx kit code bug if cx interpret secur domain ifun secur domain object save domain cx interpret secur domain cx interpret secur domain ifun secur domain try return ifun secur control call with domain ifun secur domain cx ifun scope thi obj arg final cx interpret secur domain save domain call frame frame new call frame init frame cx scope thi obj arg null 0 arg length ifun null frame return interpret loop cx frame null 
public static object restart continu continu c context cx scriptabl scope object arg if script runtim ha top call cx return script runtim do top call c cx scope null arg object arg if arg length 0 arg undefin instanc els arg arg 0 call frame captur frame call frame c get implement if captur frame null no frame to restart return arg continu jump cjump new continu jump c null cjump result arg return interpret loop cx null cjump 
privat static object interpret loop context cx call frame frame object throwabl throwabl hold except object to rethrow or catch it is also us for continu restart in which case it hold continu jump final object dbl mrk uniqu tag doubl mark final object undefin undefin instanc final boolean instruct count cx instruct threshold 0 arbitrari number to add to instruct count when call other function final int invoc cost 100 arbitrari except cost for instruct count final int except cost 100 string string reg null int index reg 1 if cx last interpret frame null save the top frame from the previou interpret loop invoc on the stack if cx previou interpret invoc null cx previou interpret invoc new obj arrai cx previou interpret invoc push cx last interpret frame when restart continu throwabl is not null and to jump to the code that rewind continu state index reg should be set to 1 with the normal call throabl null and index reg 1 allow to catch bug with us ind reg to access arrai eleemnt befor initi index reg if throwabl null assert assumpt if throwabl instanceof continu jump it should be continu kit code bug object interpret result null doubl interpret result dbl 0 0 state loop for without except try if throwabl null recov from except index reg contain the index of handler if index reg 0 normal excepton handler transfer control appropri if frame frozen xxx deal with exceptio frame frame clone frozen int tabl frame idata it except tabl frame pc tabl index reg except handler slot if instruct count frame pc prev branch frame pc frame save stack top frame empti stack top int scope local frame local shift tabl index reg except scope slot int ex local frame local shift tabl index reg except local slot frame scope scriptabl frame stack scope local frame stack ex local throwabl throwabl null els continu restor continu jump cjump continu jump throwabl clear throwabl to indic that execpt ar ok throwabl null if cjump branch frame frame kit code bug check that we have at least on frozen frame in the case of detach continu restor unwind code ensur that if cjump captur frame null kit code bug need to rewind branch frame captur frame and all frame in between int rewind count cjump captur frame frame index 1 if cjump branch frame null rewind count cjump branch frame frame index int enter count 0 call frame enter frame null call frame x cjump captur frame for int i 0 i rewind count i if x frozen kit code bug if is frame enter exit requir x if enter frame null alloc enough space to store the rest of rewind frame in case all of them would requir to enter enter frame new call frame rewind count i enter frame enter count x enter count x x parent frame while enter count 0 execut enter walk enter frame in the revers order sinc thei were store start from the captur frame not branch frame enter count x enter frame enter count enter frame cx x script runtim empti arg continu jump is almost done captur frame point to the call to the function that captur continu so clone captur frame and emul return that function with the supli result frame cjump captur frame clone frozen set call result frame cjump result cjump result dbl restart the execut should be alreadi clear if throwabl null kit code bug els if frame frozen kit code bug us local variabl for constant valu in frame for faster access object stack frame stack doubl s dbl frame s dbl object var frame var sourc stack doubl var dbl frame var sourc s dbl byte i code frame idata it icod string string frame idata it string tabl us local for stack top as well sinc execpt handler can onli exist at statement level where stack is empti it is necessari to save restor stack top onli accross function call and normal return int stack top frame save stack top store new frame in cx which is us for error report etc cx last interpret frame frame loop for except handler assum that pc is alreadi increment pass the instruct start when it search the except handler int op i code frame pc jumpless run back indent to eas imlement read switch op case token throw object valu stack stack top if valu dbl mrk valu script runtim wrap number s dbl stack top stack top int sourc line get index i code frame pc throwabl new java script except valu frame idata it sourc file sourc line break without except case token rethrow index reg frame local shift throwabl stack index reg break without except case token ge case token le case token gt case token lt stack top object rh stack stack top 1 object lh stack stack top boolean val bln object compar number compar doubl r dbl l dbl if rh dbl mrk r dbl s dbl stack top 1 l dbl stack doubl frame stack top els if lh dbl mrk r dbl script runtim to number rh l dbl s dbl stack top els break number compar switch op case token ge val bln l dbl r dbl break object compar case token le val bln l dbl r dbl break object compar case token gt val bln l dbl r dbl break object compar case token lt val bln l dbl r dbl break object compar default throw kit code bug switch op case token ge val bln script runtim cmp le rh lh break case token le val bln script runtim cmp le lh rh break case token gt val bln script runtim cmp lt rh lh break case token lt val bln script runtim cmp lt lh rh break default throw kit code bug stack stack top script runtim wrap boolean val bln continu loop case token in case token instanceof object rh stack stack top if rh dbl mrk rh script runtim wrap number s dbl stack top stack top object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top boolean val bln if op token in val bln script runtim in lh rh cx els val bln script runtim instanc of lh rh cx stack stack top script runtim wrap boolean val bln continu loop case token eq case token ne stack top boolean val bln object rh stack stack top 1 object lh stack stack top if rh dbl mrk if lh dbl mrk val bln s dbl stack top s dbl stack top 1 els val bln script runtim eq number s dbl stack top 1 lh els if lh dbl mrk val bln script runtim eq number s dbl stack top rh els val bln script runtim eq lh rh val bln op token ne stack stack top script runtim wrap boolean val bln continu loop case token sheq case token shne stack top object rh stack stack top 1 object lh stack stack top boolean val bln shallow compar doubl rdbl ldbl if rh dbl mrk rdbl s dbl stack top 1 if lh dbl mrk ldbl s dbl stack top els if lh instanceof number ldbl number lh doubl valu els val bln fals break shallow compar els if lh dbl mrk ldbl s dbl stack top if rh dbl mrk rdbl s dbl stack top 1 els if rh instanceof number rdbl number rh doubl valu els val bln fals break shallow compar els val bln script runtim shallow eq lh rh break shallow compar val bln ldbl rdbl val bln op token shne stack stack top script runtim wrap boolean val bln continu loop case token ifn if stack boolean frame stack top frame pc 2 continu loop break jumpless run case token ifeq if stack boolean frame stack top frame pc 2 continu loop break jumpless run case icod ifeq pop if stack boolean frame stack top frame pc 2 continu loop stack stack top null break jumpless run case token goto break jumpless run case icod gosub stack top stack stack top dbl mrk s dbl stack top frame pc 2 break jumpless run case icod startsub if stack top frame empti stack top 1 call from icod gosub store return pc address in the local index reg frame local shift stack index reg stack stack top s dbl index reg s dbl stack top stack top els call from except handler except object is alreadi store in the local if stack top frame empti stack top kit code bug continu loop case icod retsub index reg local to store return address if instruct count add instruct count cx frame 0 index reg frame local shift object valu stack index reg if valu dbl mrk invoc from except handler restor object to rethrow throwabl valu break without except normal return from gosub frame pc int s dbl index reg if instruct count frame pc prev branch frame pc continu loop case icod pop stack stack top null stack top continu loop case icod pop result frame result stack stack top frame result dbl s dbl stack top stack stack top null stack top continu loop case icod dup stack stack top 1 stack stack top s dbl stack top 1 s dbl stack top stack top continu loop case icod dup2 stack stack top 1 stack stack top 1 s dbl stack top 1 s dbl stack top 1 stack stack top 2 stack stack top s dbl stack top 2 s dbl stack top stack top 2 continu loop case icod swap object o stack stack top stack stack top stack stack top 1 stack stack top 1 o doubl d s dbl stack top s dbl stack top s dbl stack top 1 s dbl stack top 1 d continu loop case token return frame result stack stack top frame result dbl s dbl stack top stack top break loop case token return result break loop case icod retundef frame result undefin break loop case token bitnot int r int valu stack int32 frame stack top stack stack top dbl mrk s dbl stack top r int valu continu loop case token bitand case token bitor case token bitxor case token lsh case token rsh int r int valu stack int32 frame stack top stack top int l int valu stack int32 frame stack top stack stack top dbl mrk switch op case token bitand l int valu r int valu break case token bitor l int valu r int valu break case token bitxor l int valu r int valu break case token lsh l int valu r int valu break case token rsh l int valu r int valu break s dbl stack top l int valu continu loop case token ursh int r int valu stack int32 frame stack top 0x1f stack top doubl l dbl stack doubl frame stack top stack stack top dbl mrk s dbl stack top script runtim to uint32 l dbl r int valu continu loop case token neg case token po doubl r dbl stack doubl frame stack top stack stack top dbl mrk if op token neg r dbl r dbl s dbl stack top r dbl continu loop case token add stack top do add stack s dbl stack top cx continu loop case token sub case token mul case token div case token mod doubl r dbl stack doubl frame stack top stack top doubl l dbl stack doubl frame stack top stack stack top dbl mrk switch op case token sub l dbl r dbl break case token mul l dbl r dbl break case token div l dbl r dbl break case token mod l dbl r dbl break s dbl stack top l dbl continu loop case token not stack stack top script runtim wrap boolean stack boolean frame stack top continu loop case token bindnam stack stack top script runtim bind cx frame scope string reg continu loop case token setnam object rh stack stack top if rh dbl mrk rh script runtim wrap number s dbl stack top stack top scriptabl lh scriptabl stack stack top stack stack top script runtim set name lh rh cx frame scope string reg continu loop case token delprop object rh stack stack top if rh dbl mrk rh script runtim wrap number s dbl stack top stack top object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack stack top script runtim delet lh rh cx continu loop case token getprop object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack stack top script runtim get object prop lh string reg cx continu loop case token setprop object rh stack stack top if rh dbl mrk rh script runtim wrap number s dbl stack top stack top object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack stack top script runtim set object prop lh string reg rh cx continu loop case icod prop inc dec object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack stack top script runtim prop incr decr lh string reg cx i code frame pc frame pc continu loop case token getelem stack top object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top object valu object id stack stack top 1 if id dbl mrk valu script runtim get object elem lh id cx els doubl d s dbl stack top 1 valu script runtim get object index lh d cx stack stack top valu continu loop case token setelem stack top 2 object rh stack stack top 2 if rh dbl mrk rh script runtim wrap number s dbl stack top 2 object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top object valu object id stack stack top 1 if id dbl mrk valu script runtim set object elem lh id rh cx els doubl d s dbl stack top 1 valu script runtim set object index lh d rh cx stack stack top valu continu loop case icod elem inc dec object rh stack stack top if rh dbl mrk rh script runtim wrap number s dbl stack top stack top object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack stack top script runtim elem incr decr lh rh cx i code frame pc frame pc continu loop case token get ref ref ref ref stack stack top stack stack top script runtim ref get ref cx continu loop case token set ref object valu stack stack top if valu dbl mrk valu script runtim wrap number s dbl stack top stack top ref ref ref stack stack top stack stack top script runtim ref set ref valu cx continu loop case token del ref ref ref ref stack stack top stack stack top script runtim ref del ref cx continu loop case icod ref inc dec ref ref ref stack stack top stack stack top script runtim ref incr decr ref cx i code frame pc frame pc continu loop case token local load stack top index reg frame local shift stack stack top stack index reg s dbl stack top s dbl index reg continu loop case icod local clear index reg frame local shift stack index reg null continu loop case icod name and thi string reg name stack top stack stack top script runtim get name function and thi string reg cx frame scope stack top stack stack top script runtim last store scriptabl cx continu loop case icod prop and thi object obj stack stack top if obj dbl mrk obj script runtim wrap number s dbl stack top string reg properti stack stack top script runtim get prop function and thi obj string reg cx stack top stack stack top script runtim last store scriptabl cx continu loop case icod elem and thi object obj stack stack top 1 if obj dbl mrk obj script runtim wrap number s dbl stack top 1 object id stack stack top if id dbl mrk id script runtim wrap number s dbl stack top stack stack top 1 script runtim get elem function and thi obj id cx stack stack top script runtim last store scriptabl cx continu loop case icod valu and thi object valu stack stack top if valu dbl mrk valu script runtim wrap number s dbl stack top stack stack top script runtim get valu function and thi valu cx stack top stack stack top script runtim last store scriptabl cx continu loop case icod callspeci if instruct count cx instruct count invoc cost int call type i code frame pc 0x ff boolean is new i code frame pc 1 0 int sourc line get index i code frame pc 2 index reg number of argument if is new stack chang function arg0 arg n new result stack top index reg object function stack stack top if function dbl mrk function script runtim wrap number s dbl stack top object out arg get arg arrai stack s dbl stack top 1 index reg stack stack top script runtim new special cx function out arg frame scope call type els stack chang function thi obj arg0 arg n result stack top 1 index reg call code gener ensur that stack here is callabl scriptabl scriptabl function thi scriptabl stack stack top 1 callabl function callabl stack stack top object out arg get arg arrai stack s dbl stack top 2 index reg stack stack top script runtim call special cx function function thi out arg frame scope frame thi obj call type frame idata it sourc file sourc line frame pc 4 continu loop case token call case icod tail call case token ref call if instruct count cx instruct count invoc cost stack chang function thi obj arg0 arg n result index reg number of argument stack top 1 index reg call gener ensur that fun and fun thi obj ar alreadi scriptabl and callabl object respect callabl fun callabl stack stack top scriptabl fun thi obj scriptabl stack stack top 1 if op token ref call object out arg get arg arrai stack s dbl stack top 2 index reg stack stack top script runtim call ref fun fun thi obj out arg cx continu loop scriptabl calle scope frame scope if frame us activ calle scope scriptabl object get top level scope frame scope if fun instanceof interpret function interpret function ifun interpret function fun if frame fn or script secur domain ifun secur domain call frame call parent frame frame call frame calle frame new call frame if op icod tail call in principl tail call can re us the current frame and it stack arrai but it is hard to do properli ani except that can legal happen dure frame re initi includ stack overflow except dure innoc look system arraycopi mai leav the current frame data corrupt lead to undefin behaviour in the catch code bellow that unwind js stack on except then there is issu about frame releas end except there to avoid frame alloc a releas frame can be cach for re us which would also benefit non tail call but it is not clear that thi cach would gain in perform due to potenti bad iteract with gc call parent frame frame parent frame init frame cx calle scope fun thi obj stack s dbl stack top 2 index reg ifun call parent frame calle frame if op icod tail call releas the parent exit frame cx frame null els frame save stack top stack top frame save call op op frame calle frame continu state loop if fun instanceof continu jump to the captur continu continu jump cjump cjump new continu jump continu fun frame continu result is the first argument if ani of contin call if index reg 0 cjump result undefin els cjump result stack stack top 2 cjump result dbl s dbl stack top 2 start the real unwind job throwabl cjump break without except if fun instanceof id function object id function object ifun id function object fun if continu is continu constructor ifun captur continu cx frame stack top continu loop object out arg get arg arrai stack s dbl stack top 2 index reg stack stack top fun call cx calle scope fun thi obj out arg continu loop case token new if instruct count cx instruct count invoc cost stack chang function arg0 arg n new result index reg number of argument stack top index reg object lh stack stack top if lh instanceof interpret function interpret function f interpret function lh if frame fn or script secur domain f secur domain scriptabl new instanc f creat object cx frame scope call frame calle frame new call frame init frame cx frame scope new instanc stack s dbl stack top 1 index reg f frame calle frame stack stack top new instanc frame save stack top stack top frame save call op op frame calle frame continu state loop if lh instanceof function if lh dbl mrk lh script runtim wrap number s dbl stack top throw script runtim not function error lh function fun function lh if fun instanceof id function object id function object ifun id function object fun if continu is continu constructor ifun captur continu cx frame stack top continu loop object out arg get arg arrai stack s dbl stack top 1 index reg stack stack top fun construct cx frame scope out arg continu loop case token typeof object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack stack top script runtim typeof lh continu loop case icod typeofnam stack stack top script runtim typeof name frame scope string reg continu loop case token string stack stack top string reg continu loop case icod shortnumb stack top stack stack top dbl mrk s dbl stack top get short i code frame pc frame pc 2 continu loop case icod intnumb stack top stack stack top dbl mrk s dbl stack top get int i code frame pc frame pc 4 continu loop case token number stack top stack stack top dbl mrk s dbl stack top frame idata it doubl tabl index reg continu loop case token name stack stack top script runtim name cx frame scope string reg continu loop case icod name inc dec stack stack top script runtim name incr decr frame scope string reg i code frame pc frame pc continu loop case icod setvar1 index reg i code frame pc fallthrough case token setvar if frame us activ var index reg stack stack top var dbl index reg s dbl stack top els object val stack stack top if val dbl mrk val script runtim wrap number s dbl stack top string reg frame idata arg name index reg frame scope put string reg frame scope val continu loop case icod getvar1 index reg i code frame pc fallthrough case token getvar stack top if frame us activ stack stack top var index reg s dbl stack top var dbl index reg els string reg frame idata arg name index reg stack stack top frame scope get string reg frame scope continu loop case icod var inc dec index reg varindex stack top int incr decr mask i code frame pc if frame us activ stack stack top dbl mrk object var valu var index reg doubl d if var valu dbl mrk d var dbl index reg els d script runtim to number var valu var index reg dbl mrk doubl d2 incr decr mask node decr flag 0 d 1 0 d 1 0 var dbl index reg d2 s dbl stack top incr decr mask node post flag 0 d2 d els string var name frame idata arg name index reg stack stack top script runtim name incr decr frame scope var name incr decr mask frame pc continu loop case icod zero stack top stack stack top dbl mrk s dbl stack top 0 continu loop case icod on stack top stack stack top dbl mrk s dbl stack top 1 continu loop case token null stack stack top null continu loop case token thi stack stack top frame thi obj continu loop case token thisfn stack stack top frame fn or script continu loop case token fals stack stack top boolean fals continu loop case token true stack stack top boolean true continu loop case icod undef stack stack top undefin continu loop case token enterwith object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack top frame scope script runtim enter with lh cx frame scope continu loop case token leavewith frame scope script runtim leav with frame scope continu loop case token catch scope stack top except object string reg name of except variabl index reg local for except scope stack top index reg frame local shift boolean after first scope frame idata it icod frame pc 0 throwabl caught except throwabl stack stack top 1 scriptabl last catch scope if after first scope last catch scope null els last catch scope scriptabl stack index reg stack index reg script runtim new catch scope caught except last catch scope string reg cx frame scope frame pc continu loop case token enum init kei case token enum init valu object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack top index reg frame local shift stack index reg script runtim enum init lh cx op token enum init valu continu loop case token enum next case token enum id index reg frame local shift object val stack index reg stack top stack stack top op token enum next object script runtim enum next val object script runtim enum id val cx continu loop case token ref special string reg name of special properti object obj stack stack top if obj dbl mrk obj script runtim wrap number s dbl stack top stack stack top script runtim special ref obj string reg cx continu loop case token ref member index reg flag object elem stack stack top if elem dbl mrk elem script runtim wrap number s dbl stack top stack top object obj stack stack top if obj dbl mrk obj script runtim wrap number s dbl stack top stack stack top script runtim member ref obj elem cx index reg continu loop case token ref ns member index reg flag object elem stack stack top if elem dbl mrk elem script runtim wrap number s dbl stack top stack top object ns stack stack top if ns dbl mrk ns script runtim wrap number s dbl stack top stack top object obj stack stack top if obj dbl mrk obj script runtim wrap number s dbl stack top stack stack top script runtim member ref obj ns elem cx index reg continu loop case token ref name index reg flag object name stack stack top if name dbl mrk name script runtim wrap number s dbl stack top stack stack top script runtim name ref name cx frame scope index reg continu loop case token ref ns name index reg flag object name stack stack top if name dbl mrk name script runtim wrap number s dbl stack top stack top object ns stack stack top if ns dbl mrk ns script runtim wrap number s dbl stack top stack stack top script runtim name ref ns name cx frame scope index reg continu loop case icod scope load index reg frame local shift frame scope scriptabl stack index reg continu loop case icod scope save index reg frame local shift stack index reg frame scope continu loop case icod closur expr stack stack top interpret function creat function cx frame scope frame fn or script index reg continu loop case icod closur stmt init function cx frame scope frame fn or script index reg continu loop case token regexp stack stack top frame script reg exp index reg continu loop case icod liter new index reg number of valu in the liter stack top stack stack top new object index reg s dbl stack top 0 continu loop case icod liter set object valu stack stack top if valu dbl mrk valu script runtim wrap number s dbl stack top stack top int i int s dbl stack top object stack stack top i valu s dbl stack top i 1 continu loop case token arraylit case icod spare arraylit case token objectlit object data object stack stack top object val if op token objectlit object id object frame idata liter id index reg val script runtim new object liter id data cx frame scope els int skip indexc null if op icod spare arraylit skip indexc int frame idata liter id index reg val script runtim new arrai liter data skip indexc cx frame scope stack stack top val continu loop case icod enterdq object lh stack stack top if lh dbl mrk lh script runtim wrap number s dbl stack top stack top frame scope script runtim enter dot queri lh frame scope continu loop case icod leavedq boolean val bln stack boolean frame stack top object x script runtim updat dot queri val bln frame scope if x null stack stack top x frame scope script runtim leav dot queri frame scope frame pc 2 continu loop reset stack and pc to code after enterdq stack top break jumpless run case token defaultnamespac object valu stack stack top if valu dbl mrk valu script runtim wrap number s dbl stack top stack stack top script runtim set default namespac valu cx continu loop case token escxmlattr object valu stack stack top if valu dbl mrk stack stack top script runtim escap attribut valu valu cx continu loop case token escxmltext object valu stack stack top if valu dbl mrk stack stack top script runtim escap text valu valu cx continu loop case icod line frame pc sourc line start frame pc if frame debugg frame null int line get index i code frame pc frame debugg frame on line chang cx line frame pc 2 continu loop case icod reg ind c0 index reg 0 continu loop case icod reg ind c1 index reg 1 continu loop case icod reg ind c2 index reg 2 continu loop case icod reg ind c3 index reg 3 continu loop case icod reg ind c4 index reg 4 continu loop case icod reg ind c5 index reg 5 continu loop case icod reg ind1 index reg 0x ff i code frame pc frame pc continu loop case icod reg ind2 index reg get index i code frame pc frame pc 2 continu loop case icod reg ind4 index reg get int i code frame pc frame pc 4 continu loop case icod reg str c0 string reg string 0 continu loop case icod reg str c1 string reg string 1 continu loop case icod reg str c2 string reg string 2 continu loop case icod reg str c3 string reg string 3 continu loop case icod reg str1 string reg string 0x ff i code frame pc frame pc continu loop case icod reg str2 string reg string get index i code frame pc frame pc 2 continu loop case icod reg str4 string reg string get int i code frame pc frame pc 4 continu loop default dump icod frame idata throw new runtim except unknown icod op pc frame pc 1 end of interpret switch end of jumpless run label block thi should be reachabl onli for jump implement when pc point to encod target offset if instruct count add instruct count cx frame 2 int offset get short i code frame pc if offset 0 1 account for pc point to jump opcod 1 frame pc offset 1 els frame pc frame idata long jump get exist int frame pc if instruct count frame pc prev branch frame pc continu loop end of loop for exit frame cx frame null interpret result frame result interpret result dbl frame result dbl if frame parent frame null frame frame parent frame if frame frozen frame frame clone frozen set call result frame interpret result interpret result dbl interpret result null help gc continu state loop break state loop end of interpret without except try catch throwabl ex if throwabl null thi is seriou bug and it is better to track it asap ex print stack trace system err throw new illeg state except throwabl ex thi should be reachabl onli after abov catch or from final when it need to propag except or from explicit throw if throwabl null kit code bug except type final int ex catch state 2 can execut js catch final int ex final state 1 can execut js final final int ex no js state 0 termin js execut int ex state continu jump cjump null if throwabl instanceof java script except ex state ex catch state els if throwabl instanceof ecma error an offic ecma error object ex state ex catch state els if throwabl instanceof evalu except ex state ex catch state els if throwabl instanceof runtim except ex state ex final state els if throwabl instanceof error ex state ex no js state els it must be continu jump ex state ex final state cjump continu jump throwabl if instruct count try add instruct count cx frame except cost catch runtim except ex throwabl ex ex state ex final state catch error ex error from instruct count uncondition termin js throwabl ex cjump null ex state ex no js state if frame debugg frame null throwabl instanceof runtim except call debugg onli for runtim except runtim except rex runtim except throwabl try frame debugg frame on except thrown cx rex catch throwabl ex ani except from debugg uncondition termin js throwabl ex cjump null ex state ex no js state for if ex state ex no js state boolean onli final ex state ex catch state index reg get except handler frame onli final if index reg 0 we caught an except restart the loop with except pend the process at the loop start continu state loop no allow execpt handler in thi frame unwind to parent and try to look there exit frame cx frame throwabl frame frame parent frame if frame null break if cjump null cjump branch frame frame continu branch point wa hit restart the state loop to reenter continu index reg 1 continu state loop no more frame rethrow the except or deal with continu if cjump null if cjump branch frame null the abov loop should locat the top frame kit code bug if cjump captur frame null restart detach continu index reg 1 continu state loop return continu result to the caller interpret result cjump result interpret result dbl cjump result dbl throwabl null break state loop end of state loop for do cleanup restor befor the final return or throw if cx previou interpret invoc null cx previou interpret invoc size 0 cx last interpret frame cx previou interpret invoc pop els it wa the last interpret frame on the stack cx last interpret frame null forc gc of the valu cx previou interpret invoc cx previou interpret invoc null if throwabl null if throwabl instanceof runtim except throw runtim except throwabl els must be instanc of error or code bug throw error throwabl return interpret result dbl mrk interpret result script runtim wrap number interpret result dbl 
privat static void init frame context cx scriptabl caller scope scriptabl thi obj object arg doubl arg dbl int arg shift int arg count interpret function fn or script call frame parent frame call frame frame interpret data idata fn or script idata boolean us activ idata it need activ debug frame debugg frame null if cx debugg null debugg frame cx debugg get frame cx idata if debugg frame null us activ true if us activ copi arg to new arrai to pass to enter activ function or debugg frame on enter if arg dbl null arg get arg arrai arg arg dbl arg shift arg count arg shift 0 arg dbl null scriptabl scope if idata it function type 0 if idata us dynam scope scope fn or script get parent scope els scope caller scope if us activ scope script runtim creat function activ fn or script scope arg els scope caller scope script runtim init script fn or script thi obj cx scope fn or script idata eval script flag if idata it nest function null if idata it function type 0 idata it need activ kit code bug for int i 0 i idata it nest function length i interpret data fdata idata it nest function i if fdata it function type function node function statement init function cx scope fn or script i scriptabl script reg exp null if idata it reg exp liter null wrap regexp for function ar store in interpret function but for script which should not contain refer to scope the regexp re wrap dure each script execut if idata it function type 0 script reg exp fn or script function reg exp els script reg exp fn or script creat reg exp wrap cx scope initi arg var local and stack int empti stack top idata it max var idata it max local 1 int max frame arrai idata it max frame arrai if max frame arrai empti stack top idata it max stack 1 kit code bug object stack doubl s dbl boolean stack reus if frame stack null max frame arrai frame stack length reus stack from old frame stack reus true stack frame stack s dbl frame s dbl els stack reus fals stack new object max frame arrai s dbl new doubl max frame arrai int defin arg idata arg count if defin arg arg count defin arg arg count fill the frame structur frame parent frame parent frame frame frame index parent frame null 0 parent frame frame index 1 if frame frame index cx get maximum interpret stack depth throw context report runtim error exceed maximum stack depth frame frozen fals frame fn or script fn or script frame idata idata frame stack stack frame s dbl s dbl frame var sourc frame frame local shift idata it max var frame empti stack top empti stack top frame debugg frame debugg frame frame us activ us activ frame thi obj thi obj frame script reg exp script reg exp initi initi valu of variabl that chang dure interpret frame result undefin instanc frame pc 0 frame pc prev branch 0 frame pc sourc line start idata first line pc frame scope scope frame save stack top empti stack top frame save call op 0 system arraycopi arg arg shift stack 0 defin arg if arg dbl null system arraycopi arg dbl arg shift s dbl 0 defin arg for int i defin arg i idata it max var i stack i undefin instanc if stack reus clean the stack part and space beyond stack if ani of the old arrai to allow to gc object there for int i empti stack top 1 i stack length i stack i null enter frame cx frame arg 
privat static boolean is frame enter exit requir call frame frame return frame debugg frame null frame idata it need activ 
privat static void enter frame context cx call frame frame object arg if frame debugg frame null frame debugg frame on enter cx frame scope frame thi obj arg if frame idata it need activ enter activ onli when it need activ true not when us activ hold sinc debugg should not interfer with activ chain script runtim enter activ function cx frame scope 
privat static void exit frame context cx call frame frame object throwabl if frame idata it need activ script runtim exit activ function cx if frame debugg frame null try if throwabl instanceof throwabl frame debugg frame on exit cx true throwabl els object result continu jump cjump continu jump throwabl if cjump null result frame result els result cjump result if result uniqu tag doubl mark doubl result dbl if cjump null result dbl frame result dbl els result dbl cjump result dbl result script runtim wrap number result dbl frame debugg frame on exit cx fals result catch throwabl ex system err println rhino usag warn on exit termin with except ex print stack trace system err 
privat static void set call result call frame frame object call result doubl call result dbl if frame save call op token call frame stack frame save stack top call result frame s dbl frame save stack top call result dbl els if frame save call op token new if construct return scriptabl then it replac on stack top save origin instanc of the object if call result instanceof scriptabl frame stack frame save stack top call result els kit code bug frame save call op 0 
privat static void captur continu context cx call frame frame int stack top continu c new continu script runtim set object proto and parent c script runtim get top call scope cx make sure that all frame upstack frame ar frozen call frame x frame parent frame while x null x frozen x frozen true allow to gc unus stack space for int i x save stack top 1 i x stack length i allow to gc unus stack space x stack i null if x save call op token call the call will alwai overwrit the stack top with the result x stack x save stack top null els if x save call op token new kit code bug the new oper us stack top to store the construct object so it shall not be clear see comment in set call result x x parent frame c init implement frame parent frame frame stack stack top c 
privat static int stack int32 call frame frame int i object x frame stack i doubl valu if x uniqu tag doubl mark valu frame s dbl i els valu script runtim to number x return script runtim to int32 valu 
privat static doubl stack doubl call frame frame int i object x frame stack i if x uniqu tag doubl mark return script runtim to number x els return frame s dbl i 
privat static boolean stack boolean call frame frame int i object x frame stack i if x boolean true return true els if x boolean fals return fals els if x uniqu tag doubl mark doubl d frame s dbl i return d d d 0 0 els if x null x undefin instanc return fals els if x instanceof number doubl d number x doubl valu return d d d 0 0 els if x instanceof boolean return boolean x boolean valu els return script runtim to boolean x 
privat static void do add object stack doubl s dbl int stack top context cx object rh stack stack top 1 object lh stack stack top doubl d boolean left right order if rh uniqu tag doubl mark d s dbl stack top 1 if lh uniqu tag doubl mark s dbl stack top d return left right order true fallthrough to object number code els if lh uniqu tag doubl mark d s dbl stack top lh rh left right order fals fallthrough to object number code els if lh instanceof scriptabl rh instanceof scriptabl stack stack top script runtim add lh rh cx els if lh instanceof string string lstr string lh string rstr script runtim to string rh stack stack top lstr concat rstr els if rh instanceof string string lstr script runtim to string lh string rstr string rh stack stack top lstr concat rstr els doubl l dbl lh instanceof number number lh doubl valu script runtim to number lh doubl r dbl rh instanceof number number rh doubl valu script runtim to number rh stack stack top uniqu tag doubl mark s dbl stack top l dbl r dbl return handl object lh number d code if lh instanceof scriptabl rh script runtim wrap number d if left right order object tmp lh lh rh rh tmp stack stack top script runtim add lh rh cx els if lh instanceof string string lstr string lh string rstr script runtim to string d if left right order stack stack top lstr concat rstr els stack stack top rstr concat lstr els doubl l dbl lh instanceof number number lh doubl valu script runtim to number lh stack stack top uniqu tag doubl mark s dbl stack top l dbl d 
privat static object get arg arrai object stack doubl s dbl int shift int count if count 0 return script runtim empti arg object arg new object count for int i 0 i count i shift object val stack shift if val uniqu tag doubl mark val script runtim wrap number s dbl shift arg i val return arg 
privat static void add instruct count context cx call frame frame int extra cx instruct count frame pc frame pc prev branch extra if cx instruct count cx instruct threshold cx observ instruct count cx instruct count cx instruct count 0 
static void init scriptabl scope boolean seal nativ boolean obj new nativ boolean fals obj export as jsclass max prototyp id scope seal 
privat nativ boolean boolean b boolean valu b 
public string get class name return boolean 
public object get default valu class type hint thi is actual non ecma but will be propos as a chang in round 2 if type hint script runtim boolean class return script runtim wrap boolean boolean valu return super get default valu type hint 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 0 s to string break case id to sourc ariti 0 s to sourc break case id valu of ariti 0 s valu of break default throw new illeg argument except string valu of id init prototyp method boolean tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag boolean tag return super exec id call f cx scope thi obj arg int id f method id if id id constructor boolean b script runtim to boolean arg 0 if thi obj null new boolean val creat a new boolean object return new nativ boolean b boolean val convert val to a boolean return script runtim wrap boolean b the rest of boolean prototyp method requir thi obj to be boolean if thi obj instanceof nativ boolean throw incompat call error f boolean valu nativ boolean thi obj boolean valu switch id case id to string return valu true fals case id to sourc return valu new boolean true new boolean fals case id valu of return script runtim wrap boolean valu throw new illeg argument except string valu of id 
protect int find prototyp id string s int id gener last updat 2004 03 17 13 28 00 cet l0 id 0 string x null int c int s length s length if s length 7 x valu of id id valu of els if s length 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string els if s length 11 x constructor id id constructor if x null x s x equal s id 0 gener return id 
public class run script public static void main string arg creat and enter a context the context store inform about the execut environ of a script context cx context enter try initi the standard object object function etc thi must be done befor script can be execut return a scope object that we us in later call scriptabl scope cx init standard object collect the argument into a singl string string s for int i 0 i arg length i s arg i now evalu the string we ve colect object result cx evalu string scope s cmd 1 null convert the result to a string and print it system err println cx to string result final exit from the context context exit 
public string choos file if cwd null string dir system get properti user dir if dir null cwd new file dir if cwd null dlg set current directori cwd dlg set dialog titl select a file to load int return val dlg show open dialog thi if return val jfile chooser approv option string result dlg get select file get path cwd new file dlg get select file get parent return result return null 
public static void main string arg jsconsol consol new jsconsol arg 
public void creat file chooser dlg new jfile chooser javax swing filechoos file filter filter new javax swing filechoos file filter public boolean accept file f if f is directori return true string name f get name int i name last index of if i 0 i name length 1 string ext name substr i 1 to lower case if ext equal js return true return fals public string get descript return java script file js dlg add choosabl file filter filter 
new javax swing filechoos file filter public boolean accept file f if f is directori return true string name f get name int i name last index of if i 0 i name length 1 string ext name substr i 1 to lower case if ext equal js return true return fals 
public string get descript return java script file js 
public jsconsol string arg super rhino java script consol jmenu bar menubar new jmenu bar creat file chooser string file item load exit string file cmd load exit char file short cut l x string edit item cut copi past char edit short cut t c p string plaf item metal window motif boolean plaf state true fals fals jmenu file menu new jmenu file file menu set mnemon f jmenu edit menu new jmenu edit edit menu set mnemon e jmenu plaf menu new jmenu platform plaf menu set mnemon p for int i 0 i file item length i jmenu item item new jmenu item file item i file short cut i item set action command file cmd i item add action listen thi file menu add item for int i 0 i edit item length i jmenu item item new jmenu item edit item i edit short cut i item add action listen thi edit menu add item button group group new button group for int i 0 i plaf item length i jradio button menu item item new jradio button menu item plaf item i plaf state i group add item item add action listen thi plaf menu add item menubar add file menu menubar add edit menu menubar add plaf menu set jmenu bar menubar consol text area new consol text area arg jscroll pane scroller new jscroll pane consol text area set content pane scroller consol text area set row 24 consol text area set column 80 add window listen new window adapt public void window close window event e system exit 0 pack set visibl true system set in consol text area get in system set out consol text area get out system set err consol text area get err main set in consol text area get in main set out consol text area get out main set err consol text area get err main main arg 
consol text area set column 80 add window listen new window adapt public void window close window event e system exit 0 
public void action perform action event e string cmd e get action command string plaf name null if cmd equal load string f choos file if f null f f replac consol text area eval load f els if cmd equal exit system exit 0 els if cmd equal cut consol text area cut els if cmd equal copi consol text area copi els if cmd equal past consol text area past els if cmd equal metal plaf name javax swing plaf metal metal look and feel els if cmd equal window plaf name com sun java swing plaf window window look and feel els if cmd equal motif plaf name com sun java swing plaf motif motif look and feel if plaf name null try uimanag set look and feel plaf name swing util updat compon tree ui thi consol text area post updat ui updat compon tree ui seem to mess up the file chooser dialog so just creat a new on creat file chooser catch except exc joption pane show messag dialog thi exc get messag platform joption pane error messag 
final class irfactori irfactori parser parser thi parser parser 
script or fn node creat script return new script or fn node token script 
script for associ file url name with toplevel script void init script script or fn node script node node bodi node children bodi get first child if children null script node add children to back children 
leaf node creat leaf int node type return new node node type 
node creat leaf int node type int node op return new node node type node op 
statement leaf node node creat switch node expr int lineno the switch will be rewritten from switch expr case test1 statements1 default statement default case test n statement n to switch expr case test1 goto label1 case test n goto label n goto label default label1 statements1 label default statement default label n statement n break label where insid switch each break without label will be replac by goto break label if the origin switch doe not have the default label then the transform code would contain after the switch instead of goto label default the follow goto goto break label node jump switch node new node jump token switch expr lineno node block new node token block switch node return block 
if case express argument is null it indic default label void add switch case node switch block node case express node statement if switch block get type token block throw kit code bug node jump switch node node jump switch block get first child if switch node get type token switch throw kit code bug node goto target node new target if case express null node jump case node new node jump token case case express case node target goto target switch node add child to back case node els switch node set default goto target switch block add child to back goto target switch block add child to back statement 
void close switch node switch block if switch block get type token block throw kit code bug node jump switch node node jump switch block get first child if switch node get type token switch throw kit code bug node switch break target node new target switch node target is onli us by node transform to detect switch end switch node target switch break target node default target switch node get default if default target null default target switch break target switch block add child after make jump token goto default target switch node switch block add child to back switch break target 
node creat variabl int lineno return new node token var lineno 
node creat expr statement node expr int lineno int type if parser insid function type token expr void els type token expr result return new node type expr lineno 
node creat expr statement no return node expr int lineno return new node token expr void expr lineno 
node creat default namespac node expr int lineno default xml namespac requir activ set requir activ node n creat unari token defaultnamespac expr node result creat expr statement n lineno return result 
name node creat name string name check activ name name token name return node new string token name name 
string for liter node creat string string string return node new string string 
number for liter node creat number doubl number return node new number number 
catch claus of try catch final param var name the name of the variabl to bind to the except param catch cond the condit under which to catch the except mai be null if no condit is given param stmt the statement in the catch claus param lineno the start line number of the catch claus node creat catch string var name node catch cond node stmt int lineno if catch cond null catch cond new node token empti return new node token catch creat name var name catch cond stmt lineno 
throw node creat throw node expr int lineno return new node token throw expr lineno 
return node creat return node expr int lineno return expr null new node token return lineno new node token return expr lineno 
label node creat label int lineno return new node jump token label lineno 
node get label loop node label return node jump label get loop 
label node creat label statement node label arg node statement node jump label node jump label arg make a target and put it after the statement node and in the label node so break get the right target node break target node new target node block new node token block label statement break target label target break target return block 
break possibl label node creat break node break statement int lineno node jump n new node jump token break lineno node jump jump statement int t break statement get type if t token loop t token label jump statement node jump break statement els if t token block break statement get first child get type token switch jump statement node jump break statement get first child els throw kit code bug n set jump statement jump statement return n 
continu possibl label node creat continu node loop int lineno if loop get type token loop kit code bug node jump n new node jump token continu lineno n set jump statement node jump loop return n 
statement block creat the empti statement block must make subsequ call to add statement to the node node creat block int lineno return new node token block lineno 
function node creat function string name return new function node name 
node init function function node fn node int function index node statement int function type fn node it function type function type fn node add child to back statement int function count fn node get function count if function count 0 function contain other function requir activ object fn node it need activ true for int i 0 i function count i function node fn fn node get function node i nest function express statement overrid var if fn get function type function node function express statement string name fn get function name if name null name length 0 fn node remov param or var name if function type function node function express string name fn node get function name if name null name length 0 fn node ha param or var name a function express need to have it name as a variabl if it isn t alreadi alloc as a variabl see ecma ch 13 we add code to the begin of the function to initi a local variabl of the function s name to the function valu fn node add var name node set fn new node token expr void new node token setnam node new string token bindnam name new node token thisfn statement add children to front set fn add return to end if need node last stmt statement get last child if last stmt null last stmt get type token return statement add child to back new node token return node result node new string token function fn node get function name result put int prop node function prop function index return result 
add a child to the back of the given node thi function break the factori abstract but it remov a requir from implementor of node void add child to back node parent node child parent add child to back child 
creat loop node the parser will later call creat while creat do while creat for creat for in to finish loop gener node creat loop node node loop label int lineno node jump result new node jump token loop lineno if loop label null node jump loop label set loop result return result 
while node creat while node loop node cond node bodi return creat loop node jump loop loop while bodi cond null null 
do while node creat do while node loop node bodi node cond return creat loop node jump loop loop do while bodi cond null null 
for node creat for node loop node init node test node incr node bodi return creat loop node jump loop loop for bodi test init incr 
privat node creat loop node jump loop int loop type node bodi node cond node init node incr node bodi target node new target node cond target node new target if loop type loop for cond get type token empti cond new node token true node jump ifeq new node jump token ifeq cond ifeq target bodi target node break target node new target loop add child to back bodi target loop add children to back bodi if loop type loop while loop type loop for propag lineno to condit loop add children to back new node token empti loop get lineno loop add child to back cond target loop add child to back ifeq loop add child to back break target loop target break target node continu target cond target if loop type loop while loop type loop for just add a goto to the condit in the do while loop add child to front make jump token goto cond target if loop type loop for if init get type token empti if init get type token var init new node token expr void init loop add child to front init node incr target node new target loop add child after incr target bodi if incr get type token empti incr new node token expr void incr loop add child after incr incr target continu target incr target loop set continu continu target return loop 
for in node creat for in node loop node lh node obj node bodi boolean is for each string name int type lh get type node lvalu if type token var check that there wa onli on variabl given we can t do thi in the parser becaus then the parser would have to know someth about the init node of the for in loop node last child lh get last child if lh get first child last child parser report error msg mult index lvalu node new string token name last child get string els lvalu make refer lh if lvalu null parser report error msg bad for in lh return obj node local block new node token local block int init type is for each token enum init valu token enum init kei node init new node init type obj init put prop node local block prop local block node cond new node token enum next cond put prop node local block prop local block node id new node token enum id id put prop node local block prop local block node new bodi new node token block node assign simpl assign lvalu id new bodi add child to back new node token expr void assign new bodi add child to back bodi loop creat while loop cond new bodi loop add child to front init if type token var loop add child to front lh local block add child to back loop return local block 
try catch final the irfactori tri to express as much as possibl in the tree the respons remain for codegen ar to add the java handler either but not both of target and final might not be defin a catch handler for javascript except that unwrap the except onto the stack and goto to the catch target a final handler and a goto to goto around these handler node creat try catch final node try block node catch block node final block int lineno boolean ha final final block null final block get type token block final block ha children short circuit if try block get type token block try block ha children ha final return try block boolean ha catch catch block ha children short circuit if ha final ha catch bc final might be an empti block return try block node handler block new node token local block node jump pn new node jump token try try block lineno pn put prop node local block prop handler block if ha catch jump around catch code node end catch node new target pn add child to back make jump token goto end catch make a target for the catch that the tcf node know about node catch target node new target pn target catch target mark it pn add child to back catch target given try try block catch e if condition1 something1 catch e if condit n someth n catch e someth default rewrit as try try block goto after catch catch x with new catch scope e x if condition1 something1 goto after catch with new catch scope e x if condit n someth n goto after catch with new catch scope e x someth default goto after catch after catch if there is no default catch then the last with block arround someth default is replac by rethrow it is assum that catch handler gener will store execept object in handler block regist block with local for except scope object node catch scope block new node token local block expect catchblock children to be cond block pair node cb catch block get first child boolean ha default fals int scope index 0 while cb null int catch line no cb get lineno node name cb get first child node cond name get next node catch statement cond get next cb remov child name cb remov child cond cb remov child catch statement add goto to the catch statement to jump out of catch but prefix it with leavewith sinc try catch produc with code in order to limit the scope of the except object catch statement add child to back new node token leavewith catch statement add child to back make jump token goto end catch creat condit if when present node cond stmt if cond get type token empti cond stmt catch statement ha default true els cond stmt creat if cond catch statement null catch line no gener code to creat the scope object and store it in catch scope block regist node catch scope new node token catch scope name creat us local handler block catch scope put prop node local block prop catch scope block catch scope put int prop node catch scope prop scope index catch scope block add child to back catch scope add with statement base on catch scope object catch scope block add child to back creat with creat us local catch scope block cond stmt catch line no move to next cb cb cb get next scope index pn add child to back catch scope block if ha default gener code to rethrow if no catch claus wa execut node rethrow new node token rethrow rethrow put prop node local block prop handler block pn add child to back rethrow pn add child to back end catch if ha final node final target node new target pn set final final target add jsr final to the try block pn add child to back make jump token jsr final target jump around final code node final end node new target pn add child to back make jump token goto final end pn add child to back final target node f block new node token final final block f block put prop node local block prop handler block pn add child to back f block pn add child to back final end handler block add child to back pn return handler block 
with node creat with node obj node bodi int lineno set requir activ node result new node token block lineno result add child to back new node token enterwith obj node bodi node new node token with bodi lineno result add children to back bodi node result add child to back new node token leavewith return result 
dotqueri public node creat dot queri node obj node bodi int lineno set requir activ node result new node token dotqueri obj bodi lineno return result 
node creat arrai liter obj arrai elem int skip count int length elem size int skip index null if skip count 0 skip index new int skip count node arrai new node token arraylit for int i 0 j 0 i length i node elem node elem get i if elem null arrai add child to back elem els skip index j i j if skip count 0 arrai put prop node skip index prop skip index return arrai 
object liter br creat object liter rewrit it argument as object creation plu object properti entri so later compil stage don t need to know about object liter node creat object liter obj arrai elem int size elem size 2 node object new node token objectlit object properti if size 0 properti script runtim empti arg els properti new object size for int i 0 i size i properti i elem get 2 i node valu node elem get 2 i 1 object add child to back valu object put prop node object id prop properti return object 
regular express node creat reg exp int regexp index node n new node token regexp n put int prop node regexp prop regexp index return n 
if statement node creat if node cond node if true node if fals int lineno int cond statu is alwai defin boolean cond if cond statu alwai true boolean return if true els if cond statu alwai fals boolean if if fals null return if fals replac if fals xxx by empti block return new node token block lineno node result new node token block lineno node if not target node new target node jump ifn new node jump token ifn cond ifn target if not target result add child to back ifn result add children to back if true if if fals null node end target node new target result add child to back make jump token goto end target result add child to back if not target result add children to back if fals result add child to back end target els result add child to back if not target return result 
node creat cond expr node cond node if true node if fals int cond statu is alwai defin boolean cond if cond statu alwai true boolean return if true els if cond statu alwai fals boolean return if fals return new node token hook cond if true if fals 
unari node creat unari int node type node child int child type child get type switch node type case token delprop node n if child type token name transform delet name a to delet bind a string a child set type token bindnam node left child node right node new string child get string n new node node type left right els if child type token getprop child type token getelem node left child get first child node right child get last child child remov child left child remov child right n new node node type left right els if child type token get ref node ref child get first child child remov child ref n new node token del ref ref els n new node token true return n case token typeof if child type token name child set type token typeofnam return child break case token bitnot if child type token number int valu script runtim to int32 child get doubl child set doubl valu return child break case token neg if child type token number child set doubl child get doubl return child break case token not int statu is alwai defin boolean child if statu 0 int type if statu alwai true boolean type token fals els type token true if child type token true child type token fals child set type type return child return new node type break return new node node type child 
node creat call or new int node type node child int type node non specialcal if child get type token name string name child get string if name equal eval type node specialcal eval els if name equal with type node specialcal with els if child get type token getprop string name child get last child get string if name equal eval type node specialcal eval node node new node node type child if type node non specialcal call to these function requir activ object set requir activ node put int prop node specialcal prop type return node 
node creat inc dec int node type boolean post node child child make refer child if child null string msg if node type token dec msg msg bad decr els msg msg bad incr parser report error msg return null int child type child get type switch child type case token name case token getprop case token getelem case token get ref node n new node node type child int incr decr mask 0 if node type token dec incr decr mask node decr flag if post incr decr mask node post flag n put int prop node incrdecr prop incr decr mask return n throw kit code bug 
node creat properti get node target string namespac string name int member type flag if namespac null member type flag 0 if target null return creat name name check activ name name token getprop if script runtim is special properti name node ref new node token ref special target ref put prop node name prop name return new node token get ref ref return new node token getprop target creat string name node elem creat string name member type flag node properti flag return creat member ref get target namespac elem member type flag 
node creat element get node target string namespac node elem int member type flag opt could optim to creat properti get iff elem is string that can not be number if namespac null member type flag 0 stand alon aaa as primari express is arrai liter declar and should not come here if target null throw kit code bug return new node token getelem target elem return creat member ref get target namespac elem member type flag 
privat node creat member ref get node target string namespac node elem int member type flag node ns node null if namespac null see 11 1 2 in ecma 357 if namespac equal ns node new node token null els ns node creat name namespac node ref if target null if namespac null ref new node token ref name elem els ref new node token ref ns name ns node elem els if namespac null ref new node token ref member target elem els ref new node token ref ns member target ns node elem if member type flag 0 ref put int prop node member type prop member type flag return new node token get ref ref 
binari node creat binari int node type node left node right switch node type case token add numer addit and string concaten if left type token string string s2 if right type token string s2 right get string els if right type token number s2 script runtim number to string right get doubl 10 els break string s1 left get string left set string s1 concat s2 return left els if left type token number if right type token number left set doubl left get doubl right get doubl return left els if right type token string string s1 s2 s1 script runtim number to string left get doubl 10 s2 right get string right set string s1 concat s2 return right can t do anyth if we don t know both type sinc 0 object is suppos to call to string on the object and do string concanten rather than addit break case token sub numer subtract if left type token number doubl ld left get doubl if right type token number both number left set doubl ld right get doubl return left els if ld 0 0 first 0 0 x x return new node token neg right els if right type token number if right get doubl 0 0 second 0 x 0 x can not make simpli x becaus x 0 must be number return new node token po left break case token mul numer multipl if left type token number doubl ld left get doubl if right type token number both number left set doubl ld right get doubl return left els if ld 1 0 first 1 1 x x return new node token po right els if right type token number if right get doubl 1 0 second 1 x 1 x can not make simpli x becaus x 0 must be number return new node token po left can t do x 0 infin 0 give na n not 0 break case token div number divis if right type token number doubl rd right get doubl if left type token number both constant just divid trust java to handl x 0 left set doubl left get doubl rd return left els if rd 1 0 second 1 x 1 x not simpli x to forc number convert return new node token po left break case token and sinc x y give x not fals when boolean x is fals and y not boolean y when boolean x is true x y can onli be simplifi if x is defin see bug 309957 int left statu is alwai defin boolean left if left statu alwai fals boolean if the first on is fals just return it return left els if left statu alwai true boolean if first is true set to second return right break case token or sinc x y give x not true when boolean x is true and y not boolean y when boolean x is fals x y can onli be simplifi if x is defin see bug 309957 int left statu is alwai defin boolean left if left statu alwai true boolean if the first on is true just return it return left els if left statu alwai fals boolean if first is fals set to second return right break return new node node type left right 
privat node simpl assign node left node right int node type left get type switch node type case token name left set type token bindnam return new node token setnam left right case token getprop case token getelem node obj left get first child node id left get last child int type if node type token getprop type token setprop els type token setelem return new node type obj id right case token get ref node ref left get first child check mutabl refer ref return new node token set ref ref right throw kit code bug 
privat void check mutabl refer node n int member type flag n get int prop node member type prop 0 if member type flag node descend flag 0 parser report error msg bad assign left 
node creat assign int assign type node left node right left make refer left if left null parser report error msg bad assign left return right int assign op switch assign type case token assign return simpl assign left right case token assign bitor assign op token bitor break case token assign bitxor assign op token bitxor break case token assign bitand assign op token bitand break case token assign lsh assign op token lsh break case token assign rsh assign op token rsh break case token assign ursh assign op token ursh break case token assign add assign op token add break case token assign sub assign op token sub break case token assign mul assign op token mul break case token assign div assign op token div break case token assign mod assign op token mod break default throw kit code bug int node type left get type switch node type case token name string s left get string node op left node new string token name s node op new node assign op op left right node lvalu left node new string token bindnam s return new node token setnam lvalu left op case token getprop case token getelem node obj left get first child node id left get last child int type node type token getprop token setprop op token setelem op node op left new node token us stack node op new node assign op op left right return new node type obj id op case token get ref node ref left get first child check mutabl refer ref node op left new node token us stack node op new node assign op op left right return new node token set ref op ref op throw kit code bug 
node creat us local node local block if token local block local block get type throw kit code bug node result new node token local load result put prop node local block prop local block return result 
privat node jump make jump int type node target node jump n new node jump type n target target return n 
privat node make refer node node int type node get type switch type case token name case token getprop case token getelem case token get ref return node case token call node set type token ref call return new node token get ref node signal caller to report error return null 
check if node alwai mean true or fals in boolean context privat static int is alwai defin boolean node node switch node get type case token fals case token null return alwai fals boolean case token true return alwai true boolean case token number doubl num node get doubl if num num num 0 0 return alwai true boolean els return alwai fals boolean return 0 
privat void check activ name string name int token if parser insid function boolean activ fals if argument equal name parser compil env activ name null parser compil env activ name contain kei name activ true els if length equal name if token token getprop parser compil env get languag version context version 1 2 us of length in 1 2 requir an activ object activ true if activ set requir activ 
privat void set requir activ if parser insid function function node parser current script or fn it need activ true 
public class slot 003 extend live connect test public slot 003 super 
super public static void main string arg slot 003 test new slot 003 test start 
public void execut test get base object object test matrix get data arrai jsobject js arrai creat jsarrai get length js arrai 0 for int i 0 i test matrix length i set slot js arrai i object test matrix i get slot js arrai i object test matrix i get length js arrai test matrix length 
get the constructor of all the base java script object the test will compar the instanc constructor to the base object constructor to verifi that the java script type of the object is corret public boolean get base object try js number jsobject global eval number prototyp constructor js string jsobject global eval string prototyp constructor js function jsobject global eval function prototyp constructor js boolean jsobject global eval boolean prototyp constructor js object jsobject global eval object prototyp constructor js math jsobject global eval math js date jsobject global eval date prototyp constructor js arrai jsobject global eval arrai prototyp constructor js reg exp jsobject global eval reg exp prototyp constructor catch except e system err println fail in get base object e to string e print stack trace return fals return true 
get the data arrai which is an arrai of arrai each of the intern arrai consist of three object a string whose valu will be pass to the java script arrai constructor a string which is the expect string valu of retreiv the jsobject via get slot and a jsobject which is the jsobject s constructor that allow us to verifi the type of jsobject return the data arrai public object get data arrai object item0 global eval new string java script string new string java script string js string object item1 global eval new number 12345 new string 12345 js number object item2 global eval new boolean fals new string fals js boolean object item3 global eval new arrai 0 1 2 3 4 new string 0 1 2 3 4 js arrai object item4 global eval new object new string object object js object object data arrai item0 item1 item2 item3 item4 return data arrai 
creat an empti java script arrai name js arrai return the jsobject arrai object public jsobject creat jsarrai jsobject js arrai null string arg var js arrai new arrai string result pass try system out println arg global eval arg js arrai jsobject global get member js arrai catch except e result fail except global get member js arrai threw e to string file except except e print stack trace final add test case global eval var js arrai new arrai jsobject js arrai jsobject global get member js arrai pass result except return js arrai 
us jsobject get member to get the length properti of a jsobject param js arrai a jsobject with a properti name length param java length the expect length of the jsobject public void get length jsobject js arrai int java length string except int js length 0 try js length doubl js arrai get member length int valu catch except e except js arrai get member length threw e to string file except except e print stack trace final add test case length is js length js arrai get member length int valu java length true js length java length except 
us jsobject get slot to get an index member of a jsobject in thi test the expect class of all object is jsobject param js arrai the jsobject with index member param slot the index properti to retriev param data object arrai contain the string represent of the expect result of js arrai get slot slot and the jsobjectconstructor of the expect result which allow us to verifi the valu and type of the result object public void get slot jsobject js arrai int slot object data string except jsobject constructor null jsobject result null class e class null class a class null try result jsobject js arrai get slot slot if result null e class class for name netscap javascript jsobject a class result get class constructor jsobject result get member constructor catch except e except js arrai get slot slot threw e to string file except except e print stack trace final if result null add test case js arrai get slot slot to string trim return result data 1 equal result true data 1 to string trim equal result to string except els check the string valu of the result add test case js arrai get slot slot return result data 1 to string equal result true data 1 equal result to string except check the class of the result all should be jsobject add test case e class equal a class true e class equal a class except check the constructor of the result add test case constructor equal data 2 true constructor equal data 2 except 
jsobject set slot return undefin thi just verifi that we can call set slot without throw an except param js arrai the jsobject on which set slot will be call param slot the index member that will be set param java valu the valu to set the index member public void set slot jsobject js arrai int slot object data string except null string result pass try js arrai set slot slot object data 0 catch except e result fail except js arrai set slot slot data 0 threw e to string file except except e print stack trace final add test case js arrai set slot slot data 0 pass result except 
public class slot 004 extend live connect test public slot 004 super 
super public static void main string arg slot 004 test new slot 004 test start 
public void execut test object test matrix get data arrai jsobject js arrai creat jsarrai get length js arrai 0 for int i 0 i test matrix length i set slot js arrai i object test matrix i get slot js arrai i object test matrix i get length js arrai test matrix length 
get the data arrai which is an arrai of arrai each of the intern arrai consist of three object a string whose valu will be pass to the java script arrai constructor a string which is the expect string valu of retreiv the jsobject via get slot and a jsobject which is the jsobject s constructor that allow us to verifi the type of jsobject return the data arrai public object get data arrai object item0 new string java string new string java string java lang string object item1 new integ 12345 new string 12345 java lang integ object item2 new boolean fals new string fals java lang boolean object item3 new doubl 12345 0 new string 12345 0 java lang doubl object data arrai item0 item1 item2 item3 return data arrai 
creat an empti java script arrai name js arrai return the jsobject arrai object public jsobject creat jsarrai jsobject js arrai null string arg var js arrai new arrai string result pass try system out println arg global eval arg js arrai jsobject global get member js arrai catch except e result fail except global get member js arrai threw e to string file except except e print stack trace final add test case global eval var js arrai new arrai jsobject js arrai jsobject global get member js arrai pass result except return js arrai 
us jsobject get member to get the length properti of a jsobject param js arrai a jsobject with a properti name length param java length the expect length of the jsobject public void get length jsobject js arrai int java length string except int js length 0 try js length doubl js arrai get member length int valu catch except e except js arrai get member length threw e to string file except except e print stack trace final add test case length is js length js arrai get member length int valu java length true js length java length except 
us jsobject get slot to get an index member of a jsobject in thi test the expect class of all object is jsobject param js arrai the jsobject with index member param slot the index properti to retriev param data object arrai contain the string represent of the expect result of js arrai get slot slot and the jsobjectconstructor of the expect result which allow us to verifi the valu and type of the result object public void get slot jsobject js arrai int slot object data string except object result null class e class null class a class null try result object js arrai get slot slot if result null e class class for name string data 2 a class result get class catch except e except js arrai get slot slot threw e to string file except except e print stack trace final if result null add test case js arrai get slot slot to string trim return result data 1 equal result true data 1 to string trim equal result to string except els check the string valu of the result add test case js arrai get slot slot return result data 1 to string equal result true data 1 equal result to string except check the class of the result all should be jsobject add test case e class equal a class true e class equal a class except 
jsobject set slot return undefin thi just verifi that we can call set slot without throw an except param js arrai the jsobject on which set slot will be call param slot the index member that will be set param java valu the valu to set the index member public void set slot jsobject js arrai int slot object data string except null string result pass try js arrai set slot slot object data 0 catch except e result fail except js arrai set slot slot data 0 threw e to string file except except e print stack trace final add test case js arrai set slot slot data 0 pass result except 
token stream parser parser reader sourc reader string sourc string int lineno thi parser parser thi lineno lineno if sourc reader null if sourc string null kit code bug thi sourc reader sourc reader thi sourc buffer new char 512 thi sourc end 0 els if sourc string null kit code bug thi sourc string sourc string thi sourc end sourc string length thi sourc cursor 0 
string token to string int token if token print tree string name token name token switch token case token string case token regexp case token name return name thi string case token number return number thi number return name return 
static boolean is keyword string s return token eof string to keyword s 
privat static int string to keyword string name string id map the follow assum that token eof 0 final int id break token break id case token case id continu token continu id default token default id delet token delprop id do token do id els token els id export token export id fals token fals id for token for id function token function id if token if id in token in id new token new id null token null id return token return id switch token switch id thi token thi id true token true id typeof token typeof id var token var id void token void id while token while id with token with the follow ar ifdef reserv java keyword in jsscan c id abstract token reserv id boolean token reserv id byte token reserv id catch token catch id char token reserv id class token reserv id const token reserv id debugg token reserv id doubl token reserv id enum token reserv id extend token reserv id final token reserv id final token final id float token reserv id goto token reserv id implement token reserv id import token import id instanceof token instanceof id int token reserv id interfac token reserv id long token reserv id nativ token reserv id packag token reserv id privat token reserv id protect token reserv id public token reserv id short token reserv id static token reserv id super token reserv id synchron token reserv id throw token throw id throw token reserv id transient token reserv id try token try id volatil token reserv int id string s name gener last updat 2001 06 01 17 45 01 cest l0 id 0 string x null int c l switch s length case 2 c s char at 1 if c f if s char at 0 i id id if break l0 els if c n if s char at 0 i id id in break l0 els if c o if s char at 0 d id id do break l0 break l case 3 switch s char at 0 case f if s char at 2 r s char at 1 o id id for break l0 break l case i if s char at 2 t s char at 1 n id id int break l0 break l case n if s char at 2 w s char at 1 e id id new break l0 break l case t if s char at 2 y s char at 1 r id id try break l0 break l case v if s char at 2 r s char at 1 a id id var break l0 break l break l case 4 switch s char at 0 case b x byte id id byte break l case c c s char at 3 if c e if s char at 2 s s char at 1 a id id case break l0 els if c r if s char at 2 a s char at 1 h id id char break l0 break l case e c s char at 3 if c e if s char at 2 s s char at 1 l id id els break l0 els if c m if s char at 2 u s char at 1 n id id enum break l0 break l case g x goto id id goto break l case l x long id id long break l case n x null id id null break l case t c s char at 3 if c e if s char at 2 u s char at 1 r id id true break l0 els if c s if s char at 2 i s char at 1 h id id thi break l0 break l case v x void id id void break l case w x with id id with break l break l case 5 switch s char at 2 case a x class id id class break l case e x break id id break break l case i x while id id while break l case l x fals id id fals break l case n c s char at 0 if c c x const id id const els if c f x final id id final break l case o c s char at 0 if c f x float id id float els if c s x short id id short break l case p x super id id super break l case r x throw id id throw break l case t x catch id id catch break l break l case 6 switch s char at 1 case a x nativ id id nativ break l case e c s char at 0 if c d x delet id id delet els if c r x return id id return break l case h x throw id id throw break l case m x import id id import break l case o x doubl id id doubl break l case t x static id id static break l case u x public id id public break l case w x switch id id switch break l case x x export id id export break l case y x typeof id id typeof break l break l case 7 switch s char at 1 case a x packag id id packag break l case e x default id id default break l case i x final id id final break l case o x boolean id id boolean break l case r x privat id id privat break l case x x extend id id extend break l break l case 8 switch s char at 0 case a x abstract id id abstract break l case c x continu id id continu break l case d x debugg id id debugg break l case f x function id id function break l case v x volatil id id volatil break l break l case 9 c s char at 0 if c i x interfac id id interfac els if c p x protect id id protect els if c t x transient id id transient break l case 10 c s char at 1 if c m x implement id id implement els if c n x instanceof id id instanceof break l case 12 x synchron id id synchron break l if x null x s x equal s id 0 gener string id map if id 0 return token eof return id 0xff 
final int get lineno return lineno 
final int get lineno return lineno final string get string return string 
final string get string return string final doubl get number return number 
final doubl get number return number final boolean eof return hit eof 
final int get token throw ioexcept int c retri for eat whitespac possibl sensit to newlin for c get char if c eof char return token eof els if c n dirti line fals return token eol els if is jsspace c if c dirti line true break if c return token xmlattr identifi keyword instanceof watch out for start with a backslash boolean identifi start boolean is unicod escap start fals if c c get char if c u identifi start true is unicod escap start true string buffer top 0 els identifi start fals unget char c c els identifi start charact is java identifi start char c if identifi start string buffer top 0 add to string c if identifi start boolean contain escap is unicod escap start for if is unicod escap start strictli speak we should probabl push back all the bad charact if the backslash u xxxx sequenc is malform but sinc there isn t a correct context is there for a bad unicod escap sequenc in an identifi we can report an error here int escap val 0 for int i 0 i 4 i c get char escap val kit x digit to int c escap val next check take care about c 0 and bad escap if escap val 0 break if escap val 0 parser add error msg invalid escap return token error add to string escap val is unicod escap start fals els c get char if c c get char if c u is unicod escap start true contain escap true els parser add error msg illeg charact return token error els if c eof char charact is java identifi part char c break add to string c unget char c string str get string from buffer if contain escap opt we shouldn t have to make a string object to check if it s a keyword return the correspond token if it s a keyword int result string to keyword str if result token eof if result token reserv return result els if parser compil env is reserv keyword as identifi return result els if implement permit to us futur reserv keyword in violat with the ecma script treat it as name but issu warn parser add warn msg reserv keyword str thi string string all string intern str return token name is it a number if is digit c c is digit peek char string buffer top 0 int base 10 if c 0 c get char if c x c x base 16 c get char els if is digit c base 8 els add to string 0 if base 16 while 0 kit x digit to int c 0 add to string c c get char els while 0 c c 9 we permit 08 and 09 as decim number which make our behavior a superset of the ecma numer grammar we might not alwai be so permiss so we warn about it if base 8 c 8 parser add warn msg bad octal liter c 8 8 9 base 10 add to string c c get char boolean is integ true if base 10 c c e c e is integ fals if c do add to string c c get char while is digit c if c e c e add to string c c get char if c c add to string c c get char if is digit c parser add error msg miss expon return token error do add to string c c get char while is digit c unget char c string num string get string from buffer doubl dval if base 10 is integ try us java convers to number from string dval doubl valu of num string doubl valu catch number format except ex parser add error msg caught nfe return token error els dval script runtim string to number num string 0 base thi number dval return token number is it a string if c c we attempt to accumul a string the fast wai by build it directli out of the reader but if there ar ani escap charact in the string we revert to build it out of a string buffer int quot char c string buffer top 0 c get char str loop while c quot char if c n c eof char unget char c parser add error msg untermin string lit return token error if c we ve hit an escap charact int escap val c get char switch c case b c b break case f c f break case n c n break case r c r break case t c t break v a late addit to the ecma spec it is not in java so us 0xb case v c 0xb break case u get 4 hex digit if the u escap is not follow by 4 hex digit us u the liter charact sequenc that follow int escap start string buffer top add to string u escap val 0 for int i 0 i 4 i c get char escap val kit x digit to int c escap val if escap val 0 continu str loop add to string c prepar for replac of store u sequenc by escap valu string buffer top escap start c escap val break case x get 2 hex digit default to x liter sequenc as abov c get char escap val kit x digit to int c 0 if escap val 0 add to string x continu str loop els int c1 c c get char escap val kit x digit to int c escap val if escap val 0 add to string x add to string c1 continu str loop els got 2 hex digit c escap val break case n remov line termin after escap to follow spider monkei and c c c get char continu str loop default if 0 c c 8 int val c 0 c get char if 0 c c 8 val 8 val c 0 c get char if 0 c c 8 val 037 c is 3rd char of octal sequenc onli if the result val 0377 val 8 val c 0 c get char unget char c c val add to string c c get char string str get string from buffer thi string string all string intern str return token string switch c case return token semi case return token lb case return token rb case return token lc case return token rc case return token lp case return token rp case return token comma case return token hook case if match char return token coloncolon els return token colon case if match char return token dotdot els if match char return token dotqueri els return token dot case if match char return token or els if match char return token assign bitor els return token bitor case if match char return token assign bitxor els return token bitxor case if match char return token and els if match char return token assign bitand els return token bitand case if match char if match char return token sheq els return token eq els return token assign case if match char if match char return token shne els return token ne els return token not case nb treat html begin comment as comment till eol if match char if match char if match char skip line continu retri unget char unget char if match char if match char return token assign lsh els return token lsh els if match char return token le els return token lt case if match char if match char if match char return token assign ursh els return token ursh els if match char return token assign rsh els return token rsh els if match char return token ge els return token gt case if match char return token assign mul els return token mul case is it a comment if match char skip line continu retri if match char boolean look for slash fals for c get char if c eof char parser add error msg untermin comment return token error els if c look for slash true els if c if look for slash continu retri els look for slash fals if match char return token assign div els return token div case if match char return token assign mod els return token mod case return token bitnot case if match char return token assign add els if match char return token inc els return token add case if match char c token assign sub els if match char if dirti line treat html end comment after possibl whitespac after line start as comment util eol if match char skip line continu retri c token dec els c token sub dirti line true return c default parser add error msg illeg charact return token error 
privat static boolean is alpha int c us z a if c z return a c els return a c c z 
static boolean is digit int c return 0 c c 9 
static boolean is jsspace int c if c 127 return c 0x20 c 0x9 c 0x c c 0x b els return c 0x a0 charact get type char c charact space separ 
privat static boolean is jsformat char int c return c 127 charact get type char c charact format 
parser call the method when it get or in liter context void read reg exp int start token throw ioexcept string buffer top 0 if start token token assign div miss scan add to string els if start token token div kit code bug int c while c get char if c n c eof char unget char c throw parser report error msg untermin re lit if c add to string c c get char add to string c int re end string buffer top while true if match char g add to string g els if match char i add to string i els if match char m add to string m els break if is alpha peek char throw parser report error msg invalid re flag thi string new string string buffer 0 re end thi reg exp flag new string string buffer re end string buffer top re end 
boolean is xmlattribut return xml is attribut 
int get first xmltoken throw ioexcept xml open tag count 0 xml is attribut fals xml is tag content fals unget char return get next xmltoken 
int get next xmltoken throw ioexcept string buffer top 0 rememb the xml for int c get char c eof char c get char if xml is tag content switch c case add to string c xml is tag content fals xml is attribut fals break case add to string c if peek char c get char add to string c xml is tag content fals xml open tag count break case unget char c thi string get string from buffer return token xml case case add to string c if read quot string c return token error break case add to string c xml is attribut true break case case t case r case n add to string c break default add to string c xml is attribut fals break if xml is tag content xml open tag count 0 thi string get string from buffer return token xmlend els switch c case add to string c c peek char switch c case c get char skip add to string c c peek char switch c case c get char skip add to string c c get char if c add to string c if read xml comment return token error els throw awai the string in progress string buffer top 0 thi string null parser add error msg xml bad form return token error break case c get char skip add to string c if get char c get char d get char a get char t get char a get char add to string c add to string d add to string a add to string t add to string a add to string if read cdata return token error els throw awai the string in progress string buffer top 0 thi string null parser add error msg xml bad form return token error break default if read entiti return token error break break case c get char skip add to string c if read pi return token error break case end tag c get char skip add to string c if xml open tag count 0 throw awai the string in progress string buffer top 0 thi string null parser add error msg xml bad form return token error xml is tag content true xml open tag count break default start tag xml is tag content true xml open tag count break break case unget char c thi string get string from buffer return token xml default add to string c break string buffer top 0 throw awai the string in progress thi string null parser add error msg xml bad form return token error 
privat boolean read quot string int quot throw ioexcept for int c get char c eof char c get char add to string c if c quot return true string buffer top 0 throw awai the string in progress thi string null parser add error msg xml bad form return fals 
privat boolean read xml comment throw ioexcept for int c get char c eof char add to string c if c peek char c get char add to string c if peek char c get char skip add to string c return true els continu c get char string buffer top 0 throw awai the string in progress thi string null parser add error msg xml bad form return fals 
privat boolean read cdata throw ioexcept for int c get char c eof char add to string c if c peek char c get char add to string c if peek char c get char skip add to string c return true els continu c get char string buffer top 0 throw awai the string in progress thi string null parser add error msg xml bad form return fals 
privat boolean read entiti throw ioexcept int decl tag 1 for int c get char c eof char c get char add to string c switch c case decl tag break case decl tag if decl tag 0 return true break string buffer top 0 throw awai the string in progress thi string null parser add error msg xml bad form return fals 
privat boolean read pi throw ioexcept for int c get char c eof char c get char add to string c if c peek char c get char skip add to string c return true string buffer top 0 throw awai the string in progress thi string null parser add error msg xml bad form return fals 
privat string get string from buffer return new string string buffer 0 string buffer top 
privat void add to string int c int n string buffer top if n string buffer length char tmp new char string buffer length 2 system arraycopi string buffer 0 tmp 0 n string buffer tmp string buffer n char c string buffer top n 1 
privat void unget char int c can not unread past across line boundari if unget cursor 0 unget buffer unget cursor 1 n kit code bug unget buffer unget cursor c 
privat boolean match char int test throw ioexcept int c get char if c test return true els unget char c return fals 
privat int peek char throw ioexcept int c get char unget char c return c 
privat int get char throw ioexcept if unget cursor 0 return unget buffer unget cursor for int c if sourc string null if sourc cursor sourc end hit eof true return eof char c sourc string char at sourc cursor els if sourc cursor sourc end if fill sourc buffer hit eof true return eof char c sourc buffer sourc cursor if line end char 0 if line end char r c n line end char n continu line end char 1 line start sourc cursor 1 lineno if c 127 if c n c r line end char c c n els if is jsformat char c continu if script runtim is jsline termin c line end char c c n return c 
privat void skip line throw ioexcept skip to end of line int c while c get char eof char c n unget char c 
final int get offset int n sourc cursor line start if line end char 0 n return n 
final string get line if sourc string null string case int line end sourc cursor if line end char 0 line end els for line end sourc end line end int c sourc string char at line end if script runtim is jsline termin c break return sourc string substr line start line end els reader case int line length sourc cursor line start if line end char 0 line length els read until the end of line for line length int i line start line length if i sourc end try if fill sourc buffer break catch ioexcept ioe ignor it we re alreadi displai an error break i recalculu as fill sourc buffer can move save line buffer and chang line start i line start line length int c sourc buffer i if script runtim is jsline termin c break return new string sourc buffer line start line length 
privat boolean fill sourc buffer throw ioexcept if sourc string null kit code bug if sourc end sourc buffer length if line start 0 system arraycopi sourc buffer line start sourc buffer 0 sourc end line start sourc end line start sourc cursor line start line start 0 els char tmp new char sourc buffer length 2 system arraycopi sourc buffer 0 tmp 0 sourc end sourc buffer tmp int n sourc reader read sourc buffer sourc end sourc buffer length sourc end if n 0 return fals sourc end n return true 
static void init scriptabl scope boolean seal base function obj new base function obj is prototyp properti immun true obj export as jsclass max prototyp id scope seal 
public base function 
public base function scriptabl scope scriptabl prototyp super scope prototyp 
public string get class name return function 
implement the instanceof oper for java script function object p code foo new foo br foo instanceof foo true br code param instanc the valu that appear on the lh of the instanceof oper return true if the prototyp properti of thi appear in valu s prototyp chain public boolean ha instanc scriptabl instanc object proto prop scriptabl object get properti thi prototyp if proto prop instanceof scriptabl return script runtim js deleg to instanc scriptabl proto prop throw script runtim type error1 msg instanceof bad prototyp get function name 
max instanc id 5 protect int get max instanc id return max instanc id 
protect int find instanc id info string s int id gener last updat 2001 05 20 00 12 12 gmt 02 00 l0 id 0 string x null int c l switch s length case 4 x name id id name break l case 5 x ariti id id ariti break l case 6 x length id id length break l case 9 c s char at 0 if c a x argument id id argument els if c p x prototyp id id prototyp break l if x null x s x equal s id 0 gener string id map if id 0 return super find instanc id info s int attr switch id case id length case id ariti case id name attr dontenum readonli perman break case id prototyp attr is prototyp properti immun dontenum readonli perman dontenum break case id argument attr dontenum perman break default throw new illeg state except return instanc id info attr id 
protect string get instanc id name int id switch id case id length return length case id ariti return ariti case id name return name case id prototyp return prototyp case id argument return argument return super get instanc id name id 
protect object get instanc id valu int id switch id case id length return script runtim wrap int get length case id ariti return script runtim wrap int get ariti case id name return get function name case id prototyp return get prototyp properti case id argument return get argument return super get instanc id valu id 
protect void set instanc id valu int id object valu if id id prototyp if is prototyp properti immun prototyp properti valu null valu uniqu tag null valu return els if id id argument if valu not found thi should not be call sinc argument is perman kit code bug default put argument valu super set instanc id valu id valu 
protect void fill constructor properti id function object ctor fix up bootstrap problem get prototyp of the id function object can not return function prototyp becaus function object is not yet defin ctor set prototyp thi super fill constructor properti ctor 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 1 s to string break case id to sourc ariti 1 s to sourc break case id appli ariti 2 s appli break case id call ariti 1 s call break default throw new illeg argument except string valu of id init prototyp method function tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag function tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor return js constructor cx scope arg case id to string base function realf real function thi obj f int indent script runtim to int32 arg 0 return realf decompil indent 0 case id to sourc base function realf real function thi obj f int indent 0 int flag decompil to sourc flag if arg length 0 indent script runtim to int32 arg 0 if indent 0 flag 0 els indent 0 return realf decompil indent flag case id appli case id call return script runtim appli or call id id appli cx scope thi obj arg throw new illeg argument except string valu of id 
privat base function real function scriptabl thi obj id function object f object x thi obj get default valu script runtim function class if x instanceof base function return base function x throw script runtim type error1 msg incompat call f get function name 
make valu as dont enum dont delet read onli prototyp properti of thi function object public void set immun prototyp properti object valu if is prototyp properti immun throw new illeg state except prototyp properti valu null valu uniqu tag null valu is prototyp properti immun true 
protect scriptabl get class prototyp object proto val get prototyp properti if proto val instanceof scriptabl return scriptabl proto val return get class prototyp thi object 
should be overridden public object call context cx scriptabl scope scriptabl thi obj object arg return undefin instanc 
public scriptabl construct context cx scriptabl scope object arg scriptabl result creat object cx scope if result null object val call cx scope result arg if val instanceof scriptabl result scriptabl val els object val call cx scope null arg if val instanceof scriptabl it is program error not to return scriptabl from the call method if creat object return null throw new illeg state except bad implementaion of call as constructor name get function name in get class get name result scriptabl val if result get prototyp null result set prototyp get class prototyp if result get parent scope null scriptabl parent get parent scope if result parent result set parent scope parent return result 
creat new script object the default implement of link construct us the method to to get the valu for tt thi obj tt argument when invok link call the metho is allow to return tt null tt to indic that link call will creat a new object itself in thi case link construct will set scope and prototyp on the result link call unless thei ar alreadi set public scriptabl creat object context cx scriptabl scope scriptabl new instanc new nativ object new instanc set prototyp get class prototyp new instanc set parent scope get parent scope return new instanc 
decompil the sourc inform associ with thi js function script back into a string param indent how much to indent the decompil result param flag flag specifi format of decompil output string decompil int indent int flag string buffer sb new string buffer boolean justbodi 0 flag decompil onli bodi flag if justbodi sb append function sb append get function name sb append n t sb append nativ code ariti sb append get ariti sb append n if justbodi sb append n return sb to string 
public int get ariti return 0 
public int get ariti return 0 public int get length return 0 
public int get length return 0 public string get function name return 
final object get prototyp properti object result prototyp properti if result null synchron thi result prototyp properti if result null setup default prototyp result prototyp properti els if result uniqu tag null valu result null return result 
privat void setup default prototyp nativ object obj new nativ object final int attr scriptabl object dontenum obj defin properti constructor thi attr put the prototyp properti into the object now then in the wacki case of a user defin a function object we don t get an infinit loop try to find the prototyp prototyp properti obj scriptabl proto get object prototyp thi if proto obj not the on we just made it must remain ground obj set prototyp proto 
privat object get argument function name argument is deprec so we us a slow wai of get it that doesn t add to the invoc cost todo add warn error base on version object valu default get argument if valu not found should after chang function name argument it activ still be avail dure function call thi code assum it should not default get argument not found mean assign argument return valu context cx context get context nativ call activ script runtim find function activ cx thi return activ null null activ get argument activ 
privat static object js constructor context cx scriptabl scope object arg int arglen arg length string buffer sourc buf new string buffer sourc buf append function version 1 2 function constructor behavior print anonym as the function name if the version under which the function wa compil is less than 1 2 or if it s greater than 1 2 becaus we need to be closer to ecma if cx get languag version context version 1 2 sourc buf append anonym sourc buf append append argument as coma separ string for int i 0 i arglen 1 i if i 0 sourc buf append sourc buf append script runtim to string arg i sourc buf append if arglen 0 append function bodi string fun bodi script runtim to string arg arglen 1 sourc buf append fun bodi sourc buf append string sourc sourc buf to string int linep new int 1 string filenam context get sourc posit from stack linep if filenam null filenam eval ed string linep 0 1 string sourc uri script runtim make url for gener script fals filenam linep 0 scriptabl global scriptabl object get top level scope scope error report report report default error report for eval cx get error report compil with explicit interpret instanc to forc interpret mode return cx compil function global sourc new interpret report sourc uri 1 null 
protect int find prototyp id string s int id string id map gener last updat 2004 03 17 13 23 22 cet l0 id 0 string x null int c l switch s length case 4 x call id id call break l case 5 x appli id id appli break l case 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string break l case 11 x constructor id id constructor break l if x null x s x equal s id 0 gener return id 
static final long serial version uid 5637830967241712746l public class definit except string detail super detail 
public class script or fn node extend node public script or fn node int node type super node type 
public final string get sourc name return sourc name 
public final string get sourc name return sourc name public final void set sourc name string sourc name thi sourc name sourc name 
public final int get encod sourc start return encod sourc start 
public final int get encod sourc start return encod sourc start public final int get encod sourc end return encod sourc end 
public final int get encod sourc end return encod sourc end public final void set encod sourc bound int start int end thi encod sourc start start thi encod sourc end end 
public final int get base lineno return base lineno 
public final void set base lineno int lineno on time action if lineno 0 base lineno 0 kit code bug base lineno lineno 
public final int get end lineno return end lineno 
public final void set end lineno int lineno on time action if lineno 0 end lineno 0 kit code bug end lineno lineno 
public final int get function count if function null return 0 return function size 
public final function node get function node int i return function node function get i 
public final int add function function node fn node if fn node null kit code bug if function null function new obj arrai function add fn node return function size 1 
public final int get regexp count if regexp null return 0 return regexp size 2 
public final string get regexp string int index return string regexp get index 2 
public final string get regexp flag int index return string regexp get index 2 1 
public final int add regexp string string string flag if string null kit code bug if regexp null regexp new obj arrai regexp add string regexp add flag return regexp size 2 1 
public final boolean ha param or var string name return it variabl name ha name 
public final int get param or var index string name return it variabl name get name 1 
public final string get param or var name int index return string it variabl get index 
public final int get param count return var start 
public final int get param and var count return it variabl size 
public final string get param and var name int n it variabl size if n 0 return script runtim empti string string arrai new string n it variabl to arrai arrai return arrai 
public final void add param string name check addparam is not call after add local if var start it variabl size kit code bug allow non uniqu paramet name us the last occurr int index var start it variabl add name it variabl name put name index 
public final void add var string name int v index it variabl name get name 1 if v index 1 there s alreadi a variabl or paramet with thi name return int index it variabl size it variabl add name it variabl name put name index 
public final void remov param or var string name int i it variabl name get name 1 if i 1 it variabl remov i it variabl name remov name obj to int map iter iter it variabl name new iter for iter start iter done iter next int v iter get valu if v i iter set valu v 1 
public final object get compil data return compil data 
public final void set compil data object data if data null throw new illeg argument except can onli call onc if compil data null throw new illeg state except compil data data 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu string arg return string 
public string ambigu object arg return object 
public string ambigu boolean arg return boolean object 
public static string static object static object public static string static ambigu boolean arg return static boolean object 
public static string static ambigu string arg return static string 
public static string static ambigu object arg return static object 
static final long serial version uid 4174889037736658296l public obj arrai 
public obj arrai public final boolean is seal return seal 
public final void seal seal true 
public final boolean is empti return size 0 
public final int size return size 
public final void set size int new size if new size 0 throw new illeg argument except if seal throw on sele mutat int n size if new size n for int i new size i n i set impl i null els if new size n if new size field store size ensur capac new size size new size 
public final object get int index if 0 index index size throw on invalid index index size return get impl index 
public final void set int index object valu if 0 index index size throw on invalid index index size if seal throw on sele mutat set impl index valu 
privat object get impl int index switch index case 0 return f0 case 1 return f1 case 2 return f2 case 3 return f3 case 4 return f4 return data index field store size 
privat void set impl int index object valu switch index case 0 f0 valu break case 1 f1 valu break case 2 f2 valu break case 3 f3 valu break case 4 f4 valu break default data index field store size valu 
public int index of object obj int n size for int i 0 i n i object current get impl i if current obj current null current equal obj return i return 1 
public int last index of object obj for int i size i 0 i object current get impl i if current obj current null current equal obj return i return 1 
public final object peek int n size if n 0 throw on empti stack top read return get impl n 1 
public final object pop if seal throw on sele mutat int n size n object top switch n case 1 throw on empti stack top read case 0 top f0 f0 null break case 1 top f1 f1 null break case 2 top f2 f2 null break case 3 top f3 f3 null break case 4 top f4 f4 null break default top data n field store size data n field store size null size n return top 
public final void push object valu add valu 
public final void add object valu if seal throw on sele mutat int n size if n field store size ensur capac n 1 size n 1 set impl n valu 
public final void add int index object valu int n size if 0 index index n throw on invalid index index n 1 if seal throw on sele mutat object tmp switch index case 0 if n 0 f0 valu break tmp f0 f0 valu valu tmp case 1 if n 1 f1 valu break tmp f1 f1 valu valu tmp case 2 if n 2 f2 valu break tmp f2 f2 valu valu tmp case 3 if n 3 f3 valu break tmp f3 f3 valu valu tmp case 4 if n 4 f4 valu break tmp f4 f4 valu valu tmp index field store size default ensur capac n 1 if index n system arraycopi data index field store size data index field store size 1 n index data index field store size valu size n 1 
public final void remov int index int n size if 0 index index n throw on invalid index index n if seal throw on sele mutat n switch index case 0 if n 0 f0 null break f0 f1 case 1 if n 1 f1 null break f1 f2 case 2 if n 2 f2 null break f2 f3 case 3 if n 3 f3 null break f3 f4 case 4 if n 4 f4 null break f4 data 0 index field store size default if index n system arraycopi data index field store size 1 data index field store size n index data n field store size null size n 
public final void clear if seal throw on sele mutat int n size for int i 0 i n i set impl i null size 0 
public final object to arrai object arrai new object size to arrai arrai 0 return arrai 
public final void to arrai object arrai to arrai arrai 0 
public final void to arrai object arrai int offset int n size switch n default system arraycopi data 0 arrai offset field store size n field store size case 5 arrai offset 4 f4 case 4 arrai offset 3 f3 case 3 arrai offset 2 f2 case 2 arrai offset 1 f1 case 1 arrai offset 0 f0 case 0 break 
privat void ensur capac int minim capac int requir minim capac field store size if requir 0 throw new illeg argument except if data null int alloc field store size 2 if alloc requir alloc requir data new object alloc els int alloc data length if alloc requir if alloc field store size alloc field store size 2 els alloc 2 if alloc requir alloc requir object tmp new object alloc if size field store size system arraycopi data 0 tmp 0 size field store size data tmp 
privat static runtim except on invalid index int index int upper bound u2209 is not element of string msg index u2209 0 upper bound throw new index out of bound except msg 
privat static runtim except on empti stack top read throw new runtim except empti stack 
privat static runtim except on sele mutat throw new illeg state except attempt to modifi seal arrai 
privat void write object object output stream os throw ioexcept os default write object int n size for int i 0 i n i object obj get impl i os write object obj 
privat void read object object input stream is throw ioexcept class not found except is default read object it read size int n size if n field store size data new object n field store size for int i 0 i n i object obj is read object set impl i obj 
public abstract class rhino except extend runtim except rhino except interpret captur interpret stack info thi 
rhino except string detail super detail interpret captur interpret stack info thi 
public final string get messag string detail detail if sourc name null line number 0 return detail string buffer buf new string buffer detail buf append if sourc name null buf append sourc name if line number 0 buf append buf append line number buf append return buf to string 
public string detail return super get messag 
get the uri of the script sourc contain the error or null if that inform is not avail public final string sourc name return sourc name 
initi the uri of the script sourc contain the error param sourc name the uri of the script sourc repons for the error it should not be tt null tt throw illeg state except if the method is call more then onc public final void init sourc name string sourc name if sourc name null throw new illeg argument except if thi sourc name null throw new illeg state except thi sourc name sourc name 
return the line number of the statement caus the error or zero if not avail public final int line number return line number 
initi the line number of the script statement caus the error param line number the line number in the script sourc it should be posit number throw illeg state except if the method is call more then onc public final void init line number int line number if line number 0 throw new illeg argument except string valu of line number if thi line number 0 throw new illeg state except thi line number line number 
the column number of the locat of the error or zero if unknown public final int column number return column number 
initi the column number of the script statement caus the error param column number the column number in the script sourc it should be posit number throw illeg state except if the method is call more then onc public final void init column number int column number if column number 0 throw new illeg argument except string valu of column number if thi column number 0 throw new illeg state except thi column number column number 
the sourc text of the line caus the error or null if unknown public final string line sourc return line sourc 
initi the text of the sourc line contain the error param line sourc the text of the sourc line repons for the error it should not be tt null tt throw illeg state except if the method is call more then onc public final void init line sourc string line sourc if line sourc null throw new illeg argument except if thi line sourc null throw new illeg state except thi line sourc line sourc 
final void record error origin string sourc name int line number string line sourc int column number xxx for compat allow for now 1 to mean 0 if line number 1 line number 0 if sourc name null init sourc name sourc name if line number 0 init line number line number if line sourc null init line sourc line sourc if column number 0 init column number column number 
privat string gener stack trace get stabl refer to work properli with concurr access char arrai writer writer new char arrai writer super print stack trace new print writer writer string orig stack trace writer to string return interpret get patch stack thi orig stack trace 
public void print stack trace print writer s if interpret stack info null super print stack trace s els s print gener stack trace 
public void print stack trace print stream s if interpret stack info null super print stack trace s els s print gener stack trace 
public string float float public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl object 
public string ambigu doubl arg return doubl 
public string ambigu char arg return char 
public string expect return char 
see context throw as script runtim ex throwabl e public wrap except throwabl except super wrap except to string thi except except kit init caus thi except int linep 0 string sourc name context get sourc posit from stack linep int line number linep 0 if sourc name null init sourc name sourc name if line number 0 init line number line number 
get the wrap except return the except that wa present as a argument to the constructor when thi object wa creat public throwabl get wrap except return except 
deprec us link get wrap except instead public object unwrap return get wrap except 
public class counter extend scriptabl object the zero argument constructor us by rhino runtim to creat instanc public counter 
method js constructor defin the java script constructor public void js constructor int a count a 
the class name is defin by the get class name method public string get class name return counter 
the method js get count defin the count properti public int js get count return count 
method can be defin us the js function prefix here we defin reset count for java script public void js function reset count count 0 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
return float public string expect return float 
void optim script or fn node script or fn int opt level it opt level opt level run on on function at a time for now int function count script or fn get function count for int i 0 i function count i opt function node f opt function node get script or fn i optim function f 
privat void optim function opt function node the function if the function fnode requir activ return in direct call function the function is target of direct call thi the function the function obj arrai statement arrai new obj arrai build statement list r the function fnode statement arrai node the statement node new node statement arrai size statement arrai to arrai the statement node block run flow analyz the function the statement node if the function fnode requir activ now that we know which local var ar in fact alwai number we re write the tree to take advantag of that ani arithmet or assign op involv just number type var is mark so that the codegen will gener non object code paramet us in number context fals for int i 0 i the statement node length i rewrit for number variabl the statement node i the function set paramet number context paramet us in number context 
privat void mark dcpnumber context node n if in direct call function n get type token getvar int var index the function get var index n if the function is paramet var index paramet us in number context true 
privat boolean convert paramet node n if in direct call function n get type token getvar int var index the function get var index n if the function is paramet var index n remov prop node isnumb prop return true return fals 
privat int rewrit for number variabl node n switch n get type case token expr void node child n get first child int type rewrit for number variabl child if type number type n put int prop node isnumb prop node both return no type case token number n put int prop node isnumb prop node both return number type case token getvar int var index the function get var index n if in direct call function the function is paramet var index n put int prop node isnumb prop node both return number type els if the function is number var var index n put int prop node isnumb prop node both return number type return no type case token inc case token dec node child n get first child will be a getvar or getprop if child get type token getvar int var index the function get var index child if the function is number var var index n put int prop node isnumb prop node both mark dcpnumber context child return number type els return no type els return no type case token setvar node l child n get first child node r child l child get next int r type rewrit for number variabl r child int var index the function get var index n if in direct call function the function is paramet var index if r type number type if convert paramet r child n put int prop node isnumb prop node both return number type mark dcpnumber context r child return no type els return r type els if the function is number var var index if r type number type n remov child r child n add child to back new node token to doubl r child n put int prop node isnumb prop node both mark dcpnumber context r child return number type els if r type number type if convert paramet r child n remov child r child n add child to back new node token to object r child return no type case token le case token lt case token ge case token gt node l child n get first child node r child l child get next int l type rewrit for number variabl l child int r type rewrit for number variabl r child mark dcpnumber context l child mark dcpnumber context r child if convert paramet l child if convert paramet r child return no type els if r type number type n put int prop node isnumb prop node right els if convert paramet r child if l type number type n put int prop node isnumb prop node left els if l type number type if r type number type n put int prop node isnumb prop node both els n put int prop node isnumb prop node left els if r type number type n put int prop node isnumb prop node right we actual build a boolean valu return no type case token add node l child n get first child node r child l child get next int l type rewrit for number variabl l child int r type rewrit for number variabl r child if convert paramet l child if convert paramet r child return no type els if r type number type n put int prop node isnumb prop node right els if convert paramet r child if l type number type n put int prop node isnumb prop node left els if l type number type if r type number type n put int prop node isnumb prop node both return number type els n put int prop node isnumb prop node left els if r type number type n put int prop node isnumb prop node right return no type case token bitxor case token bitor case token bitand case token rsh case token lsh case token sub case token mul case token div case token mod node l child n get first child node r child l child get next int l type rewrit for number variabl l child int r type rewrit for number variabl r child mark dcpnumber context l child mark dcpnumber context r child if l type number type if r type number type n put int prop node isnumb prop node both return number type els if convert paramet r child n remov child r child n add child to back new node token to doubl r child n put int prop node isnumb prop node both return number type els if r type number type if convert paramet l child n remov child l child n add child to front new node token to doubl l child n put int prop node isnumb prop node both return number type els if convert paramet l child n remov child l child n add child to front new node token to doubl l child if convert paramet r child n remov child r child n add child to back new node token to doubl r child n put int prop node isnumb prop node both return number type case token setelem case token setelem op node arrai base n get first child node arrai index arrai base get next node r valu arrai index get next int base type rewrit for number variabl arrai base if base type number type can never happen if convert paramet arrai base n remov child arrai base n add child to front new node token to object arrai base int index type rewrit for number variabl arrai index if index type number type set the isnumb prop signal the codegen to us the opt runtim set object index that take a doubl index n put int prop node isnumb prop node left mark dcpnumber context arrai index int r valu type rewrit for number variabl r valu if r valu type number type if convert paramet r valu n remov child r valu n add child to back new node token to object r valu return no type case token getelem node arrai base n get first child node arrai index arrai base get next int base type rewrit for number variabl arrai base if base type number type can never happen if convert paramet arrai base n remov child arrai base n add child to front new node token to object arrai base int index type rewrit for number variabl arrai index if index type number type if convert paramet arrai index set the isnumb prop signal the codegen to us the opt runtim get object index that take a doubl index n put int prop node isnumb prop node right return no type case token call node child n get first child the function node if child get type token getelem optim of x 0 is not support so bypass getelem optim that rewrit for number variabl would trigger rewrit as object children child child get first child els rewrit for number variabl child child child get next the first arg opt function node target opt function node n get prop node directcal prop if target null we leav each child as a number if it can be the codegen will handl move the pair of paramet while child null int type rewrit for number variabl child if type number type mark dcpnumber context child child child get next els rewrit as object children n child return no type default rewrit as object children n n get first child return no type 
privat void rewrit as object children node n node child forc optim children to be object while child null node next child child get next int type rewrit for number variabl child if type number type if convert paramet child n remov child child node nu child new node token to object child if next child null n add child to back nu child els n add child befor nu child next child child next child 
privat static void build statement list r node node obj arrai statement int type node get type if type token block type token local block type token loop type token function node child node get first child while child null build statement list r child statement child child get next els statement add node 
construct a new live nav env param file test file whose program will be evalu in thi environ param suit test suit which thi test file belong to param driver test driver that is current run public live nav env test file file test suit suit live nav drv driver super file suit driver 
open the current test file in the window by us live connect to set the window s locat href properti to a url where the test file can be found xxx need to gener html file on the fly public object execut test file try locat jsobject window get member locat driver p file name we need to look for the html file in the test directori the name of the file is the class name html string classnam file name substr 0 file name length class length html string s driver http path classnam system out println try to set browser window to s locat set member href s evalu successfulli wait for complet catch except e driver p file name fail with except e file except e to string if file name end with n js thi file pass true evalu successfulli true els thi file pass fals thi suit pass fals evalu successfulli fals return null 
get a refer to the live connect test applet unfortun due to reason i don t understand we can t just get the test file object from the live connect test via live connect attempt to cast the applet to live connect test fail with a java lang class cast except so we continu to us the temporari file hack in navig need a refer to the applet so we can properli destroi it befor close the navig window thi is http scopu bugsplat show bug cgi id 300350 and when that s fix we can ue the get applet class method below to directli access the live connect test s test file file object so we don t have us the temporari file hack public applet get applet object document object window get member document object applet jsobject document get member applet return applet jsobject applet get slot 0 
current doe not work see get applet public void get applet class applet applet try driver p the class of applet is applet get class to string driver p is it a jsobject 001 applet instanceof jsobject 001 driver p is it a live connect test applet instanceof live connect test driver p is it an applet applet instanceof applet driver p try to cast applet to jsobject 001 thi throw the class cast except driver p jsobject 001 applet to string catch except e driver p pars result threw except e 
pars the result file for thi test the which contain data in the follow format pre classnam live connect test class name pass true fals length number of testcas in thi test no pass number of testcas that pass no fail number of testcas that fail pre see com netscap javascript qa liveconnect live connect test write result to temp file public boolean pars result applet get applet vector label null vector valu null try file reader fr new file reader driver output directori get absolut path driver output directori get absolut path end with file separ file separ live connect test temp log name buffer reader br new buffer reader fr string classnam br read line boolean pass new boolean br read line boolean valu int length new doubl br read line int valu int no pass new doubl br read line int valu int no fail new doubl br read line int valu if pass thi file pass fals thi suit pass fals thi file total case length thi file case pass no pass thi suit case pass no pass thi file case fail no fail thi suit case fail no fail catch ioexcept e driver p e to string return fals return true 
destroi the test applet close navig window and delet the refer to the test applet s window public void close applet destroi open eval window name close open eval delet window name 
public string ambigu string arg return string 
public string ambigu object arg return object 
public static string static ambigu string arg return static string 
public static string static ambigu object arg return static object 
privat static final int dtobasestr buffer size 1078 privat static char basedigit int digit return char digit 10 a 10 digit 0 digit 
privat static int lo0bit int y int k int x y if x 7 0 if x 1 0 return 0 if x 2 0 return 1 return 2 k 0 if x 0xffff 0 k 16 x 16 if x 0xff 0 k 8 x 8 if x 0xf 0 k 4 x 4 if x 0x3 0 k 2 x 2 if x 1 0 k x 1 if x 1 0 return 32 return k 
return the number 0 through 32 of most signific zero bit in x privat static int hi0bit int x int k 0 if x 0xffff0000 0 k 16 x 16 if x 0xff000000 0 k 8 x 8 if x 0xf0000000 0 k 4 x 4 if x 0xc0000000 0 k 2 x 2 if x 0x80000000 0 k if x 0x40000000 0 return 32 return k 
privat static void stuff bit byte bit int offset int val bit offset byte val 24 bit offset 1 byte val 16 bit offset 2 byte val 8 bit offset 3 byte val 
bit in b in bit d must be finit and nonzero privat static big integ d2b doubl d int e int bit byte dbl bit int i k y z de long d bit doubl doubl to long bit d int d0 int d bit 32 int d1 int d bit z d0 frac mask d0 0x7fffffff clear sign bit which we ignor if de int d0 exp shift 0 z exp msk1 if y d1 0 dbl bit new byte 8 k lo0bit y y k if k 0 stuff bit dbl bit 4 y z 32 k z k els stuff bit dbl bit 4 y stuff bit dbl bit 0 z i z 0 2 1 els js assert z dbl bit new byte 4 k lo0bit z z k stuff bit dbl bit 0 z k 32 i 1 if de 0 e 0 de bia p 1 k bit 0 p k els e 0 de bia p 1 1 k bit 0 32 i hi0bit z return new big integ dbl bit 
static string js dtobasestr int base doubl d if 2 base base 36 throw new illeg argument except bad base base check for infin and na n if doubl is na n d return na n els if doubl is infinit d return d 0 0 infin infin els if d 0 alert should it distinguish 0 0 from 0 0 return 0 boolean neg if d 0 0 neg fals els neg true d d get the integ part of d includ sign string int digit doubl dfloor math floor d long lfloor long dfloor if lfloor dfloor int part fit long int digit long to string neg lfloor lfloor base els big integ should be us long floor bit doubl doubl to long bit dfloor int exp int floor bit exp shift l exp mask shift long mantissa if exp 0 mantissa floor bit frac mask l 1 els mantissa floor bit frac mask l exp msk1l if neg mantissa mantissa exp 1075 big integ x big integ valu of mantissa if exp 0 x x shift left exp els if exp 0 x x shift right exp int digit x to string base if d dfloor no fraction part return int digit els we have a fraction char buffer the output string int p index to current posit in the buffer int q int digit doubl df the fraction part of d big integ b buffer new char dtobasestr buffer size p 0 df d dfloor long d bit doubl doubl to long bit d int word0 int d bit 32 int word1 int d bit int e new int 1 int bbit new int 1 b d2b df e bbit js assert e 0 at thi point df b 2 e e must be less than zero becaus 0 df 1 int s2 word0 exp shift1 exp mask exp shift1 if s2 0 s2 1 s2 bia p 1 2 s2 next doubl d d 2 js assert s2 e big integ mlo big integ valu of 1 big integ mhi mlo if word1 0 word0 bndry mask 0 word0 exp mask exp mask 1 0 the special case here we want to be within a quarter of the last input signific digit instead of on half of it when the output string s valu is less than d s2 log2p mhi big integ valu of 1 log2p b b shift left e 0 s2 big integ s big integ valu of 1 s s shift left s2 at thi point we have the follow s 2 s2 1 df b 2 s2 0 d prev doubl d 2 mlo 2 s2 next doubl d d 2 mhi 2 s2 big integ big base big integ valu of base boolean done fals do b b multipli big base big integ div result b divid and remaind s b div result 1 digit char div result 0 int valu if mlo mhi mlo mhi mlo multipli big base els mlo mlo multipli big base mhi mhi multipli big base do we yet have the shortest string that will round to d int j b compar to mlo j is b 2 s2 compar with mlo 2 s2 big integ delta s subtract mhi int j1 delta signum 0 1 b compar to delta j1 is b 2 s2 compar with 1 mhi 2 s2 if j1 0 word1 1 0 if j 0 digit done true els if j 0 j 0 word1 1 0 if j1 0 either dig or dig 1 would work here as the least signific digit us whichev would produc an output valu closer to d b b shift left 1 j1 b compar to s if j1 0 the even test j1 0 digit 1 is not here becaus it mess up odd base output such as 3 5 in base 3 digit done true els if j1 0 digit done true js assert digit uint32 base buffer p basedigit digit while done string buffer sb new string buffer int digit length 1 p sb append int digit sb append sb append buffer 0 p return sb to string 
static int word0 doubl d long d bit doubl doubl to long bit d return int d bit 32 
static doubl set word0 doubl d int i long d bit doubl doubl to long bit d d bit long i 32 d bit 0x0ffffffffl return doubl long bit to doubl d bit 
static int word1 doubl d long d bit doubl doubl to long bit d return int d bit 
return b 5 k k must be nonneg xxxx the c version built a cach of these static big integ pow5mult big integ b int k return b multipli big integ valu of 5 pow k 
static boolean round off string buffer buf int i buf length while i 0 i char c buf char at i if c 9 buf set char at i char c 1 buf set length i 1 return fals buf set length 0 return true 
bufsiz should be two greater than the maximum number of output charact expect static int js dtoa doubl d int mode boolean bia up int ndigit boolean sign string buffer buf argument ndigit decpt sign ar similar to those of ecvt and fcvt trail zero ar suppress from the return string if not null rve is set to point to the end of the return valu if d is infin or na n then decpt is set to 9999 mode 0 shortest string that yield d when read in and round to nearest 1 like 0 but with steel white stop rule e g with ieee p754 arithmet mode 0 give 1e23 wherea mode 1 give 9 999999999999999e22 2 max 1 ndigit signific digit thi give a return valu similar to that of ecvt except that trail zero ar suppress 3 through ndigit past the decim point thi give a return valu similar to that from fcvt except that trail zero ar suppress and ndigit can be neg 4 9 should give the same return valu as 2 3 i e 4 mode 9 same return as mode 2 mode 1 these mode ar mainli for debug often thei run slower but sometim faster than mode 2 3 4 5 8 9 left to right digit gener 6 9 don t try fast float point estim if applic valu of mode other than 0 9 ar treat as mode 0 suffici space is alloc to the return valu to hold the suppress trail zero int b2 b5 i iep ilim ilim0 ilim1 j j1 k k0 m2 m5 s2 s5 char dig long l long x big integ b b1 delta mlo mhi s int be new int 1 int bbit new int 1 doubl d2 ds ep boolean spec case denorm k check try quick leftright if word0 d sign bit 0 set sign for everyth includ 0 s and na ns sign 0 true word0 d sign bit clear sign bit d set word0 d word0 d sign bit els sign 0 fals if word0 d exp mask exp mask infin or na n buf append word1 d 0 word0 d frac mask 0 infin na n return 9999 if d 0 no digit buf set length 0 buf append 0 copi 0 to buffer return 1 b d2b d be bbit if i int word0 d exp shift1 exp mask exp shift1 0 d2 set word0 d word0 d frac mask1 exp 11 log x log 1 5 x 1 5 1 5 log10 x log x log 10 log 1 5 log 10 x 1 5 1 5 log 10 log10 d i bia log 2 log 10 log10 d2 thi suggest comput an approxim k to log10 d by k i bia 0 301029995663981 d2 1 5 0 289529654602168 0 176091259055681 we want k to be too larg rather than too small the error in the first order taylor seri approxim is in our favor so we just round up the constant enough to compens for ani error in the multipl of i bia by 0 301029995663981 sinc i bia 1077 and 1077 0 30103 2 52 7 2e 14 ad 1e 13 to the constant term more than suffic henc we adjust the constant term to 0 1760912590558 we could get a more accur k by invok log10 but thi is probabl not worthwhil i bia denorm fals els d is denorm i bbit 0 be 0 bia p 1 1 x i 32 word0 d 64 i word1 d i 32 word1 d 32 i d2 x word0 d2 31 exp msk1 adjust expon d2 set word0 x word0 x 31 exp msk1 i bia p 1 1 1 denorm true at thi point d f 2 i where 1 f 2 d2 is an approxim of f ds d2 1 5 0 289529654602168 0 1760912590558 i 0 301029995663981 k int ds if ds 0 0 ds k k want k floor ds k check true if k 0 k ten pmax if d ten k k k check fals at thi point floor log10 d k floor log10 d 1 if k check is zero we re guarante that k floor log10 d j bbit 0 i 1 at thi point d b 2 j where b is an odd integ if j 0 b2 0 s2 j els b2 j s2 0 if k 0 b5 0 s5 k s2 k els b2 k b5 k s5 0 at thi point d 10 k b 2 b2 5 b5 2 s2 5 s5 where b is an odd integ b2 0 b5 0 s2 0 and s5 0 if mode 0 mode 9 mode 0 try quick true if mode 5 mode 4 try quick fals leftright true ilim ilim1 0 switch mode case 0 case 1 ilim ilim1 1 i 18 ndigit 0 break case 2 leftright fals no break case 4 if ndigit 0 ndigit 1 ilim ilim1 i ndigit break case 3 leftright fals no break case 5 i ndigit k 1 ilim i ilim1 i 1 if i 0 i 1 ilim is the maximum number of signific digit we want base on k and ndigit ilim1 is the maximum number of signific digit we want base on k and ndigit when it turn out that k wa comput too high by on boolean fast fail fals if ilim 0 ilim quick max try quick try to get by with float point arithmet i 0 d2 d k0 k ilim0 ilim iep 2 conserv divid d by 10 k keep track of the roundoff error and avoid overflow if k 0 ds ten k 0xf j k 4 if j bletch 0 prevent overflow j bletch 1 d bigten n bigten 1 iep for j 0 j 1 i if j 1 0 iep ds bigten i d ds els if j1 k 0 d ten j1 0xf for j j1 4 j 0 j 1 i if j 1 0 iep d bigten i check that k wa comput correctli if k check d 1 0 ilim 0 if ilim1 0 fast fail true els ilim ilim1 k d 10 iep ep bound the cumul error ep iep d 7 0 word0 ep p 1 exp msk1 ep iep d 7 0 ep set word0 ep word0 ep p 1 exp msk1 if ilim 0 s mhi null d 5 0 if d ep buf append 1 k return k 1 if d ep buf set length 0 buf append 0 copi 0 to buffer return 1 fast fail true if fast fail fast fail true if leftright us steel white method of onli gener digit need ep 0 5 ten ilim 1 ep for i 0 l long d d l buf append char 0 l if d ep return k 1 if 1 0 d ep goto bump up char last ch while true last ch buf char at buf length 1 buf set length buf length 1 if last ch 9 break if buf length 0 k last ch 0 break buf append char last ch 1 return k 1 if i ilim break ep 10 0 d 10 0 els gener ilim digit then fix them up ep ten ilim 1 for i 1 i d 10 0 l long d d l buf append char 0 l if i ilim if d 0 5 ep goto bump up char last ch while true last ch buf char at buf length 1 buf set length buf length 1 if last ch 9 break if buf length 0 k last ch 0 break buf append char last ch 1 return k 1 els if d 0 5 ep strip trail zero buf while s 0 s return k 1 break if fast fail buf set length 0 d d2 k k0 ilim ilim0 do we have a small integ if be 0 0 k int max ye ds ten k if ndigit 0 ilim 0 s mhi null if ilim 0 d 5 ds bia up d 5 ds buf set length 0 buf append 0 copi 0 to buffer return 1 buf append 1 k return k 1 for i 1 i l long d ds d l ds buf append char 0 l if i ilim d d if d ds d ds l 1 0 bia up bump up while s 9 if s buf k s 0 break s char last ch while true last ch buf char at buf length 1 buf set length buf length 1 if last ch 9 break if buf length 0 k last ch 0 break buf append char last ch 1 break d 10 0 if d 0 break return k 1 m2 b2 m5 b5 mhi mlo null if leftright if mode 2 i denorm be 0 bia p 1 1 1 1 p bbit 0 i is 1 plu the number of trail zero bit in d s significand thu 2 m2 5 m5 2 s2 i 5 s5 1 2 lsb of d 10 k els j ilim 1 if m5 j m5 j els s5 j m5 b5 j m5 0 if i ilim 0 m2 i i 0 2 m2 5 m5 2 s2 i 5 s5 1 2 10 1 ilim 10 k b2 i s2 i mhi big integ valu of 1 mhi 2 m2 5 m5 2 s2 5 s5 on half of last print when mode 2 or input when mode 2 signific digit divid by 10 k we still have d 10 k b 2 b2 5 b5 2 s2 5 s5 reduc common factor in b2 m2 and s2 without chang the equal if m2 0 s2 0 i m2 s2 m2 s2 b2 i m2 i s2 i fold b5 into b and m5 into mhi if b5 0 if leftright if m5 0 mhi pow5mult mhi m5 b1 mhi multipli b b b1 if j b5 m5 0 b pow5mult b j els b pow5mult b b5 now we have d 10 k b 2 b2 2 s2 5 s5 and mhi 2 m2 2 s2 5 s5 on half of last print or input signific digit divid by 10 k s big integ valu of 1 if s5 0 s pow5mult s s5 now we have d 10 k b 2 b2 s 2 s2 and mhi 2 m2 s 2 s2 on half of last print or input signific digit divid by 10 k check for special case that d is a normal power of 2 spec case fals if mode 2 if word1 d 0 word0 d bndry mask 0 word0 d exp mask exp mask 1 0 the special case here we want to be within a quarter of the last input signific digit instead of on half of it when the decim output string s valu is less than d b2 log2p s2 log2p spec case true arrang for conveni comput of quotient shift left if necessari so divisor ha 4 lead 0 bit perhap we should just comput lead 28 bit of s onc and for all and pass them and a shift to quorem so it can do shift and or to comput the numer for q byte s byte s to byte arrai int s hi word 0 for int idx 0 idx 4 idx s hi word s hi word 8 if idx s byte length s hi word s byte idx 0x ff if i s5 0 32 hi0bit s hi word 1 s2 0x1f 0 i 32 i i is the number of lead zero bit in the most signific word of s 2 s2 if i 4 i 4 b2 i m2 i s2 i els if i 4 i 28 b2 i m2 i s2 i now s 2 s2 ha exactli four lead zero bit in it most signific word if b2 0 b b shift left b2 if s2 0 s s shift left s2 now we have d 10 k b s and mhi 2 m2 s maximum accept error divid by 10 k if k check if b compar to s 0 k b b multipli big integ valu of 10 we botch the k estim if leftright mhi mhi multipli big integ valu of 10 ilim ilim1 at thi point 1 d 10 k b s 10 if ilim 0 mode 2 we re do fix mode output and d is less than the minimum nonzero output in thi mode output either zero or the minimum nonzero output depend on which is closer to d if ilim 0 i b compar to s s multipli big integ valu of 5 0 i 0 bia up alwai emit at least on digit if the number appear to be zero us the current mode then emit on 0 digit and set decpt to 1 no digit k 1 ndigit goto ret buf set length 0 buf append 0 copi 0 to buffer return 1 goto no digit on digit buf append 1 k return k 1 if leftright if m2 0 mhi mhi shift left m2 comput mlo check for special case that d is a normal power of 2 mlo mhi if spec case mhi mlo mhi mhi shift left log2p mlo s maximum accept error divid by 10 k if the output is less than d mhi s maximum accept error divid by 10 k if the output is greater than d for i 1 i big integ div result b divid and remaind s b div result 1 dig char div result 0 int valu 0 do we yet have the shortest decim string that will round to d j b compar to mlo j is b s compar with mlo s delta s subtract mhi j1 delta signum 0 1 b compar to delta j1 is b s compar with 1 mhi s if j1 0 mode 0 word1 d 1 0 if dig 9 buf append 9 if round off buf k buf append 1 return k 1 goto round 9 up if j 0 dig buf append dig return k 1 if j 0 j 0 mode 0 word1 d 1 0 if j1 0 either dig or dig 1 would work here as the least signific decim digit us whichev would produc a decim valu closer to d b b shift left 1 j1 b compar to s if j1 0 j1 0 dig 1 1 bia up dig 9 buf append 9 if round off buf k buf append 1 return k 1 goto round 9 up buf append dig return k 1 if j1 0 if dig 9 possibl if i 1 round 9 up s 9 goto roundoff buf append 9 if round off buf k buf append 1 return k 1 buf append char dig 1 return k 1 buf append dig if i ilim break b b multipli big integ valu of 10 if mlo mhi mlo mhi mhi multipli big integ valu of 10 els mlo mlo multipli big integ valu of 10 mhi mhi multipli big integ valu of 10 els for i 1 i char dig quorem b s 0 big integ div result b divid and remaind s b div result 1 dig char div result 0 int valu 0 buf append dig if i ilim break b b multipli big integ valu of 10 round off last digit b b shift left 1 j b compar to s if j 0 j 0 dig 1 1 bia up roundoff while s 9 if s buf k s 1 goto ret s if round off buf k buf append 1 return k 1 els strip trail zero buf while s 0 s ret bfree s if mhi if mlo mlo mhi bfree mlo bfree mhi ret1 bfree b js assert s buf bufsiz return k 1 
privat static void strip trail zero string buffer buf while s 0 s int bl buf length while bl 0 buf char at bl 0 buf set length bl 1 
static void js dtostr string buffer buffer int mode int precis doubl d int dec pt posit of decim point rel to first digit return by js dtoa boolean sign new boolean 1 true if the sign bit wa set in d int n digit number of significand digit return by js dtoa js assert buffer size size t mode dtostr standard exponenti dtostr standard buffer size dtostr variabl buffer size precis if mode dtostr fix d 1e21 d 1e21 mode dtostr standard chang mode here rather than below becaus the buffer mai not be larg enough to hold a larg integ dec pt js dtoa d dtoa mode mode mode dtostr fix precis sign buffer n digit buffer length if infin infin or na n return the string regardless of the mode if dec pt 9999 boolean exponenti notat fals int min ndigit 0 minimum number of significand digit requir by mode and precis int p int q switch mode case dtostr standard if dec pt 5 dec pt 21 exponenti notat true els min ndigit dec pt break case dtostr fix if precis 0 min ndigit dec pt precis els min ndigit dec pt break case dtostr exponenti js assert precis 0 min ndigit precis fall through case dtostr standard exponenti exponenti notat true break case dtostr precis js assert precis 0 min ndigit precis if dec pt 5 dec pt precis exponenti notat true break if the number ha fewer than min ndigit pad it with zero at the end if n digit min ndigit p min ndigit n digit min ndigit do buffer append 0 while buffer length p if exponenti notat insert a decim point if more than on significand digit if n digit 1 buffer insert 1 buffer append e if dec pt 1 0 buffer append buffer append dec pt 1 js snprintf num end buffer size num end buffer e d dec pt 1 els if dec pt n digit some kind of a fraction in fix notat js assert dec pt n digit if dec pt 0 dd dd dd dd buffer insert dec pt els 0 00 00dd dd for int i 0 i 1 dec pt i buffer insert 0 0 buffer insert 1 if neg and neither 0 0 nor na n output a lead if sign 0 word0 d sign bit word1 d 0 word0 d exp mask exp mask word1 d 0 word0 d frac mask 0 buffer insert 0 
public id function object id function call idcal object tag int id int ariti if ariti 0 throw new illeg argument except thi idcal idcal thi tag tag thi method id id thi ariti ariti if ariti 0 throw new illeg argument except 
public id function object id function call idcal object tag int id string name int ariti scriptabl scope super scope null if ariti 0 throw new illeg argument except if name null throw new illeg argument except thi idcal idcal thi tag tag thi method id id thi ariti ariti thi function name name 
public void init function string name scriptabl scope if name null throw new illeg argument except if scope null throw new illeg argument except thi function name name set parent scope scope 
public final boolean ha tag object tag return thi tag tag 
public final int method id return method id 
public final void mark as constructor scriptabl prototyp properti us call as constructor true set immun prototyp properti prototyp properti 
public final void add as properti scriptabl target scriptabl object defin properti target function name thi scriptabl object dontenum 
public void export as scope properti add as properti get parent scope 
public scriptabl get prototyp lazi initi of prototyp for nativ function thi mai not be call at all scriptabl proto super get prototyp if proto null proto get function prototyp get parent scope set prototyp proto return proto 
public object call context cx scriptabl scope scriptabl thi obj object arg return idcal exec id call thi cx scope thi obj arg 
public scriptabl creat object context cx scriptabl scope if us call as constructor return null throw error if not explicitli code to be us as constructor to satisfi ecmascript standard see bugzilla 202019 to follow current 2003 05 01 spider monkei behavior chang it to return super creat object cx scope throw script runtim type error1 msg not ctor function name 
string decompil int indent int flag string buffer sb new string buffer boolean justbodi 0 flag decompil onli bodi flag if justbodi sb append function sb append get function name sb append sb append nativ code for if idcal instanceof scriptabl scriptabl sobj scriptabl idcal sb append sobj get class name sb append sb append get function name sb append ariti sb append get ariti sb append justbodi n n return sb to string 
public int get ariti return ariti 
public int get length return get ariti 
public int get length return get ariti public string get function name return function name null function name 
public final runtim except unknown it is program error to call id like method for unknown function return new illeg argument except bad function id method id master idcal 
static void init scriptabl scope boolean seal nativ object obj new nativ object obj export as jsclass max prototyp id scope seal 
public string get class name return object 
public string to string return script runtim default object to string thi 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 0 s to string break case id to local string ariti 0 s to local string break case id valu of ariti 0 s valu of break case id ha own properti ariti 1 s ha own properti break case id properti is enumer ariti 1 s properti is enumer break case id is prototyp of ariti 1 s is prototyp of break case id to sourc ariti 0 s to sourc break default throw new illeg argument except string valu of id init prototyp method object tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag object tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor if thi obj null base function construct will set up parent proto return f construct cx scope arg if arg length 0 arg 0 null arg 0 undefin instanc return new nativ object return script runtim to object cx scope arg 0 case id to local string for now just alia to string case id to string if cx ha featur context featur to string as sourc string s script runtim default object to sourc cx scope thi obj arg int l s length if l 0 s char at 0 s char at l 1 strip that surround to sourc s s substr 1 l 1 return s return script runtim default object to string thi obj case id valu of return thi obj case id ha own properti boolean result if arg length 0 result fals els string s script runtim to string id or index cx arg 0 if s null int index script runtim last index result cx result thi obj ha index thi obj els result thi obj ha s thi obj return script runtim wrap boolean result case id properti is enumer boolean result if arg length 0 result fals els string s script runtim to string id or index cx arg 0 if s null int index script runtim last index result cx result thi obj ha index thi obj if result thi obj instanceof scriptabl object scriptabl object so scriptabl object thi obj int attr so get attribut index result attr scriptabl object dontenum 0 els result thi obj ha s thi obj if result thi obj instanceof scriptabl object scriptabl object so scriptabl object thi obj int attr so get attribut s result attr scriptabl object dontenum 0 return script runtim wrap boolean result case id is prototyp of boolean result fals if arg length 0 arg 0 instanceof scriptabl scriptabl v scriptabl arg 0 do v v get prototyp if v thi obj result true break while v null return script runtim wrap boolean result case id to sourc return script runtim default object to sourc cx scope thi obj arg default throw new illeg argument except string valu of id 
protect int find prototyp id string s int id gener last updat 2003 11 11 01 51 40 cet l0 id 0 string x null int c l switch s length case 7 x valu of id id valu of break l case 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string break l case 11 x constructor id id constructor break l case 13 x is prototyp of id id is prototyp of break l case 14 c s char at 0 if c h x ha own properti id id ha own properti els if c t x to local string id id to local string break l case 20 x properti is enumer id id properti is enumer break l if x null x s x equal s id 0 gener return id 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public int ambigu char arg return char 
public int ambigu short arg return short 
nativ java top packag class loader loader super true loader 
public object call context cx scriptabl scope scriptabl thi obj object arg return construct cx scope arg 
public scriptabl construct context cx scriptabl scope object arg class loader loader null if arg length 0 object arg arg 0 if arg instanceof wrapper arg wrapper arg unwrap if arg instanceof class loader loader class loader arg if loader null context report runtim error0 msg not classload return null return new nativ java packag true loader 
public static void init context cx scriptabl scope boolean seal class loader loader cx get applic class loader final nativ java top packag top new nativ java top packag loader top set prototyp get object prototyp scope top set parent scope scope string name kit semicolon split common packag for int i 0 i name length i top forc packag name i scope get class implement id function object get class new id function object top ftag id get class get class 1 scope we want to get a real alia and not a distinct java packag with the same packag name so that we share class and top that ar underneath nativ java packag java alia nativ java packag top get java top it s safe to downcast here sinc init standard object take a scriptabl object scriptabl object global scriptabl object scope if seal get class seal object get class export as scope properti global defin properti packag top scriptabl object dontenum global defin properti java java alia scriptabl object dontenum 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag ftag if f method id id get class return js get class cx scope arg throw f unknown 
privat scriptabl js get class context cx scriptabl scope object arg if arg length 0 arg 0 instanceof wrapper scriptabl result thi class cl wrapper arg 0 unwrap get class evalu the class name by get success properti of the string to find the appropri nativ java class object string name cl get name int offset 0 for int index name index of offset string prop name index 1 name substr offset name substr offset index object prop result get prop name result if prop instanceof scriptabl break fall through to error result scriptabl prop if index 1 return result offset index 1 throw context report runtim error0 msg not java obj 
public abstract class xmlobject extend id scriptabl object public xmlobject 
public xmlobject scriptabl scope scriptabl prototyp super scope prototyp 
implement of ecmascript ha public abstract boolean ecma ha context cx object id 
public abstract boolean ecma ha context cx object id implement of ecmascript get public abstract object ecma get context cx object id 
public abstract object ecma get context cx object id implement of ecmascript put public abstract void ecma put context cx object id object valu 
public abstract void ecma put context cx object id object valu implement of ecmascript delet public abstract boolean ecma delet context cx object id 
return an addit object to look for method that runtim should consid dure method search return null if no such object avail 
gener refer to implement x y x y etc public abstract ref member ref context cx object elem 
gener refer to implement x ns x ns y x ns y etc public abstract ref member ref context cx object namespac object elem 
int member type flag wrap thi object into nativ with to implement the with statement public abstract nativ with enter with scriptabl scope 
public abstract nativ with enter with scriptabl scope wrap thi object into nativ with to implement the queri public abstract nativ with enter dot queri scriptabl scope 
custom tt tt oper should return link scriptabl not found if thi object doe not have custom addit oper for the given valu or the result of the addit oper p the default implement return link scriptabl not found to indic no custom addit oper param cx the context object associ with the current thread param thi is left if true the object should calcul thi valu if fals the object should calcul valu thi param valu the second argument for addit oper public object add valu context cx boolean thi is left object valu return scriptabl not found 
public class data type 010 extend live connect test public data type 010 super 
public static void main string arg data type 010 test new data type 010 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt static get doubl arrai true do arrai test dt pub static arrai doubl true do arrai test dt get doubl arrai true do arrai test dt pub arrai doubl fals 
assign a java byte arrai to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command the command to eval to get the byte arrai public void do arrai test string command boolean should equal doubl arrai data type class pub static arrai doubl doubl js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java object js arrai doubl global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai doubl item doubl global eval js arrai i add test case js arrai command global eval var js arrai command global eval js arrai i equal arrai i true item equal new doubl arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal true fals js arrai arrai 
opt function node function node fnode thi fnode fnode fnode set compil data thi 
static opt function node get script or fn node script or fn int i function node fnode script or fn get function node i return opt function node fnode get compil data 
static opt function node get script or fn node script or fn return opt function node script or fn get compil data 
boolean is target of direct call return direct target index 0 
int get direct target index return direct target index 
void set direct target index int direct target index on time action if direct target index 0 thi direct target index 0 kit code bug thi direct target index direct target index 
void set paramet number context boolean b it paramet number context b 
boolean get paramet number context return it paramet number context 
int get var count return fnode get param and var count 
boolean is paramet int var index return var index fnode get param count 
boolean is number var int var index var index fnode get param count if var index 0 number var flag null return number var flag var index return fals 
void set is number var int var index var index fnode get param count can onli be us with non paramet if var index 0 kit code bug if number var flag null int size fnode get param and var count fnode get param count number var flag new boolean size number var flag var index true 
int get var index node n int index n get int prop node variabl prop 1 if index 1 string name int type n get type if type token getvar name n get string els if type token setvar name n get first child get string els throw kit code bug index fnode get param or var index name if index 0 throw kit code bug n put int prop node variabl prop index return index 
creat a new test suit object param name name of the test suit param file path full path to test suit directori public test suit string name string file path thi name name thi file path file path thi pass true thi total case 0 thi case pass 0 thi case fail 0 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
implement call shrink optim code public static object call0 callabl fun scriptabl thi obj context cx scriptabl scope return fun call cx scope thi obj script runtim empti arg 
implement arg call shrink optim code public static object call1 callabl fun scriptabl thi obj object arg0 context cx scriptabl scope return fun call cx scope thi obj new object arg0 
implement arg0 arg1 call shrink optim code public static object call2 callabl fun scriptabl thi obj object arg0 object arg1 context cx scriptabl scope return fun call cx scope thi obj new object arg0 arg1 
implement arg0 arg1 call shrink optim code public static object call n callabl fun scriptabl thi obj object arg context cx scriptabl scope return fun call cx scope thi obj arg 
implement name arg call shrink optim code public static object call name object arg string name context cx scriptabl scope callabl f get name function and thi name cx scope scriptabl thi obj last store scriptabl cx return f call cx scope thi obj arg 
implement name call shrink optim code public static object call name0 string name context cx scriptabl scope callabl f get name function and thi name cx scope scriptabl thi obj last store scriptabl cx return f call cx scope thi obj script runtim empti arg 
implement x properti call shrink optim code public static object call prop0 object valu string properti context cx scriptabl scope callabl f get prop function and thi valu properti cx scriptabl thi obj last store scriptabl cx return f call cx scope thi obj script runtim empti arg 
public static object add object val1 doubl val2 if val1 instanceof scriptabl val1 scriptabl val1 get default valu null if val1 instanceof string return wrap doubl to number val1 val2 return string val1 concat to string val2 
public static object add doubl val1 object val2 if val2 instanceof scriptabl val2 scriptabl val2 get default valu null if val2 instanceof string return wrap doubl to number val2 val1 return to string val1 concat string val2 
public static object pad start object current arg int count object result new object current arg length count system arraycopi current arg 0 result count current arg length return result 
public static void init function nativ function fn int function type scriptabl scope context cx script runtim init function cx scope fn function type fals 
public static object call special context cx callabl fun scriptabl thi obj object arg scriptabl scope scriptabl caller thi int call type string file name int line number return script runtim call special cx fun thi obj arg scope caller thi call type file name line number 
public static object new object special context cx object fun object arg scriptabl scope scriptabl caller thi int call type return script runtim new special cx fun arg scope call type 
public static doubl wrap doubl doubl num if num 0 0 if 1 num 0 0 0 return zero obj els if num 1 0 return on obj els if num 1 0 return minu on obj els if num num return na nobj return new doubl num 
static string encod int arrai int arrai xxx thi extrem ineffici for small integ if arrai null return null int n arrai length char buffer new char 1 n 2 buffer 0 1 for int i 0 i n i int valu arrai i int shift 1 i 2 buffer shift char valu 16 buffer shift 1 char valu return new string buffer 
privat static int decod int arrai string str int arrai size xxx thi extrem ineffici for small integ if arrai size 0 if str null throw new illeg argument except return null if str length 1 arrai size 2 str char at 0 1 throw new illeg argument except int arrai new int arrai size for int i 0 i arrai size i int shift 1 i 2 arrai i str char at shift 16 str char at shift 1 return arrai 
public static scriptabl new arrai liter object object string encod int int skip count context cx scriptabl scope int skip indexc decod int arrai encod int skip count return new arrai liter object skip indexc cx scope 
public static void main final script script final string arg context call new context action public object run context cx scriptabl object global get global cx get the command line argument and defin argument arrai in the top level object object arg copi new object arg length system arraycopi arg 0 arg copi 0 arg length scriptabl arg obj cx new arrai global arg copi global defin properti argument arg obj scriptabl object dontenum script exec cx global return null 
context call new context action public object run context cx scriptabl object global get global cx get the command line argument and defin argument arrai in the top level object object arg copi new object arg length system arraycopi arg 0 arg copi 0 arg length scriptabl arg obj cx new arrai global arg copi global defin properti argument arg obj scriptabl object dontenum script exec cx global return null 
public class slot 002 extend live connect test public slot 002 super 
super public static void main string arg slot 002 test new slot 002 test start 
public void execut test get base object object test matrix get data arrai string arg get arrai argument test matrix jsobject js arrai creat jsarrai arg get length js arrai test matrix length for int i 0 i test matrix length i get slot js arrai i object test matrix i 
public string get arrai argument object matrix string buffer buffer new string buffer for int i 0 i matrix length i buffer append object matrix i 0 if i matrix length 1 buffer append return buffer to string 
get the constructor of all the base java script object the test will compar the instanc constructor to the base object constructor to verifi that the java script type of the object is corret public boolean get base object try js number jsobject global eval number prototyp constructor js string jsobject global eval string prototyp constructor js function jsobject global eval function prototyp constructor js boolean jsobject global eval boolean prototyp constructor js object jsobject global eval object prototyp constructor js math jsobject global eval math js date jsobject global eval date prototyp constructor js arrai jsobject global eval arrai prototyp constructor js reg exp jsobject global eval reg exp prototyp constructor catch except e system err println fail in get base object e to string e print stack trace return fals return true 
get the data arrai which is an arrai of arrai each of the intern arrai consist of three object a string whose valu will be pass to the java script arrai constructor a string which is the expect string valu of retreiv the jsobject via get slot and a jsobject which is the jsobject s constructor that allow us to verifi the type of jsobject return the data arrai public object get data arrai object item0 new string new string java script string new string java script string js string object item1 new string new number 12345 new string 12345 js number object item2 new string new boolean fals new string fals js boolean object item3 new string new arrai 0 1 2 3 4 new string 0 1 2 3 4 js arrai object item4 new string new object new string object object js object object data arrai item0 item1 item2 item3 item4 return data arrai 
creat a java script arrai name js arrai param new arrai argument string contain a list of argument for the java script arrai constructor return the jsobject arrai object public jsobject creat jsarrai string new arrai argument jsobject js arrai null string arg var js arrai new arrai new arrai argument string result pass try system out println arg global eval arg js arrai jsobject global get member js arrai catch except e result fail except global get member js arrai threw e to string file except except e print stack trace final add test case global eval var js arrai new arrai new arrai argument jsobject js arrai jsobject global get member js arrai pass result except return js arrai 
us jsobject get member to get the length properti of a jsobject param js arrai a jsobject with a properti name length param java length the expect length of the jsobject public void get length jsobject js arrai int java length string except int js length 0 try js length doubl js arrai get member length int valu catch except e except js arrai get member length threw e to string file except except e print stack trace final add test case length is js length js arrai get member length int valu java length true js length java length except 
us jsobject get slot to get an index member of a jsobject in thi test the expect class of all object is jsobject param js arrai the jsobject with index member param slot the index properti to retriev param data object arrai contain the string represent of the expect result of js arrai get slot slot and the jsobjectconstructor of the expect result which allow us to verifi the valu and type of the result object public void get slot jsobject js arrai int slot object data string except jsobject constructor null jsobject result null class e class null class a class null try result jsobject js arrai get slot slot if result null e class class for name netscap javascript jsobject a class result get class constructor jsobject result get member constructor catch except e except js arrai get slot slot threw e to string file except except e print stack trace final if result null add test case js arrai get slot slot to string trim return result data 1 equal result true data 1 to string trim equal result to string except els check the string valu of the result add test case js arrai get slot slot return result data 1 to string equal result true data 1 equal result except check the class of the result all should be jsobject add test case e class equal a class true e class equal a class except constructor of the result add test case constructor equal data 2 true constructor equal data 2 except 
opt transform hashtabl possibl direct call obj arrai direct call target thi possibl direct call possibl direct call thi direct call target direct call target 
protect void visit new node node script or fn node tree detect direct call node tree super visit new node tree 
protect void visit call node node script or fn node tree detect direct call node tree super visit call node tree 
privat void detect direct call node node script or fn node tree if tree get type token function node left node get first child count the argument int arg count 0 node arg left get next while arg null arg arg get next arg count if arg count 0 opt function node get tree it contain calls0 true optim a call site by convert call a b c into function object for a instanc variabl init d by constructor thi is a directcal node fn get prop tmp get base a a if fn function object for a fn call tmp b c els script runtim call fn tmp b c if possibl direct call null string target name null if left get type token name target name left get string els if left get type token getprop target name left get first child get next get string if target name null opt function node ofn ofn opt function node possibl direct call get target name if ofn null arg count ofn fnode get param count ofn fnode requir activ refus to direct call ani function with more than 32 paramet prevent code explos for wacki test case if arg count 32 node put prop node directcal prop ofn if ofn is target of direct call int index direct call target size direct call target add ofn ofn set direct target index index 
creat a new mac ref env public mac ref env test file f test suit s ref drv d thi file f thi suit s thi driver d 
thi implement doe noth sinc creat the js shell automat run the test on the mac public object execut test file return null 
instanti a new java script shell which ha been built with mac test hack defin public object creat context try look for a file call flagfil flg file flag new file flagfil flg if flag exist flag delet task runtim get runtim exec driver execut wait a maximum of five minut int i 0 while flag exist i 60 thread current thread sleep 5000 catch ioexcept x system out println ioexcept in run js x catch interrupt except x system out println interrupt except in run js x return null 
public boolean setup mac file boolean result1 get directori name delet result file boolean result3 creat testarg file boolean result4 write testarg file if result1 result3 result4 return true els return fals 
public synchron void run test try if setup mac file file start time driver get current time creat context file end time driver get current time if task get exit valu 0 if file name end with n js file pass true els suit pass fals file pass fals if pars result if file name end with n js file pass true els suit pass fals file pass fals file except new string task get error catch except e suit pass fals file pass fals file except unknown process except file except new string task get error exit valu task get exit valu n threw except e 
public boolean pars result string line int i j result new file result txt if result exist return fals spit out all the line we find in the result file try file reader fr new file reader result line number reader lnr new line number reader fr do line lnr read line driver p line if line null driver p t error no line to read return fals while line equal size tag if line lnr read line null return fals file total case integ valu of line int valu if line lnr read line null driver p t error no line after size tag return fals for i 0 i file total case i string valu new string tag length try for j 0 j tag length j valu j null if line start with tag j driver p line didn t start with tag j line return fals while line lnr read line null line start with start tag valu j valu j null line valu j n line if valu j null valu j if line null i file total case 1 driver p line null and i file total case 1 return fals catch ioexcept e driver p except read process output e file except e to string return fals test case rt new test case valu 0 valu 1 valu 4 valu 2 valu 3 valu 5 file bugnumb valu 6 file case vector add element rt if rt pass equal fals if file name end with n js thi file pass true els thi file pass fals thi suit pass fals try lnr close fr close catch ioexcept x system out println ioexcept in run js x return fals catch number format except nfe system out println t error no integ after size tag return fals catch ioexcept e system out println except read process output e to string file except e to string return fals return true 
get the execut s directori which is where we will write testarg txt and from where we will get result txt public boolean get directori name directori name return true 
check to see whether testarg txt exist if so delet it public boolean creat testarg file string testargsnam testarg txt file testargsfil new file testargsnam if testargsfil exist testargsfil delet testarg new test log testarg txt return true 
public boolean delet result file string resultsnam result txt file resultsfil new file resultsnam if resultsfil exist resultsfil delet return true 
write testarg txt to the directori where the execut is public boolean write testarg file string helper get mac file string driver helper string string testfil get mac file string file file path testarg write line f testarg write line helper testarg write line f testarg write line testfil testarg close log return true 
public void close return 
replac slash in a string with colon public string get mac file string string path string buffer buffer new string buffer int i for i 0 i path length i if path char at i buffer append els buffer append path char at i return buffer to string 
int pretti indent scriptabl global scope return global scope 
privat xmllib impl scriptabl global scope thi global scope global scope default set 
public static void init context cx scriptabl scope boolean seal to forc linkag error if xml object is not avail xml object class get name xmllib impl lib new xmllib impl scope xmllib bound lib bind to scope scope if bound lib lib export to scope seal 
privat void export to scope boolean seal xml prototyp xml creat empti xml thi xml list prototyp new xmllist thi namespac prototyp new namespac thi qname prototyp new qname thi xml prototyp export as jsclass seal xml list prototyp export as jsclass seal namespac prototyp export as jsclass seal qname prototyp export as jsclass seal 
void default set ignor comment true ignor process instruct true ignor whitespac true pretti print true pretti indent 2 
xmlname to attribut name context cx object name valu string uri string local name if name valu instanceof string uri local name string name valu els if name valu instanceof xmlname xmlname xml name xmlname name valu if xml name is attribut name xml name set attribut name return xml name els if name valu instanceof qname qname qname qname name valu uri qname uri local name qname local name els if name valu instanceof boolean name valu instanceof number name valu undefin instanc name valu null throw bad xmlname name valu els uri local name script runtim to string name valu xmlname xml name xmlname form properti uri local name xml name set attribut name return xml name 
privat static runtim except bad xmlname object valu string msg if valu instanceof number msg can not construct xml name from number els if valu instanceof boolean msg can not construct xml name from boolean els if valu undefin instanc valu null msg can not construct xml name from els throw new illeg argument except valu to string return script runtim type error msg script runtim to string valu 
xmlname to xmlname context cx object name valu xmlname result if name valu instanceof xmlname result xmlname name valu els if name valu instanceof qname qname qname qname name valu result xmlname form properti qname uri qname local name els if name valu instanceof string result to xmlname from string cx string name valu els if name valu instanceof boolean name valu instanceof number name valu undefin instanc name valu null throw bad xmlname name valu els string name script runtim to string name valu result to xmlname from string cx name return result 
if valu repres uint32 index make it avail through script runtim last uint32result cx and return null otherwis return the same valu as to xmlname cx valu xmlname to xmlname or index context cx object valu xmlname result if valu instanceof xmlname result xmlname valu els if valu instanceof string string str string valu long test script runtim test uint32str str if test 0 script runtim store uint32result cx test result null els result to xmlname from string cx str els if valu instanceof number doubl d number valu doubl valu long l long d if l d 0 l l 0x ffffffffl script runtim store uint32result cx l result null els throw bad xmlname valu els if valu instanceof qname qname qname qname valu string uri qname uri boolean number fals result null if uri null uri length 0 onli in thi case qname to string can resembl uint32 long test script runtim test uint32str uri if test 0 script runtim store uint32result cx test number true if number result xmlname form properti uri qname local name els if valu instanceof boolean valu undefin instanc valu null throw bad xmlname valu els string str script runtim to string valu long test script runtim test uint32str str if test 0 script runtim store uint32result cx test result null els result to xmlname from string cx str return result 
xmlname to xmlname from string context cx string name if name null throw new illeg argument except int l name length if l 0 char first char name char at 0 if first char if l 1 return xmlname form star els if first char xmlname xml name xmlname form properti name substr 1 xml name set attribut name return xml name string uri get default namespac uri cx return xmlname form properti uri name 
namespac construct namespac context cx object uri valu string prefix string uri if uri valu instanceof namespac namespac ns namespac uri valu prefix ns prefix uri ns uri els if uri valu instanceof qname qname qname qname uri valu uri qname uri if uri null prefix qname prefix els uri qname to string prefix null els uri script runtim to string uri valu prefix uri length 0 null return new namespac thi prefix uri 
namespac cast to namespac context cx object namescap obj if namescap obj instanceof namespac return namespac namescap obj return construct namespac cx namescap obj 
namespac construct namespac context cx return new namespac thi 
public namespac construct namespac context cx object prefix valu object uri valu string prefix string uri if uri valu instanceof qname qname qname qname uri valu uri qname uri if uri null uri qname to string els uri script runtim to string uri valu if uri length 0 if prefix valu undefin instanc prefix els prefix script runtim to string prefix valu if prefix length 0 throw script runtim type error illeg prefix prefix for no namespac els if prefix valu undefin instanc prefix els if is xmlname cx prefix valu prefix els prefix script runtim to string prefix valu return new namespac thi prefix uri 
string get default namespac uri context cx string uri if cx null cx context get current context if cx null object ns script runtim search default namespac cx if ns null if ns instanceof namespac uri namespac ns uri els should not happen but for now it could due to bad search default namespac implement return uri 
namespac get default namespac context cx if cx null cx context get current context if cx null return namespac prototyp namespac result object ns script runtim search default namespac cx if ns null result namespac prototyp els if ns instanceof namespac result namespac ns els should not happen but for now it could due to bad search default namespac implement result namespac prototyp return result 
qname cast to qname context cx object qname valu if qname valu instanceof qname return qname qname valu return construct qname cx qname valu 
qname construct qname context cx object name valu qname result if name valu instanceof qname qname qname qname name valu result new qname thi qname uri qname local name qname prefix els string local name script runtim to string name valu result construct qname from string cx local name return result 
optim version of construct qname for string type qname construct qname from string context cx string local name if local name null throw new illeg argument except string uri string prefix if equal local name uri null prefix null els namespac ns get default namespac cx uri ns uri prefix ns prefix return new qname thi uri local name prefix 
qname construct qname context cx object namespac valu object name valu string uri string local name string prefix if name valu instanceof qname qname qname qname name valu local name qname local name els local name script runtim to string name valu namespac ns if namespac valu undefin instanc if equal local name ns null els ns get default namespac cx els if namespac valu null ns null els if namespac valu instanceof namespac ns namespac namespac valu els ns construct namespac cx namespac valu if ns null uri null prefix null els uri ns uri prefix ns prefix return new qname thi uri local name prefix 
object add xmlobject context cx xmlobject obj1 xmlobject obj2 xmllist list to add new xmllist thi if obj1 instanceof xmllist xmllist list1 xmllist obj1 if list1 length 1 list to add add to list list1 item 0 els might be xml fragment xml fragment xml fragment then the result will be an xmllist which we want to be an r valu and allow it to be assign to an lvalu list to add new xmllist thi obj1 els list to add add to list xml obj1 if obj2 instanceof xmllist xmllist list2 xmllist obj2 for int i 0 i list2 length i list to add add to list list2 item i els if obj2 instanceof xml list to add add to list xml obj2 return list to add 
see e4x 13 1 2 1 public boolean is xmlname context cx object name obj string name try name script runtim to string name obj catch ecma error ee if type error equal ee get name return fals throw ee see http w3 org tr xml names11 nt ncname int length name length if length 0 if is ncname start char name char at 0 for int i 1 i length i if is ncname char name char at i return fals return true return fals 
privat static boolean is ncname start char int c if c 0x7f 0 optim for ascii and us a z a z if c a return c z els if c a if c z return true return c els if c 0x1fff 0 return 0x c0 c c 0x d6 0x d8 c c 0x f6 0x f8 c c 0x2ff 0x370 c c 0x37d 0x37f c return 0x200c c c 0x200d 0x2070 c c 0x218f 0x2c00 c c 0x2fef 0x3001 c c 0x d7ff 0x f900 c c 0x fdcf 0x fdf0 c c 0x fffd 0x10000 c c 0x effff 
privat static boolean is ncname char int c if c 0x7f 0 optim for ascii and us 0 9 a z a z if c a return c z els if c a if c z return true return c els if c 0 return c 9 els return c c els if c 0x1fff 0 return is ncname start char c c 0x b7 0x300 c c 0x36f return is ncname start char c 0x203f c c 0x2040 
xmlname to qualifi name context cx object namespac valu object name valu thi is duplic of construct qname cx namespac valu name valu but for xmlname string uri string local name if name valu instanceof qname qname qname qname name valu local name qname local name els local name script runtim to string name valu namespac ns if namespac valu undefin instanc if equal local name ns null els ns get default namespac cx els if namespac valu null ns null els if namespac valu instanceof namespac ns namespac namespac valu els ns construct namespac cx namespac valu if ns null uri null els uri ns uri return xmlname form properti uri local name 
public ref name ref context cx object name scriptabl scope int member type flag if member type flag node attribut flag 0 should onli be call foir case like name or expr throw kit code bug xmlname xml name to attribut name cx name return xml primari refer cx xml name scope 
public ref name ref context cx object namespac object name scriptabl scope int member type flag xmlname xml name to qualifi name cx namespac name if member type flag node attribut flag 0 if xml name is attribut name xml name set attribut name return xml primari refer cx xml name scope 
privat ref xml primari refer context cx xmlname xml name scriptabl scope xmlobject impl xml obj xmlobject impl first xml object null for xml object can onli present on scope chain as a wrapper of xmlwith scope if scope instanceof xmlwith scope xml obj xmlobject impl scope get prototyp if xml obj ha xmlproperti xml name break if first xml object null first xml object xml obj scope scope get parent scope if scope null xml obj first xml object break xml obj null correspond to undefin as the target of the refer if xml obj null xml name init xmlobject xml obj return xml name 
escap the reserv charact in a valu of an attribut and surround it by param valu unescap text return the escap text public string escap attribut valu object valu string text script runtim to string valu if text length 0 return xml object xo xml object factori new instanc xml cursor cursor xo new cursor cursor to next token cursor begin element a cursor insert attribut with valu a text cursor dispos string element text xo to string int begin element text index of int end element text last index of return element text substr begin end 1 
escap the reserv charact in a valu of a text node param valu unescap text return the escap text public string escap text valu object valu if valu instanceof xmlobject impl return xmlobject impl valu to xmlstring 0 string text script runtim to string valu if text length 0 return text xml object xo xml object factori new instanc xml cursor cursor xo new cursor cursor to next token cursor begin element a cursor insert char text cursor dispos string element text xo to string int begin element text index of 1 int end element text last index of return begin end element text substr begin end 
public object to default xml namespac context cx object uri valu return construct namespac cx uri valu 
creat a new main public main string titl dim new dim debug gui new swing gui dim titl 
return the debugg window link jframe public jframe get debug frame return debug gui 
break execut of the script public void do break dim set break 
set whether execut should break when a script except is thrown public void set break on except boolean valu dim set break on except valu debug gui get menubar get break on except set select valu 
set whether execut should break when a function is enter public void set break on enter boolean valu dim set break on enter valu debug gui get menubar get break on enter set select valu 
set whether execut should break when a function is left public void set break on return boolean valu dim set break on return valu debug gui get menubar get break on return set select valu 
remov all breakpoint public void clear all breakpoint dim clear all breakpoint 
resum execut of the script public void go dim go 
set the scope to be us for script evalu public void set scope scriptabl scope set scope provid iproxi new scope provid scope 
set the link scope provid that provid a scope to be us for script evalu public void set scope provid scope provid p dim set scope provid p 
assign a runnabl object that will be invok when the user select exit or close the debugg main window public void set exit action runnabl r debug gui set exit action r 
return an link input stream for stdin from the debugg s intern consol window public input stream get in return debug gui get consol get in 
return a link print stream for stdout to the debugg s intern consol window public print stream get out return debug gui get consol get out 
return a link print stream for stderr in the debugg s intern consol window public print stream get err return debug gui get consol get err 
pack the debugg gui frame public void pack debug gui pack 
set the debugg gui frame dimens public void set size int w int h debug gui set size w h 
set the visibl of the debugg gui frame public void set visibl boolean flag debug gui set visibl flag 
return whether the debugg gui frame is visibl public boolean is visibl return debug gui is visibl 
free ani resourc held by the debugg public void dispos clear all breakpoint dim go debug gui dispos dim null 
attach the debugg to the given link context factori public void attach to context factori factori dim attach to factori 
detach from the current link context factori public void detach dim detach 
main entri point creat a debugg attach to a rhino link org mozilla tool shell main shell session public static void main string arg main main new main rhino java script debugg main do break main set exit action new iproxi iproxi exit action system set in main get in system set out main get out system set err main get err global global org mozilla javascript tool shell main get global global set in main get in global set out main get out global set err main get err main attach to org mozilla javascript tool shell main shell context factori main set scope global main pack main set size 600 460 main set visibl true org mozilla javascript tool shell main exec arg 
entri point for embed applic thi method attach to the global link context factori with a scope of a newli creat link global object no i o redirect is perform as with link main string public static void main embed string titl context factori factori context factori get global global global new global global init factori main embed factori global titl 
entri point for embed applic thi method attach to the given link context factori with the given scope no i o redirect is perform as with link main string public static void main embed context factori factori scriptabl scope string titl main embed impl factori scope titl 
entri point for embed applic thi method attach to the given link context factori with the given scope no i o redirect is perform as with link main string public static void main embed context factori factori scope provid scope provid string titl main embed impl factori scope provid titl 
helper method for link main embed privat static void main embed impl context factori factori object scope provid string titl if titl null titl rhino java script debugg embed usag main main new main titl main do break main set exit action new iproxi iproxi exit action main attach to factori if scope provid instanceof scope provid main set scope provid scope provid scope provid els scriptabl scope scriptabl scope provid if scope instanceof global global global global scope global set in main get in global set out main get out global set err main get err main set scope scope main pack main set size 600 460 main set visibl true 
deprec us link set size int int instead public void set size java awt dimens dimens debug gui set size dimens width dimens height 
deprec the method doe noth and is onli present for compat public void set optim level int level 
deprec the method is onli present for compat and should not be call public void context enter context cx throw new illeg state except 
deprec the method is onli present for compat and should not be call public void context exit context cx throw new illeg state except 
deprec the method is onli present for compat and should not be call public void context creat context cx throw new illeg state except 
deprec the method is onli present for compat and should not be call public void context releas context cx throw new illeg state except 
creat a new iproxi public iproxi int type thi type type 
creat a new iproxi that act as a link scope provid public static scope provid new scope provid scriptabl scope iproxi scope provid new iproxi scope provid scope provid scope scope return scope provid 
exit action public void run if type exit action kit code bug system exit 0 
return the scope for script evalu public scriptabl get scope if type scope provid kit code bug if scope null kit code bug return scope 
privat interpret function interpret data idata object static secur domain thi idata idata alwai get context from the current thread to avoid secur breach via pass mangl context instanc with bogu secur control context cx context get context secur control sc cx get secur control object dynam domain if sc null dynam domain sc get dynam secur domain static secur domain els if static secur domain null throw new illeg argument except dynam domain null thi secur control sc thi secur domain dynam domain 
privat interpret function interpret function parent int index thi idata parent idata it nest function index thi secur control parent secur control thi secur domain parent secur domain 
creat script from compil bytecod static interpret function creat script interpret data idata object static secur domain interpret function f f new interpret function idata static secur domain return f 
creat function compil from function constructor static interpret function creat function context cx scriptabl scope interpret data idata object static secur domain interpret function f f new interpret function idata static secur domain f init interpret function cx scope return f 
creat function embed in script or anoth function static interpret function creat function context cx scriptabl scope interpret function parent int index interpret function f new interpret function parent index f init interpret function cx scope return f 
scriptabl creat reg exp wrap context cx scriptabl scope if idata it reg exp liter null kit code bug reg exp proxi rep script runtim check reg exp proxi cx int n idata it reg exp liter length scriptabl arrai new scriptabl n for int i 0 i n i arrai i rep wrap reg exp cx scope idata it reg exp liter i return arrai 
privat void init interpret function context cx scriptabl scope init script function cx scope if idata it reg exp liter null function reg exp creat reg exp wrap cx scope 
public string get function name return idata it name null idata it name 
call the function param cx the current context param scope the scope us for the call param the valu of thi param function argument must not be null you can us link script runtim empti arg to pass empti argument return the result of the function call public object call context cx scriptabl scope scriptabl thi obj object arg if script runtim ha top call cx return script runtim do top call thi cx scope thi obj arg return interpret interpret thi cx scope thi obj arg 
public object exec context cx scriptabl scope if idata it function type 0 can onli be appli to script throw new illeg state except if script runtim ha top call cx it will go through call path but thei ar equival return script runtim do top call thi cx scope scope script runtim empti arg return interpret interpret thi cx scope scope script runtim empti arg 
public string get encod sourc return interpret get encod sourc idata 
public debugg script get debugg view return idata 
protect int get languag version return idata languag version 
protect int get param count return idata arg count 
protect int get param and var count return idata arg name length 
protect string get param or var name int index return idata arg name index 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string expect return byte 
public static string name int token if print name return string valu of token switch token case error return error case eof return eof case eol return eol case enterwith return enterwith case leavewith return leavewith case return return return case goto return goto case ifeq return ifeq case ifn return ifn case setnam return setnam case bitor return bitor case bitxor return bitxor case bitand return bitand case eq return eq case ne return ne case lt return lt case le return le case gt return gt case ge return ge case lsh return lsh case rsh return rsh case ursh return ursh case add return add case sub return sub case mul return mul case div return div case mod return mod case not return not case bitnot return bitnot case po return po case neg return neg case new return new case delprop return delprop case typeof return typeof case getprop return getprop case setprop return setprop case getelem return getelem case setelem return setelem case call return call case name return name case number return number case string return string case null return null case thi return thi case fals return fals case true return true case sheq return sheq case shne return shne case regexp return object case bindnam return bindnam case throw return throw case rethrow return rethrow case in return in case instanceof return instanceof case local load return local load case getvar return getvar case setvar return setvar case catch scope return catch scope case enum init kei return enum init kei case enum init valu return enum init valu case enum next return enum next case enum id return enum id case thisfn return thisfn case return result return return result case arraylit return arraylit case objectlit return objectlit case get ref return get ref case set ref return set ref case del ref return del ref case ref call return ref call case ref special return ref special case defaultnamespac return defaultnamespac case escxmltext return escxmltext case escxmlattr return escxmlattr case ref member return ref member case ref ns member return ref ns member case ref name return ref name case ref ns name return ref ns name case try return try case semi return semi case lb return lb case rb return rb case lc return lc case rc return rc case lp return lp case rp return rp case comma return comma case assign return assign case assign bitor return assign bitor case assign bitxor return assign bitxor case assign bitand return assign bitand case assign lsh return assign lsh case assign rsh return assign rsh case assign ursh return assign ursh case assign add return assign add case assign sub return assign sub case assign mul return assign mul case assign div return assign div case assign mod return assign mod case hook return hook case colon return colon case or return or case and return and case inc return inc case dec return dec case dot return dot case function return function case export return export case import return import case if return if case els return els case switch return switch case case return case case default return default case while return while case do return do case for return for case break return break case continu return continu case var return var case with return with case catch return catch case final return final case reserv return reserv case empti return empti case block return block case label return label case target return target case loop return loop case expr void return expr void case expr result return expr result case jsr return jsr case script return script case typeofnam return typeofnam case us stack return us stack case setprop op return setprop op case setelem op return setelem op case local block return local block case set ref op return set ref op case dotdot return dotdot case coloncolon return coloncolon case xml return xml case dotqueri return dotqueri case xmlattr return xmlattr case xmlend return xmlend case to object return to object case to doubl return to doubl token without name throw new illeg state except string valu of token 
string suffix public live nav drv super set suffix java 
public static void main string arg system out println main live nav drv d new live nav drv d start 
iter through suit for each file in each suit creat a live nav env in thi case a navig window that can load and evalu the test result see live nav env pars result public synchron void execut suit test suit suit privileg manag enabl privileg univers file access privileg manag enabl privileg univers file read privileg manag enabl privileg univers file write privileg manag enabl privileg univers properti read live nav env context test file file for int i 0 i suit size i synchron suit file test file suit element at i context new live nav env file suit thi context run test write file result file suit output directori write case result file suit output directori context close context null if file pass suit pass fals write suit result suit output directori write suit summari suit output directori 
privat hashtabl thread with context new hashtabl protect object get thread context helper return thread current thread 
protect context get context object context helper thread t thread context helper return context thread with context get t 
protect void set context object context helper context cx thread t thread context helper if cx null allow to garbag collect thread refer thread with context remov t els thread with context put t cx 
protect class loader get current thread class loader return null 
protect boolean try to make access object access object return fals 
the zero paramet constructor when context defin class is call with thi class it will construct foo prototyp us thi constructor public foo 
the java method defin the java script foo constructor take an initi valu for the counter properti note that in the exampl shell session abov we didn t suppli a argument to the foo constructor thi mean that the undefin valu is us as the valu of the argument and when the argument is convert to an integ undefin becom 0 public foo int counter start counter counter start 
return the name of thi java script class foo public string get class name return foo 
the java method defin the java script reset counter function reset the counter to 0 public void js function reset counter counter 0 
the java method implement the getter for the counter properti p if set counter had been defin in thi class the runtim would call the setter when the properti is assign to public int js get counter return counter 
an exampl of a variabl argument method all variabl argument method must have the same number and type of paramet and must be static p param cx the context of the current thread param thi obj the java script thi valu param arg the arrai of argument for thi call param fun obj the function object of the invok java script function thi valu is us to comput a scope us context get top level scope return comput the string valu and type of thi and of each of the suppli argument and return them in a string except thread associ except if the current thread is not associ with a context see org mozilla javascript scriptabl object get top level scope public static object js function vararg context cx scriptabl thi obj object arg function fun obj string buffer buf new string buffer buf append thi buf append context to string thi obj buf append arg for int i 0 i arg length i buf append context to string arg i if i 1 arg length buf append buf append return buf to string 
public namespac xmllib impl lib string uri super lib global scope lib namespac prototyp if uri null throw new illeg argument except thi lib lib thi prefix uri length 0 null thi uri uri 
public namespac xmllib impl lib string prefix string uri super lib global scope lib namespac prototyp if uri null throw new illeg argument except if uri length 0 prefix should be for empti uri if prefix null throw new illeg argument except if prefix length 0 throw new illeg argument except thi lib lib thi prefix prefix thi uri uri 
public void export as jsclass boolean seal export as jsclass max prototyp id lib global scope seal 
return public string uri return uri 
return public string prefix return prefix 
return public string to string return uri 
return public string to local string return to string 
public boolean equal object obj if obj instanceof namespac return fals return equal namespac obj 
protect object equival valu object valu if valu instanceof namespac return scriptabl not found boolean result equal namespac valu return result boolean true boolean fals 
privat boolean equal namespac n return uri equal n uri 
return public string get class name return namespac 
param hint return public object get default valu class hint return uri 
max instanc id 2 protect int get max instanc id return super get max instanc id max instanc id 
protect int find instanc id info string s int id gener last updat 2004 07 20 19 50 50 cest l0 id 0 string x null int s length s length if s length 3 x uri id id uri els if s length 6 x prefix id id prefix if x null x s x equal s id 0 gener if id 0 return super find instanc id info s int attr switch id case id prefix case id uri attr perman readonli break default throw new illeg state except return instanc id info attr super get max instanc id id 
protect string get instanc id name int id switch id super get max instanc id case id prefix return prefix case id uri return uri return super get instanc id name id 
protect object get instanc id valu int id switch id super get max instanc id case id prefix if prefix null return undefin instanc return prefix case id uri return uri return super get instanc id valu id 
protect int find prototyp id string s int id gener last updat 2004 08 21 12 07 01 cest l0 id 0 string x null int c int s length s length if s length 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string els if s length 11 x constructor id id constructor if x null x s x equal s id 0 gener return id 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 2 s constructor break case id to string ariti 0 s to string break case id to sourc ariti 0 s to sourc break default throw new illeg argument except string valu of id init prototyp method namespac tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag namespac tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor return js constructor cx thi obj null arg case id to string return real thi thi obj f to string case id to sourc return real thi thi obj f js to sourc throw new illeg argument except string valu of id 
privat namespac real thi scriptabl thi obj id function object f if thi obj instanceof namespac throw incompat call error f return namespac thi obj 
privat object js constructor context cx boolean in new expr object arg if in new expr arg length 1 return lib cast to namespac cx arg 0 if arg length 0 return lib construct namespac cx els if arg length 1 return lib construct namespac cx arg 0 els return lib construct namespac cx arg 0 arg 1 
privat string js to sourc string buffer sb new string buffer sb append to sourc impl prefix uri sb sb append return sb to string 
static void to sourc impl string prefix string uri string buffer sb sb append new namespac if uri length 0 if equal prefix throw new illeg argument except prefix els sb append if prefix null sb append script runtim escap string prefix sb append sb append script runtim escap string uri sb append sb append 
static final long serial version uid 8221564865490676219l public properti except string detail super detail 
xscript annot xml cursor cur name cur get name 
namespac declar xml cursor cur prefix idx 0 namespac decl new string buffer skip non element cur default nsuri cur namespac for prefix if is ani default namespac add decl default nsuri 
privat void add decl string prefix string ns namespac decl append prefix length 0 declar namespac prefix default element namespac ns n 
string get next prefix string ns string prefix ns prefix idx namespac decl append declar namespac prefix ns n return prefix 
boolean is ani default namespac return default nsuri null default nsuri length 0 fals 
string get declar return namespac decl to string 
param anno privat xml xmllib impl lib xscript annot anno super lib lib xml prototyp anno anno anno x script xml thi 
static xml creat empti xml xmllib impl lib xscript annot anno xml object xo xml object factori new instanc xml cursor cur xo new cursor try anno new xscript annot cur cur set bookmark anno final cur dispos return new xml lib anno 
privat static xml creat xml xmllib impl lib xml cursor cur if cur current token type is startdoc cur to first content token xscript annot anno find annot cur return new xml lib anno 
special constructor for make an attribut privat static xml creat attribut xml xmllib impl lib xml cursor cursor if cursor is attr throw new illeg argument except xscript annot anno new xscript annot cursor cursor set bookmark anno return new xml lib anno 
param qname param valu return static xml creat text element xmllib impl lib javax xml namespac qname qname string valu xscript annot anno xml object xo xml object factori new instanc xml cursor cursor xo new cursor try cursor to next token cursor begin element qname get local part qname get namespac uri if namespac length 0 cursor insert namespac namespac cursor insert char valu cursor to start doc cursor to next token anno new xscript annot cursor cursor set bookmark anno final cursor dispos return new xml lib anno 
static xml creat from xml object xmllib impl lib xml object xo xscript annot anno xml cursor cur xo new cursor if cur current token type is startdoc cur to first content token try anno new xscript annot cur cur set bookmark anno final cur dispos return new xml lib anno 
static xml creat from js xmllib impl lib object input object xml object xo boolean is text fals string frag if input object null input object undefin instanc frag els if input object instanceof xmlobject impl todo faster wai for xmlobject frag xmlobject impl input object to xmlstring 0 els if input object instanceof wrapper object wrap wrapper input object unwrap if wrap instanceof xml object return creat from xml object lib xml object wrap frag script runtim to string input object if frag trim start with throw script runtim type error invalid us of xml object anonym tag if frag index of 1 must be solo text node wrap in xml fragment is text true frag text fragment frag text fragment xml option option new xml option if lib ignor comment option put xml option load strip comment if lib ignor process instruct option put xml option load strip procinst if lib ignor whitespac option put xml option load strip whitespac try xo xml object factori pars frag option appli the default namespac context cx context get current context string default uri lib get default namespac uri cx if default uri length 0 xml cursor cursor xo new cursor boolean is root true while cursor to next token is enddoc if cursor is start continu check if thi element explicitli set the default namespac boolean default nsdeclar fals cursor push while cursor to next token is ani attr if cursor is namespac if cursor get name get local part length 0 default nsdeclar true break cursor pop if default nsdeclar cursor to end token continu check if thi element s name is in no namespac javax xml namespac qname qname cursor get name if qname get namespac uri length 0 chang the namespac qname new javax xml namespac qname default uri qname get local part cursor set name qname if is root declar the default namespac cursor push cursor to next token cursor insert namespac default uri cursor pop is root fals cursor dispos catch xml except xe todo need to handl namespac prefix not found in xml look for namespac type in the scope chang string error msg us of undefin namespac prefix string msg xe get error get messag if msg start with error msg string prefix msg substr error msg length string err msg xe get messag if err msg equal error unexpect end of file after null creat an empti document xo xml object factori new instanc els throw script runtim type error xe get messag catch throwabl e todo tll catch specif except dure pars throw script runtim type error not parsabl as xml xml cursor cur xo new cursor if cur current token type is startdoc cur to first content token if is text move it to point to the text node cur to first content token xscript annot anno try anno new xscript annot cur cur set bookmark anno final cur dispos return new xml lib anno 
static xml get from annot xmllib impl lib xscript annot anno if anno x script xml null anno x script xml new xml lib anno return anno x script xml 
param cur return privat static token type skip non element xml cursor cur token type tt cur current token type while tt is comment tt is procinst tt cur to next token return tt 
param cur return protect static xscript annot find annot xml cursor cur xml bookmark anno cur get bookmark xscript annot class if anno null anno new xscript annot cur cur set bookmark anno return xscript annot anno 
return privat xml option get option xml option option new xml option if lib ignor comment option put xml option load strip comment if lib ignor process instruct option put xml option load strip procinst if lib ignor whitespac option put xml option load strip whitespac if lib pretti print option put xml option save pretti print null option put xml option save pretti print indent new integ lib pretti indent return option 
param cursor param opt return privat static string dump node xml cursor cursor xml option opt if cursor is text return cursor get char if cursor is finish return cursor push boolean wan raw text cursor is startdoc cursor to first child cursor pop return wan raw text cursor get text valu cursor xml text opt 
return privat xml cursor new cursor xml cursor cur if anno null cur anno creat cursor if cur null orphan case xml object doc xml object factori new instanc cur doc new cursor if anno name null cur to next token cur insert element anno name cur to prev sibl cur set bookmark anno els xml object doc xml object factori new instanc cur doc new cursor return cur 
privat boolean move to child xml cursor cur long index boolean f first child boolean f us start doc if index 0 throw new illeg argument except long idx child 0 if f us start doc cur current token type is startdoc we alwai move to the children of the top node todo thi assum that we want have multipl top level node which we should be abl tohav cur to first content token token type tt cur to first content token if tt is none tt is end while true if index idx child return true tt cur current token type if tt is text cur to next token els if tt is start need to do thi we want to be point at the text if that after the end token cur to end token cur to next token els if tt is comment tt is procinst continu els break idx child els if f first child index 0 drill into where first child would be cur to first content token return true return fals 
return xml cursor token type token type xml cursor token type result xml cursor cur new cursor if cur is startdoc cur to first content token result cur current token type cur dispos return result 
param src cur param dest cur param f dont move if same return privat boolean move src to dest xml cursor src cur xml cursor dest cur boolean f dont move if same boolean f move someth true token type tt do if f dont move if same src cur is in same document dest cur src cur compar posit dest cur 0 if the sourc and destin ar point at the same place then there s noth to move f move someth fals break todo tll us replac content when ad and elimin children remov see abov todo if dest cur current token type is startdoc dest cur to next token todo tll can eric support notion of copi instead of me copi then move xml cursor copi cur copi src cur copi cur move xml dest cur copi cur dispos tt src cur current token type while tt is start tt is end tt is enddoc return f move someth 
param cur to copi return privat xml cursor copi xml cursor cur to copi xml object xo xml object factori new instanc xml cursor copi cur null if cur to copi current token type is text try try just as a textnod to do that we need to wrap the text in a special fragment tag that is not visibl from the xml cursor copi cur xml object factori pars x fragment xmln x http www openuri org fragment cur to copi get char x fragment new cursor if cur to copi to next sibl if cur to copi current token type is text cur to copi to next token it s not an element it s text so skip it catch except ex throw script runtim type error ex get messag els copi cur xo new cursor copi cur to first content token if cur to copi current token type xml cursor token type startdoc cur to copi to next token cur to copi copi xml copi cur if cur to copi to next sibl if element skip element if cur to copi current token type is text cur to copi to next token it s not an element it s text so skip it copi cur to start doc copi cur to first content token return copi cur 
param cur param xml to insert privat void insert child xml cursor cur object xml to insert if xml to insert null xml to insert instanceof undefin do noth els if xml to insert instanceof xml cursor move src to dest xml cursor xml to insert cur true els if xml to insert instanceof xml xml xml valu xml xml to insert if it s an attribut then chang to text node if xml valu token type xml cursor token type attr insert child cur xml valu to string els xml cursor cur to insert xml xml to insert new cursor move src to dest cur to insert cur true cur to insert dispos els if xml to insert instanceof xmllist xmllist list xmllist xml to insert for int i 0 i list length i insert child cur list item i els convert to string and make xml out of it string xml str script runtim to string xml to insert xml object xo xml object factori new instanc creat an empti document xml cursor sourc cur xo new cursor sourc cur to next token to hold the text sourc cur insert char xml str sourc cur to prev token call us again with the cursor move src to dest sourc cur cur true 
param child to match param xml to insert param add to type privat void insert child xml child to match object xml to insert int add to type xml cursor cur new cursor token type tt cur current token type xml cursor xml child cursor child to match new cursor if tt is startdoc tt cur to first content token if tt is contain tt cur to next token while tt is end if tt is start see if thi child is the same as the on thep pass in if cur compar posit xml child cursor 0 found it if add to type append child move the cursor to just past the end of thi element cur to end token cur to next token insert child cur xml to insert break skip over child element if tt is start tt cur to end token tt cur to next token xml child cursor dispos cur dispos 
param cur protect void remov token xml cursor cur xml object xo xml object factori new instanc don t delet anyth move to anoth document so it get orphan nice xml cursor tmp cur xo new cursor tmp cur to first content token cur move xml tmp cur tmp cur dispos 
param index protect void remov child long index xml cursor cur new cursor if move to child cur index fals fals remov token cur cur dispos 
param name return protect static javax xml namespac qname comput qname object name if name instanceof string string ns null string local name null string full name string name local name full name if full name start with int idx full name index of if idx 1 ns full name substr 1 idx 1 don t includ the around the namespac local name full name substr idx 1 if ns null return new javax xml namespac qname local name els return new javax xml namespac qname ns local name return null 
param dest cur param new valu privat void replac xml cursor dest cur xml new valu if dest cur is startdoc can t overwrit a whole document user realli want to overwrit the content of dest cur to first content token orphan the token don t delet it outright on the xml cursor remov token dest cur xml cursor src cur new valu new cursor if src cur current token type is startdoc cann t append a whole document user realli want to append the content of src cur to first content token move src to dest src cur dest cur fals re link a new annot to thi cursor we just delet the previou annot on entranc to replac if dest cur to prev sibl dest cur to prev token dest cur set bookmark new xscript annot dest cur todo would be nice if dest cur to next sibl went to where the next token if the cursor wa point at the last token in the stream dest cur to end token dest cur to next token src cur dispos 
param curr xmlnode param xml valu return privat boolean do put xmlname name xml curr xmlnode xmlobject impl xml valu boolean result fals xml cursor cur curr xmlnode new cursor try replac the node with thi new xml valu xml xml int to assign len xml valu length for int i 0 i to assign len i if xml valu instanceof xmllist xml xml xmllist xml valu item i els xml xml xml valu if it s an attribut or text node make text node xml cursor token type tt xml token type if tt xml cursor token type attr tt xml cursor token type text xml make xml from string lib name xml to string if i 0 1st assign is replac child all other ar append child replac cur xml els insert child cur xml we re done we ve blown awai the node becaus the rvalu wa xml result true catch except ex ex print stack trace throw script runtim type error ex get messag final cur dispos return result 
make a text node element with thi element name and text valu param name param valu return privat xml make xml from string xmllib impl lib xmlname name string valu xml result javax xml namespac qname qname try qname new javax xml namespac qname name uri name local name catch except e throw script runtim type error e get messag result creat text element lib qname valu to string return result 
param name return privat xmllist match attribut xmlname xml name xmllist result new xmllist lib xml cursor cur new cursor if cur current token type is startdoc cur to first content token if cur is start if cur to first attribut do if qname match xml name cur get name result add to list creat attribut object cur while cur to next attribut cur dispos return result 
param attr cur return privat xml creat attribut object xml cursor attr cur xml result null if attr cur current token type is attr result creat attribut xml lib attr cur return result 
public string get class name return xml 
xml 0 should return thi all other index ar undefin param index param start return public object get int index scriptabl start log get index index if index 0 return thi els return scriptabl not found 
doe the name properti exist param name param start return boolean ha xmlproperti xmlname xml name boolean result fals if prototyp flag string name xml name local name if get method name not found result true els ha now should return true if the properti would have result 0 or if it s a method name string name xml name local name if get properti list xml name length 0 get method name not found result true return result 
param index param start return public boolean ha int index scriptabl start return index 0 
return public object get id object enum obj if prototyp flag enum obj new object 0 els enum obj new object 1 enum obj 0 new integ 0 return enum obj 
return public object get id for debug return get id 
param name param start return object get xmlproperti xmlname xml name object result not found if prototyp flag string name xml name local name result get method name els result get properti list xml name return result 
param name param start param valu void put xmlproperti xmlname xml name object valu log put properti name valu valu get class if prototyp flag els special case check for undefin and null if valu null valu null els if valu instanceof undefin valu undefin get the name properti if xml name is attribut name set attribut xml name valu els if xml name uri null xml name local name equal set children valu els convert text into xml if need xmlobject impl xml valu null if valu instanceof xmlobject impl xml valu xmlobject impl valu check for attribut type and convert to text node if xml valu instanceof xml if xml xml valu token type xml cursor token type attr xml valu make xml from string lib xml name xml valu to string if xml valu instanceof xmllist for int i 0 i xml valu length i xml xml xml xmllist xml valu item i if xml token type xml cursor token type attr xmllist xml valu replac i make xml from string lib xml name xml to string els xml valu make xml from string lib xml name script runtim to string valu xmllist match xmllist get properti list xml name if match length 0 append child xml valu els remov all other match for int i 1 i match length i remov child match item i child index replac first match with new valu do put xml name xml match item 0 xml valu 
param index param start param valu public void put int index scriptabl start object valu spec sai assign to index xml object should return type error throw script runtim type error assign to index xml is not allow 
param name void delet xmlproperti xmlname name if name is descend name is attribut name xml cursor cur new cursor todo cover the case name if name local name equal delet all attribut if cur to first attribut while cur current token type is attr cur remov xml els delet an attribut javax xml namespac qname qname new javax xml namespac qname name uri name local name cur remov attribut qname cur dispos els xmllist match xmllist get properti list name match remov 
param index public void delet int index if index 0 remov 
protect xscript annot get annot return anno 
protect void chang ns string old uri string new uri xml cursor cur new cursor while cur to parent goto the top of the document token type tt cur current token type if tt is startdoc tt cur to first content token if tt is start do if tt is start tt is attr tt is namespac javax xml namespac qname curr qname cur get name if old uri equal curr qname get namespac uri cur set name new javax xml namespac qname new uri curr qname get local part tt cur to next token while tt is enddoc tt is none cur dispos 
void remov xml cursor child cur new cursor if child cur current token type is startdoc remov on the document remov all children token type tt child cur to first content token while tt is end tt is enddoc remov token child cur tt child cur current token type now see where we re point after the delet next token els remov token child cur child cur dispos 
param valu void replac all xml valu xml cursor cur new cursor replac cur valu anno valu anno cur dispos 
param attr name param valu void set attribut xmlname xml name object valu if xml name uri null xml name local name equal throw script runtim type error assign not support xml cursor cur new cursor string str valu script runtim to string valu if cur current token type is startdoc cur to first content token javax xml namespac qname q name try q name new javax xml namespac qname xml name uri xml name local name catch except e throw script runtim type error e get messag if cur set attribut text q name str valu if cur current token type is start can onli add attribut insid of a start cur to next token cur insert attribut with valu q name str valu cur dispos 
param namespac return privat xmllist all child node string namespac xmllist result new xmllist lib xml cursor cur new cursor token type tt cur current token type javax xml namespac qname target properti new javax xml namespac qname namespac if tt is startdoc tt cur to first content token if tt is contain tt cur to first content token while tt is end if tt is start not an element result add to list find annot cur reset target properti to null in thi case target properti null els match namespac as well if specifi if namespac null namespac length 0 namespac equal cur get name get namespac uri equal namespac add it to the list result add to list find annot cur set target properti if target name is otherwis if target properti doe not match current then set to null if target properti null if target properti get local part equal target properti cur get name els if target properti get local part equal cur get name get local part not a match unset target properti target properti null skip over child element if tt is start tt cur to end token tt cur to next token cur dispos set the target for thi xmllist result set target thi target properti return result 
return privat xmllist match descend attribut xmlname xml name xmllist result new xmllist lib xml cursor cur new cursor token type tt cur current token type set the target for thi xmllist result set target thi null if tt is startdoc tt cur to first content token if tt is contain int nest level 1 while nest level 0 tt cur to next token onli try to match name for attribut if tt is attr if qname match xml name cur get name result add to list find annot cur if tt is start nest level els if tt is end nest level els if tt is enddoc shouldn t get here but just in case break cur dispos return result 
return privat xmllist match descend children xmlname xml name xmllist result new xmllist lib xml cursor cur new cursor token type tt cur current token type set the target for thi xmllist result set target thi null if tt is startdoc tt cur to first content token if tt is contain int nest level 1 while nest level 0 tt cur to next token if tt is attr tt is end tt is enddoc onli try to match name for element or process instruct if tt is start tt is procinst not an element or procinst onli add if qname is all if xml name local name equal result add to list find annot cur els if qname match xml name cur get name result add to list find annot cur if tt is start nest level els if tt is end nest level els if tt is enddoc shouldn t get here but just in case break cur dispos return result 
param token type return privat xmllist match children xml cursor token type token type return match children token type xmlname form star 
return privat xmllist match children xml cursor token type token type xmlname name xmllist result new xmllist lib xml cursor cur new cursor token type tt cur current token type javax xml namespac qname qname new javax xml namespac qname name uri name local name javax xml namespac qname target properti qname if tt is startdoc tt cur to first content token if tt is contain tt cur to first content token while tt is end if tt token type onli try to match name for element or process instruct if tt is start tt is procinst not an element or no name specifi result add to list find annot cur reset target properti to null in thi case target properti null els match name as well if qname match name cur get name add it to the list result add to list find annot cur set target properti if target name is otherwis if target properti doe not match current then set to null if target properti null if target properti get local part equal target properti cur get name els if target properti get local part equal cur get name get local part not a match unset target properti target properti null skip over child element if tt is start tt cur to end token tt cur to next token cur dispos if token type xml cursor token type start set the target for thi xmllist result set target thi target properti return result 
param templat param match return privat boolean qname match xmlname templat javax xml namespac qname match boolean match fals if templat uri null templat uri equal match get namespac uri uri ok test name if templat local name equal templat local name equal match get local part match true return match 
the add namespac method add a namespac declar to the in scope namespac for thi xml object and return thi xml object param to add xml add namespac namespac ns when a namespac is us it will be ad automat to the in scope namespac set there is no need to add namespac with undefin prefix string ns prefix ns prefix if ns prefix null return thi xml cursor cursor new cursor try if cursor is contain return thi javax xml namespac qname qname cursor get name don t add a default namespac declar to contain with qname in no namespac if qname get namespac uri equal ns prefix equal return thi get all declar namespac that ar in scope map prefix to uri namespac helper get all namespac lib cursor string uri string prefix to uri get ns prefix if uri null check if the namespac is not alreadi in scope if uri equal ns uri return thi cursor push let s see if we have to delet a namespac declar while cursor to next token is ani attr if cursor is namespac qname cursor get name string prefix qname get local part if prefix equal ns prefix delet the current namespac declar cursor remov xml break cursor pop cursor to next token cursor insert namespac ns prefix ns uri final cursor dispos return thi 
param xml return xml append child object xml xml cursor cur new cursor if cur is startdoc cur to first content token move the cursor to the end of thi element if cur is start cur to end token insert child cur xml cur dispos return thi 
param name return xmllist attribut xmlname xml name return match attribut xml name 
return xmllist attribut xmlname xml name xmlname form star return match attribut xml name 
xmllist child long index xmllist result new xmllist lib result set target thi null result add to list get xml child index return result 
xmllist child xmlname xml name if xml name null return new xmllist lib xmllist result if xml name local name equal result all child node xml name uri els result match children xml cursor token type start xml name return result 
param index return xml get xml child long index xml result null xml cursor cur new cursor if move to child cur index fals true result creat xml lib cur cur dispos return result 
return int child index int index 0 xml cursor cur new cursor token type tt cur current token type while true if tt is text index if cur to prev sibl break els if tt is start tt cur to prev token if tt is end cur to next token if cur to prev sibl break index els hit the parent start tag so get out we re down count children break els if tt is comment tt is procinst cur to prev token els break tt cur current token type index cur current token type is startdoc 1 index cur dispos return index 
return xmllist children return all child node null 
return xmllist comment return match children xml cursor token type comment 
param xml return boolean contain object xml boolean result fals if xml instanceof xml result equival xml xml return result 
return object copi xml cursor src cur new cursor if src cur is startdoc src cur to first content token xml xml creat empti xml lib xml cursor dest cur xml new cursor dest cur to first content token src cur copi xml dest cur dest cur dispos src cur dispos return xml 
param name return xmllist descend xmlname xml name xmllist result if xml name is attribut name result match descend attribut xml name els result match descend children xml name return result 
the in scope namespac method return an arrai of namespac object repres the namespac in scope for thi xml object in the context of it parent return arrai of all namespac in scope for thi xml object object in scope namespac xml cursor cursor new cursor object namespac namespac helper in scope namespac lib cursor cursor dispos return namespac 
param child param xml xml insert child after object child object xml if child null spec sai insert after noth is the same as prepend prepend child xml els if child instanceof xml insert child xml child xml append child return thi 
param child param xml xml insert child befor object child object xml if child null spec sai insert befor noth is the same as append append child xml els if child instanceof xml insert child xml child xml prepend child return thi 
return boolean ha own properti xmlname xml name boolean ha properti fals if prototyp flag string properti xml name local name ha properti 0 find prototyp id properti els ha properti get properti list xml name length 0 return ha properti 
return boolean ha complex content return ha simpl content 
return boolean ha simpl content boolean simpl content fals xml cursor cur new cursor if cur is attr cur is text return true if cur is startdoc cur to first content token simpl content cur to first child cur dispos return simpl content 
length of an xml object is alwai 1 it s a list of xml object of size 1 return int length return 1 
return string local name xml cursor cursor new cursor if cursor is startdoc cursor to first content token string name null if cursor is start cursor is attr cursor is procinst javax xml namespac qname qname cursor get name name qname get local part cursor dispos return name 
the name method return the qualifi name associ with thi xml object return the qualifi name associ with thi xml object qname name xml cursor cursor new cursor if cursor is startdoc cursor to first content token qname name null if cursor is start cursor is attr cursor is procinst javax xml namespac qname qname cursor get name if cursor is procinst name new qname lib qname get local part els string uri qname get namespac uri string prefix qname get prefix name new qname lib uri qname get local part prefix cursor dispos return name 
param prefix return object namespac string prefix xml cursor cursor new cursor if cursor is startdoc cursor to first content token object result null if prefix null if cursor is start cursor is attr object in scope ns namespac helper in scope namespac lib cursor xxx is it reaali necessari to creat the second cursor xml cursor cursor2 new cursor if cursor2 is startdoc cursor2 to first content token result namespac helper get namespac lib cursor2 in scope ns cursor2 dispos els map prefix to uri namespac helper get all namespac lib cursor string uri string prefix to uri get prefix result uri null undefin instanc new namespac lib prefix uri cursor dispos return result 
return object namespac declar xml cursor cursor new cursor object namespac namespac helper namespac declar lib cursor cursor dispos return namespac 
return object node kind string result xml cursor token type tt token type if tt xml cursor token type attr result attribut els if tt xml cursor token type text result text els if tt xml cursor token type comment result comment els if tt xml cursor token type procinst result process instruct els if tt xml cursor token type start result element els a non exist node ha the node kind of text result text return result 
void normal xml cursor cur new cursor token type tt cur current token type walk through the token remov empti text node and merg adjac text node if tt is startdoc tt cur to first content token if tt is contain int nest level 1 string previou text null while nest level 0 tt cur to next token if tt xml cursor token type text string current text cur get char trim if current text trim length 0 empti text node remov remov token cur cur to prev token els if previou text null no previou text node reset to trim version previou text current text els it appear that thi case never happen with xbean previou text node exist concaten string new text previou text current text cur to prev token remov token cur remov token cur cur insert char new text els previou text null if tt is start nest level els if tt is end nest level els if tt is enddoc shouldn t get here but just in case break cur dispos 
return object parent object parent xml cursor cur new cursor if cur is startdoc at doc level no parent parent undefin instanc els if cur to parent if cur is startdoc wa top level no parent parent undefin instanc els parent get from annot lib find annot cur els no parent parent undefin instanc cur dispos return parent 
param xml return xml prepend child object xml xml cursor cur new cursor if cur is startdoc cur to first content token move the cursor to the first content token cur to first content token insert child cur xml cur dispos return thi 
return object process instruct xmlname xml name return match children xml cursor token type procinst xml name 
param name return boolean properti is enumer object name boolean result if name instanceof integ result integ name int valu 0 els if name instanceof number doubl x number name doubl valu check that number is posot 0 result x 0 0 1 0 x 0 els result script runtim to string name equal 0 return result 
param namespac xml remov namespac namespac ns xml cursor cursor new cursor try if cursor is startdoc cursor to first content token if cursor is start return thi string ns prefix ns prefix string ns uri ns uri map prefix to uri new hash map int depth 1 while cursor is end depth 0 if cursor is start get the namespac declar in thi element the on with undefin prefix ar not candid for remov becaus thei ar us prefix to uri clear namespac helper get namespac cursor prefix to uri obj arrai in scope nsbag new obj arrai iter i prefix to uri entri set iter while i ha next map entri entri map entri i next ns new namespac lib string entri get kei string entri get valu in scope nsbag add ns add the uri we ar look for to avoid match non exist namespac ns new namespac lib ns uri in scope nsbag add ns object in scope ns in scope nsbag to arrai check the element name namespac n namespac helper get namespac lib cursor in scope ns if ns uri equal n uri ns prefix null ns prefix equal n prefix thi namespac is us return thi check the attribut cursor push boolean ha next cursor to first attribut while ha next n namespac helper get namespac lib cursor in scope ns if ns uri equal n uri ns prefix null ns prefix equal n prefix thi namespac is us return thi ha next cursor to next attribut cursor pop if ns prefix null remov all namespac declar that match ns uri i prefix to uri entri set iter while i ha next map entri entri map entri i next if entri get valu equal ns uri namespac helper remov namespac cursor string entri get kei els if ns uri equal prefix to uri get ns prefix remov the namespac declar that match ns prefix namespac helper remov namespac cursor string valu of ns prefix switch cursor to next token int valu case xml cursor token type int start depth break case xml cursor token type int end depth break final cursor dispos return thi 
xml replac long index object xml xmllist xl child to replac xmllist child index if xl child to replac length 0 on exist an that index xml child to replac xml xl child to replac item 0 insert child after child to replac xml remov child index return thi 
param properti name param xml return xml replac xmlname xml name object xml put xmlproperti xml name xml return thi 
param xml xml set children object xml remov all children xmlname xml name xmlname form star xmllist match xmllist get properti list xml name match remov append new children append child xml return thi 
param name void set local name string local name xml cursor cursor new cursor try if cursor is startdoc cursor to first content token if cursor is text cursor is comment return javax xml namespac qname qname cursor get name cursor set name new javax xml namespac qname qname get namespac uri local name qname get prefix final cursor dispos 
param name void set name qname qname xml cursor cursor new cursor try if cursor is startdoc cursor to first content token if cursor is text cursor is comment return if cursor is procinst string local name qname local name cursor set name new javax xml namespac qname local name els string prefix qname prefix if prefix null prefix cursor set name new javax xml namespac qname qname uri qname local name prefix final cursor dispos 
param ns void set namespac namespac ns xml cursor cursor new cursor try if cursor is startdoc cursor to first content token if cursor is text cursor is comment cursor is procinst return string prefix ns prefix if prefix null prefix cursor set name new javax xml namespac qname ns uri local name prefix final cursor dispos 
return xmllist text return match children xml cursor token type text 
return public string to string string result xml cursor cur new cursor if cur is startdoc cur to first content token if cur is text result cur get char els if cur is start ha simpl content result cur get text valu els result to xmlstring 0 return result 
string to sourc int indent xxx doe to xmlstring alwai return valid xml liter return to xmlstring indent 
return string to xmlstring int indent xxx indent is ignor string result xml cursor cur new cursor if cur is startdoc cur to first content token try if cur is text result cur get char els if cur is attr result cur get text valu els if cur is comment cur is procinst result xml dump node cur get option todo xbean depend hack here if it s a comment or pi take off the xml frament stuff string start xml fragment string end xml fragment if result start with start result result substr start length if result end with end result result substr 0 result length end length els result xml dump node cur get option final cur dispos return result 
return object valu of return thi 
param target return boolean equival xml object target boolean result fals if target instanceof xml xml other xml xml target compar with to string if either side is text node or attribut otherwis compar as xml xml cursor token type thi tt token type xml cursor token type other tt other xml token type if thi tt xml cursor token type attr other tt xml cursor token type attr thi tt xml cursor token type text other tt xml cursor token type text result to string equal other xml to string els xml cursor cur on new cursor xml cursor cur two other xml new cursor result logic equal node equal cur on cur two cur on dispos cur two dispos old wai of compar by string boolean org pretti print prototyp pretti print prototyp pretti print true result to xmlstring 0 equal other xml to xmlstring 0 prototyp pretti print org pretti print els if target instanceof xmllist xmllist other list xmllist target if other list length 1 result equival xml other list get xml from annot 0 els if ha simpl content string other str script runtim to string target result to string equal other str return result 
param name param start return xmllist get properti list xmlname name xmllist result get the name properti if name is descend result descend name els if name is attribut name result attribut name els result child name return result 
protect object js constructor context cx boolean in new expr object arg if arg length 0 return creat from js lib els object arg0 arg 0 if in new expr arg0 instanceof xml xml xml return the same object return arg0 return creat from js lib arg0 
see ecma 357 11 2 2 1 semant 3 f public scriptabl get extra method sourc context cx if ha simpl content string src to string return script runtim to object or null cx src return null 
xml object get xml object xml object xo xml cursor cursor new cursor try xo cursor get object final cursor dispos return xo 
public class data type 003 extend live connect test public data type 003 super 
public static void main string arg data type 003 test new data type 003 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class 
valu pass from java script to java ar convert as follow ul li li object that ar wrapper around java object ar unwrap li other object ar wrap with a jsobject li string number and boolean ar convert to string float and boolean object respect see netscap javascript jsobject public void execut test java object ar unwrap do get jsvar test packag com netscap javascript qa liveconnect data type class java lang class class com netscap javascript qa liveconnect data type class do get jsvar test new java lang string java string java lang string java string string number and boolean ar convert to string doubl and boolean object do get jsvar test boolean true java lang boolean true do get jsvar test boolean java lang boolean fals do get jsvar test boolean fals java lang boolean fals do get jsvar test number 12345 java lang doubl new doubl 12345 to string do get jsvar test 12345 java lang doubl new doubl 12345 to string do get jsvar test string hello java lang string hello do get jsvar test hello java lang string hello do get jsvar test true java lang boolean true do get jsvar test fals java lang boolean fals other object ar wrap with a jsobject do get jsvar test new number 0 netscap javascript jsobject 0 throw null pointer except put in it own test do get jsvar test null netscap javascript jsobject null 4 05 return a java lang string which i guess we need to maintain for backward compatilibilti do get jsvar test void 0 java lang string undefin do get jsvar test new number 999 netscap javascript jsobject 999 do get jsvar test math netscap javascript jsobject object math do get jsvar test new boolean true netscap javascript jsobject true do get jsvar test new boolean fals netscap javascript jsobject fals do get jsvar test new string netscap javascript jsobject do get jsvar test new string hi netscap javascript jsobject hi do get jsvar test new arrai 1 2 3 4 5 netscap javascript jsobject 1 2 3 4 5 do get jsvar test 5 4 3 2 1 netscap javascript jsobject 5 4 3 2 1 
pass the same argument to two differ test param right expr right hand side to a java script assign express param class name expect name of the class of the java script object when it valu is retriev from the java script context us jsobject eval or jsobject get member param valu string represent of the valu of the java script object see get jsvar with eval see get jsvar with get member public void do get jsvar test string right expr string class name string valu get jsvar with eval right expr class name valu get jsvar with get member right expr class name valu 
us jsobject eval to creat a java script variabl of a java script type get the valu of the variabl us jsobject get member and jsobject eval the type and valu of the object return by get member and eval should be the same add the testcas param right expr right hand side to a java script assign express param class name string represent of expect type of the result param e valu expect valu of the result public void get jsvar with eval string right expr string class name string valu string var name js var object js object object result class expect class null try expect class class for name class name creat the variabl in the java script context global eval var var name right expr get the valu of var name from the java script context js object global eval var name catch except e system err println set jsvar with eval threw e to string with argument right expr expect class get name valu to string e print stack trace except e to string js object new object compar the class of the js object to the expect class add test case global eval var var name right expr js object global eval var name js object get class get name equal expect class get name js object class is js object get class get name true js object get class get name equal expect class get name except compar the valu of the string valu of the js object to the expect string valu add test case js object to string equal valu to string true js object to string equal valu except 
us jsobject eval to creat a java script variabl of a java script type get the valu of the variabl us jsobject get member add the test case param right expr right hand side to a java script assign express param class name string represent of expect type of the result param e valu expect valu of the result public void get jsvar with get member string right expr string class name string valu string var name js var object js object class expect class null try expect class class for name class name creat the variabl in the java script context global eval var var name right expr get the valu of var name from the java script context js object global get member var name catch except e system err println get jsvar with get member threw e to string with argument right expr expect class get name valu to string e print stack trace except e to string js object new object check the class of the js object object add test case global eval var var name right expr js object global get member var name js object get class get name equal expect class get name js object class is js object get class get name true js object get class get name equal expect class get name except check the string represent of the js object add test case js object to string equal valu to string true js object to string equal valu except 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl 
public string ambigu string arg return string 
public string ambigu object arg return object 
privat static final object import tag new object public import top level 
public import top level public import top level context cx thi cx fals 
public import top level context cx boolean seal init standard object cx seal 
public string get class name return top scope flag global java import 
public static void init context cx scriptabl scope boolean seal import top level obj new import top level obj export as jsclass max prototyp id scope seal 
public void init standard object context cx boolean seal assum that context init standard object initi java import properti lazili so the abov init call is not yet call cx init standard object thi seal top scope flag true if seal is true then export as jsclass cx seal would seal thi obj sinc thi is scope as well it would not allow to add variabl id function object ctor export as jsclass max prototyp id thi fals if seal ctor seal object delet constructor defin by export as jsclass so constructor name would refer to object constructor and not to java import prototyp constructor delet constructor 
public boolean ha string name scriptabl start return super ha name start get packag properti name start not found 
public object get string name scriptabl start object result super get name start if result not found return result result get packag properti name start return result 
privat object get packag properti string name scriptabl start object result not found object element synchron import packag element import packag to arrai for int i 0 i element length i nativ java packag p nativ java packag element i object v p get pkg properti name start fals if v null v instanceof nativ java packag if result not found result v els throw context report runtim error2 msg ambig import result to string v to string return result 
deprec kept onli for compat public void import packag context cx scriptabl thi obj object arg function fun obj js import packag arg 
privat object js construct scriptabl scope object arg import top level result new import top level for int i 0 i arg length i object arg arg i if arg instanceof nativ java class result import class nativ java class arg els if arg instanceof nativ java packag result import packag nativ java packag arg els throw context report runtim error1 msg not class not pkg context to string arg set explicitli prototyp and scope as otherwis in top scope mode base function construct would keep them set to null it also allow to us java import without new and still get properli initi object result set parent scope scope result set prototyp thi return result 
privat object js import class object arg for int i 0 i arg length i object arg arg i if arg instanceof nativ java class throw context report runtim error1 msg not class context to string arg import class nativ java class arg return undefin instanc 
privat object js import packag object arg for int i 0 i arg length i object arg arg i if arg instanceof nativ java packag throw context report runtim error1 msg not pkg context to string arg import packag nativ java packag arg return undefin instanc 
privat void import packag nativ java packag pkg synchron import packag for int j 0 j import packag size j if pkg import packag get j pkg null break if pkg null import packag add pkg 
privat void import class nativ java class cl string s cl get class object get name string n s substr s last index of 1 object val get n thi if val not found val cl throw context report runtim error1 msg prop defin n defin properti n cl dontenum put n thi cl 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 0 s constructor break case id import class ariti 1 s import class break case id import packag ariti 1 s import packag break default throw new illeg argument except string valu of id init prototyp method import tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag import tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor return js construct scope arg case id import class return real thi thi obj f js import class arg case id import packag return real thi thi obj f js import packag arg throw new illeg argument except string valu of id 
privat import top level real thi scriptabl thi obj id function object f if top scope flag when us as top scope import packag and import class ar global function that ignor thi obj return thi if thi obj instanceof import top level throw incompat call error f return import top level thi obj 
protect int find prototyp id string s int id gener last updat 2004 06 08 02 03 11 cest l0 id 0 string x null int c int s length s length if s length 11 c s char at 0 if c c x constructor id id constructor els if c i x import class id id import class els if s length 13 x import packag id id import packag if x null x s x equal s id 0 gener return id 
public class data type 011 extend live connect test public data type 011 super 
public static void main string arg data type 011 test new data type 011 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt static get short arrai true do arrai test dt pub static arrai short true do arrai test dt get short arrai true do arrai test dt pub arrai short fals 
assign a java short to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command the command to eval to get the byte arrai public void do arrai test string command boolean should equal short arrai data type class pub static arrai short short js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java object js arrai short global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai doubl item doubl global eval js arrai i add test case js arrai command global eval js arrai i equal arrai i true item equal new doubl arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal true fals js arrai arrai 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public int ambigu char arg return char 
public string float float public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl object 
public string ambigu doubl arg return doubl 
public string expect return doubl 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
creat a new test log and open associ stream param name name of the log file param termin string that will be append to the end of each line public test log string name string termin thi name name thi termin termin open log 
write a string to the end test log file public void write line string string if print stream null print stream println string termin try random access file raf new random access file name rw raf seek raf length raf write output stream to byte arrai raf close output stream reset catch except e system out println except write to name write line e 
overrid if privileg ar requir to write to file system the default implemen doe noth public void enabl privileg return 
close print stream associ with the test log file public void close log if print stream null print stream close 
creat stream associ with thi test log file public void open log enabl privileg thi output stream new byte arrai output stream thi print stream new print stream thi output stream 
public string to string return thi name 
public class data type 002 extend live connect test public data type 002 super 
public static void main string arg data type 002 test new data type 002 test start 
public void execut test do test on do test two do test three do test four 
string liter get pass jsobject eval and thi test succe public void do test on object befor object new valu object new string test on new valu object after befor global eval dt pub static string global eval dt pub static string test on new valu after global eval dt pub static string add test case global eval dt public string test on new valu after global eval dt pub static string after to string equal new valu to string true after to string equal new valu to string null 
new string valu is object to string thi succe with the extra quot public void do test two object befor object new valu object new string test two new valu object after befor global eval dt pub static string global eval dt pub static string new valu to string after global eval dt pub static string add test case object new valu object new string test two new valu global eval dt public string new valu to string after global eval dt pub static string after to string equal new valu to string true after to string equal new valu to string null 
more extra quot stuff thi succe public void do test three object befor object new valu object new string test three new valu object after string eval arg dt pub static string new valu to string befor global eval dt pub static string global eval eval arg to string after global eval dt pub static string add test case string eval arg eval arg to string global eval eval arg to string after global eval dt pub static string after to string equal new valu to string true after to string equal new valu to string null 
thi throw an except thi doe not us the extra quot public void do test four object befor object new valu object new string test four new valu object after string except string eval arg dt pub static string new valu to string string except jsexcept thrown try befor global eval dt pub static string global eval eval arg to string after global eval dt pub static string except catch except e if e instanceof jsexcept after except els after some random except thrown file except e to string add test case string eval arg eval arg to string global eval eval arg to string after global eval dt pub static string after to string equal new valu to string except after to string file except 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class 
public static void defin class scriptabl object scope try scriptabl object defin class scope environ class catch except e throw new error e get messag 
public string get class name return environ 
public environ if the prototyp instanc null the prototyp instanc thi 
public environ scriptabl object scope set parent scope scope object ctor script runtim get top level prop scope environ if ctor null ctor instanceof scriptabl scriptabl s scriptabl ctor set prototyp scriptabl s get prototyp s 
public boolean ha string name scriptabl start if thi the prototyp instanc return super ha name start return system get properti name null 
public object get string name scriptabl start if thi the prototyp instanc return super get name start string result system get properti name if result null return script runtim to object get parent scope result els return scriptabl not found 
public void put string name scriptabl start object valu if thi the prototyp instanc super put name start valu els system get properti put name script runtim to string valu 
privat object collect id properti prop system get properti enumer name prop properti name vector kei new vector while name ha more element kei add element name next element object id new object kei size kei copi into id return id 
public object get id if thi the prototyp instanc return super get id return collect id 
public object get all id if thi the prototyp instanc return super get all id return collect id 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl object 
public string expect return doubl object 
public class data type 005 extend live connect test public data type 005 super 
public static void main string arg data type 005 test new data type 005 test start 
public void execut test do field test dt pub boolean java lang boolean object new boolean data type class pub static final boolean do field test dt pub byte java lang doubl object new doubl data type class pub static final byte do field test dt pub short java lang doubl object new doubl data type class pub static final short do field test dt pub int java lang doubl object new doubl data type class pub static final int do field test dt pub long java lang doubl object new doubl data type class pub static final long do field test dt pub float java lang doubl object new doubl data type class pub static final float do field test dt pub doubl java lang doubl object new doubl data type class pub static final doubl do field test dt pub char java lang doubl object new doubl data type class pub static final char do field test dt pub string java lang string object new string data type class pub static final string 
call the parent class s setup test environ method us jsobject eval to defin the com netscap javascript qa liveconnect data type class us jsobject eval to defin an instanc of the data type class see com netscap javascript qa liveconnect data type class public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
pass the argument to the differ test all of which take the same argument param field name of the data type class field param class name name of the class of the data type class field param valu valu of the data type class field see com netscap javascript qa liveconnect data type class public void do field test string field string class name object valu get public field field class name valu if field start with dt pub final set public final field field class name valu els set public field field class name valu set java script variabl field class name valu 
us jsobject eval to creat a java script variabl whose valu is the valu of a java object instanc us jsobject get member to get the valu of the java script object and verifi that the valu of the result object is of the expect class and valu param field name of the data type class field param class name name of the class of the data type class field param valu valu of the data type class field see com netscap javascript qa liveconnect data type class public void get public field string field string class name object valu string descript field string except null object actual null string expect null check the class try global eval var myobject descript actual global get member myobject expect class for name class name get name catch class not found except e catch except e except e to string might want to do all the interest stuff here in a try catch block add test case descript get class expect actual get class get name except add test case descript valu to string true actual equal valu except add test case actual to string equal valu to string true actual to string equal valu to string except 
us jsobject eval to creat a java script variabl whose valu is the valu of a java object instanc us jsobject eval to reset the valu of the java script variabl and then us jsobject eval to get the new valu of the java script object verifi that the valu of the result object is of the expect class and valu param field name of the data type class field param class name name of the class of the data type class field param valu valu of the data type class field see com netscap javascript qa liveconnect data type class public void set public field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try befor global eval descript need to quot string if class name equal java lang string global eval descript new valu to string els global eval descript new valu after global eval descript expect class for name class name get name catch except e except e to string add test case global eval descript new valu to string after global eval descript after get class get name expect after get class get name except add test case after to string equal new valu to string true after equal new valu except add test case after to string equal new valu to string true after to string equal new valu to string except 
us jsobject eval to get the valu of a java object field that ha been defin as final assign a valu to a public final instanc field the assign should fail the valu should not chang but there should be no error messag param field name of the data type class field param class name name of the class of the data type class field param valu valu of the data type class field see com netscap javascript qa liveconnect data type class public void set public final field string field string class name object valu string descript field string except null object befor null object after null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try expect class for name class name get name catch except e except e to string befor global eval descript global eval descript new valu to string after global eval descript check the class of the result which should be the same as expect add test case descript get class expect after get class get name except the valu of the actual result should be the origin valu add test case descript valu to string true after equal valu except the string represent of the actual result should be the same as the string represent of the expect valu add test case after to string equal valu to string true after to string equal valu to string except get member field should return the same valu befor and after the assign add test case befor equal after true befor equal after except 
us jsobject eval to creat a java script variabl whose valu is the valu of a java object instanc us jsobject set member to reset the valu of the variabl and then us jsobject get member to get the valu of the java script object vverifi that the valu of the result object is of the expect class and valu param field name of the data type class field param class name name of the class of the data type class field param valu valu of the data type class field see com netscap javascript qa liveconnect data type class public void set java script variabl string field string class name object valu string descript field string except null object actual null string expect null object new valu class name equal java lang doubl new doubl 0 class name equal java lang boolean new boolean fals object new string new valu try global eval var myobject descript global set member myobject new valu actual global get member myobject expect class for name class name get name catch except e except e to string add test case global eval var myobject descript global set member myobject new valu to string actual global get member myobject actual get class get name expect actual get class get name except add test case descript new valu to string true actual equal new valu except add test case actual to string equal new valu to string true actual to string equal new valu to string except 
protect boolean ha featur context cx int featur index if featur index context featur dynam scope return us dynam scope return super ha featur cx featur index 
main entri point set up the share scope and then spawn new thread that execut rel to that share scope try to run function with and without dynam scope to see the effect the expect output is pre share scope nest share scope share scope nest share scope share scope nest share scope thread0 nest thread0 thread1 nest thread1 thread2 nest thread2 pre the final three line mai be permut in ani order depend on thread schedul public static void main string arg context cx context enter try precompil sourc onli onc string sourc var x share scope n function f return x n dynam scope work with nest function too function init closur prefix n return function test return prefix x n n var closur init closur nest n script script cx compil string sourc share script 1 null us dynam scope fals run script cx script us dynam scope true run script cx script final cx exit 
static void run script context cx script script initi the standard object object function etc thi must be done befor script can be execut the call return a new scope that we will share scriptabl object share scope cx init standard object null true now we can execut the precompil script against the scope to defin x variabl and f function in the share scope script exec cx share scope now we spawn some thread that execut a script that call the function f the scope chain look like thi pre per thread scope prototyp share scope parent scope f s activ pre both the share scope and the per thread scope have variabl x defin in them if f is compil with dynam scope enabl the x from the per thread scope will be us otherwis the x from the share scope will be us the x defin in g which call f should not be seen by f final int thread count 3 thread t new thread thread count for int i 0 i thread count i string source2 function g var x local return f n java lang system out println g n function g2 var x local return closur n java lang system out println g2 n t i new thread new per thread share scope source2 thread i for int i 0 i thread count i t i start don t return in thi thread until all the spawn thread have complet for int i 0 i thread count i try t i join catch interrupt except e 
per thread scriptabl share scope string sourc string x thi share scope share scope thi sourc sourc thi x x 
public void run we need a new context for thi thread context cx context enter try we can share the scope scriptabl thread scope cx new object share scope thread scope set prototyp share scope we want thread scope to be a new top level scope so set it parent scope to null thi mean that ani variabl creat by assign will be properti of thread scope thread scope set parent scope null creat a java script properti of the thread scope name x and save a valu for it thread scope put x thread scope x cx evalu string thread scope sourc thread script 1 null final context exit 
construct class compil that us the specifi compil environ when gener class public class compil compil environ compil env if compil env null throw new illeg argument except thi compil env compil env thi main method class name codegen default main method class 
set the class name to us for main method implement the class must have a method match tt public static void main script sc string arg tt it will be call when tt main string arg tt is call in the gener class the class name should be fulli qulifi name and includ the packag name like in tt org foo bar tt public void set main method class string class name xxx should thi check for a valid class name main method class name class name 
get the name of the class for main method implement see set main method class string public string get main method class return main method class name 
get the compil environ the compil us public compil environ get compil env return compil env 
get the class that the gener target will extend public class get target extend return target extend 
set the class that the gener target will extend param extend class the class it extend public void set target extend class extend class target extend extend class 
get the interfac that the gener target will implement public class get target implement return target implement 
set the interfac that the gener target will implement param implement class an arrai of class object on for each interfac the target will extend public void set target implement class implement class target implement implement class 
build class name for a auxiliari class gener by compil if the compil need to gener extra class beyond the main class it will call thi function to build the auxiliari class name the default implement simpli append aux marker to main class name but thi can be overridden protect string make auxiliari class name string main class name string aux marker return main class name aux marker 
compil java script sourc into on or more java class file the first compil class will have name main class name if the result of link get target extend or link get target implement ar not null then the first compil class will extend the specifi super class and implement specifi interfac return arrai where element with even index specifi class name and the followinf odd index give class file bodi as byte arrai the initi elemnt of the arrai alwai hold main class name and arrai 1 hold it byte code public object compil to class file string sourc string sourc locat int lineno string main class name parser p new parser compil env compil env get error report script or fn node tree p pars sourc sourc locat lineno string encod sourc p get encod sourc class super class get target extend class interfac get target implement string script class name boolean is primari interfac null super class null if is primari script class name main class name els script class name make auxiliari class name main class name 1 codegen codegen new codegen codegen set main method class main method class name byte script class byte codegen compil to class file compil env script class name tree encod sourc fals if is primari return new object script class name script class byte int function count tree get function count obj to int map function name new obj to int map function count for int i 0 i function count i function node ofn tree get function node i string name ofn get function name if name null name length 0 function name put name ofn get param count if super class null super class script runtim object class byte main class byte java adapt creat adapt code function name main class name super class interfac script class name return new object main class name main class byte script class name script class byte 
protect object get thread context helper to make subsequ batch call to get context set context faster associ perman on element arrai with context local so get context set context would need just to read write the first arrai element note that it is necessari to us object not context to allow garbag collect of rhino class for detail see comment by attila szegedi in http bugzilla mozilla org show bug cgi id 281067 c5 object storag object context local get if storag null storag new object 1 context local set storag return storag 
protect context get context object context helper object storag object context helper return context storag 0 
protect void set context object context helper context cx object storag object context helper storag 0 cx 
protect class loader get current thread class loader return thread current thread get context class loader 
protect boolean try to make access object access object if access object instanceof access object return fals access object access access object access object if access is access return true try access set access true catch except ex return access is access 
protect object get interfac proxi helper context factori cf class interfac xxx how to handl interfac arrai withclass from differ class loader us cf get applic class loader class loader loader interfac 0 get class loader class cl proxi get proxi class loader interfac constructor c try c cl get constructor new class invoc handler class catch no such method except ex should not happen throw kit init caus new illeg state except ex return c 
protect object new interfac proxi object proxi helper final context factori cf final interfac adapt adapt final object target final scriptabl top scope constructor c constructor proxi helper invoc handler handler new invoc handler public object invok object proxi method method object arg return adapt invok cf target top scope method arg object proxi try proxi c new instanc new object handler catch invoc target except ex throw context throw as script runtim ex ex catch illeg access except ex shoul not happen throw kit init caus new illeg state except ex catch instanti except ex shoul not happen throw kit init caus new illeg state except ex return proxi 
invoc handler handler new invoc handler public object invok object proxi method method object arg return adapt invok cf target top scope method arg 
public class data type 008 extend live connect test public data type 008 super 
public static void main string arg data type 008 test new data type 008 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt 
public void execut test do arrai test dt pub static arrai byte true do arrai test dt get byte arrai true do arrai test dt pub arrai byte fals 
assign a java byte arrai to a java script variabl in the follow wai ul li call a static method li get the valu of a static field li call an instanc method li get the valu of an instanc field param command method call or field refer that return an arrai public void do arrai test string command boolean should equal byte arrai data type class pub static arrai byte byte js arrai int js arrai length try assign the arrai to a java script variabl global eval var js arrai command get the js arrai object which should be the java object js arrai byte global get member js arrai get the length of the arrai from java script js arrai length doubl global eval js arrai length int valu iter through js arrai in java script verifi that the type and valu of each object in the arrai is correct for int i 0 i js arrai length i verifi that the arrai item is the same object as in the origin arrai doubl item doubl global eval js arrai i add test case js arrai command global eval var js arrai command global eval js arrai i equal arrai i true item equal new doubl arrai i catch except e e print stack trace file except e to string js arrai length 0 js arrai null verifi that js arrai is the same as the origin arrai add test case js arrai command js arrai global get member js arrai js arrai arrai should equal true fals js arrai arrai 
public class to string 001 extend live connect test public to string 001 super 
public static void main string arg to string 001 test new to string 001 test start 
public void setup test environ super setup test environ 
public void execut test object data get data arrai for int i 0 i data length i jsobject js object get jsobject object data i get string js object object data i 
public void get string jsobject js object object data string e string string data 2 string result of to string null string result of call null string result of eval null try result of to string js object to string result of call string js object call to string null catch except e file except e to string p get string threw e to string e print stack trace final add test case js object to string return js object to string js object to string equal e string true js object to string equal e string file except add test case call to string return result of call js object call to string null equal e string true result of call equal e string file except 
creat and return a jsobject us data in the data arrai param data object arrai contain name of jsobject and assign express return the jsobject public jsobject get jsobject object data global eval string data 1 jsobject the thi jsobject global get member string data 0 return the thi 
get the data arrai which is an object arrai data arrai which ar also object arrai the data arrai consist of 8 item ul li identifi for java script object li assign express to initi java script object li expect string valu of the object ul to add test case to thi test modifi thi method return the data arrai public object get data arrai object d0 new string o 0 identifi new string var o new object 1 complet express for instanti or assign new string object object object d1 new string num new string num new number 12345 new string 12345 object d2 new string number new string number new number infin new string infin object d3 new string string new string string new string java script new string java script object d4 new string arrai new string arrai new arrai 1 2 3 4 5 new string 1 2 3 4 5 object data arrai d0 d1 d2 d3 d4 return data arrai 
public class run script2 public static void main string arg context cx context enter try scriptabl scope cx init standard object add a global variabl out that is a java script reflect of system out object js out context java to js system out scope scriptabl object put properti scope out js out string s for int i 0 i arg length i s arg i object result cx evalu string scope s cmd 1 null system err println cx to string result final context exit 
no instanc should be creat protect script runtim 
public static boolean is rhino runtim type class cl if cl is primit return cl charact type els return cl string class cl boolean class number class is assign from cl scriptabl class is assign from cl 
public static scriptabl object init standard object context cx scriptabl object scope boolean seal if scope null scope new nativ object scope associ valu librari scope kei scope new class cach associ scope base function init scope seal nativ object init scope seal scriptabl object proto scriptabl object get object prototyp scope function prototyp proto should be object prototyp scriptabl function proto scriptabl object get function prototyp scope function proto set prototyp object proto set the prototyp of the object pass in if need be if scope get prototyp null scope set prototyp object proto must preced nativ global sinc it s need therein nativ error init scope seal nativ global init cx scope seal nativ arrai init scope seal nativ string init scope seal nativ boolean init scope seal nativ number init scope seal nativ date init scope seal nativ math init scope seal nativ with init scope seal nativ call init scope seal nativ script init scope seal boolean with xml cx ha featur context featur e4x for int i 0 i lazili name length i 2 string top properti lazili name i string class name lazili name i 1 if with xml class name xml init class continu new lazili load ctor scope top properti class name seal continu init scope seal return scope 
public static scriptabl object get librari scope or null scriptabl scope scriptabl object lib scope lib scope scriptabl object scriptabl object get top scope valu scope librari scope kei return lib scope 
it is public so nativ reg exp can access it public static boolean is jsline termin int c optim for faster check for eol charact thei do not have 0x dfd0 bit set if c 0x dfd0 0 return fals return c n c r c 0x2028 c 0x2029 
public static boolean wrap boolean boolean b return b boolean true boolean fals 
public static integ wrap int int i return new integ i 
public static number wrap number doubl x if x x return script runtim na nobj return new doubl x 
convert the valu to a boolean see ecma 9 2 public static boolean to boolean object val for if val instanceof boolean return boolean val boolean valu if val null val undefin instanc return fals if val instanceof string return string val length 0 if val instanceof number doubl d number val doubl valu return d d d 0 0 if val instanceof scriptabl if context get context is version ecma1 pure ecma return true ecma extens val scriptabl val get default valu boolean class if val instanceof scriptabl throw error with class name msg primit expect val continu warn about non jsobject val return true 
public static boolean to boolean object arg int index return index arg length to boolean arg index fals 
convert the valu to a number see ecma 9 3 public static doubl to number object val for if val instanceof number return number val doubl valu if val null return 0 0 if val undefin instanc return na n if val instanceof string return to number string val if val instanceof boolean return boolean val boolean valu 1 0 0 if val instanceof scriptabl val scriptabl val get default valu number class if val instanceof scriptabl throw error with class name msg primit expect val continu warn about non jsobject val return na n 
public static doubl to number object arg int index return index arg length to number arg index na n 
static doubl string to number string s int start int radix char digit max 9 char lower case bound a char upper case bound a int len s length if radix 10 digit max char 0 radix 1 if radix 10 lower case bound char a radix 10 upper case bound char a radix 10 int end doubl sum 0 0 for end start end len end char c s char at end int new digit if 0 c c digit max new digit c 0 els if a c c lower case bound new digit c a 10 els if a c c upper case bound new digit c a 10 els break sum sum radix new digit if start end return na n if sum 9007199254740992 0 if radix 10 if we re accumul a decim number and the number is 2 53 then the result from the repeat multipli add abov mai be inaccur call java to get the correct answer try return doubl valu of s substr start end doubl valu catch number format except nfe return na n els if radix 2 radix 4 radix 8 radix 16 radix 32 the number mai also be inaccur for on of these base thi happen if the addit in valu radix digit caus a round down to an even least signific mantissa bit when the first drop bit is a on if ani of the follow digit in the number which haven t been ad in yet ar nonzero then the correct action would have been to round up instead of down an exampl of thi occur when read the number 0x1000000000000081 which round to 0x1000000000000000 instead of 0x1000000000000100 int bit shift in char 1 int digit 0 final int skip lead zero 0 final int first exact 53 bit 1 final int after bit 53 2 final int zero after 54 3 final int mix after 54 4 int state skip lead zero int exact bit limit 53 doubl factor 0 0 boolean bit53 fals bit54 is the 54th bit the first drop from the mantissa boolean bit54 fals for if bit shift in char 1 if start end break digit s char at start if 0 digit digit 9 digit 0 els if a digit digit z digit a 10 els digit a 10 bit shift in char radix bit shift in char 1 boolean bit digit bit shift in char 0 switch state case skip lead zero if bit exact bit limit sum 1 0 state first exact 53 bit break case first exact 53 bit sum 2 0 if bit sum 1 0 exact bit limit if exact bit limit 0 bit53 bit state after bit 53 break case after bit 53 bit54 bit factor 2 0 state zero after 54 break case zero after 54 if bit state mix after 54 fallthrough case mix after 54 factor 2 break switch state case skip lead zero sum 0 0 break case first exact 53 bit case after bit 53 do noth break case zero after 54 x1 1 x1 1 round up x0 1 x0 round down if bit54 bit53 sum 1 0 sum factor break case mix after 54 x 100 1 x 1 round up x 0anyth x round down if bit54 sum 1 0 sum factor break we don t worri about inaccur number for ani other base return sum 
to number appli to the string type see ecma 9 3 1 public static doubl to number string s int len s length int start 0 char start char for if start len empti or contain onli whitespac return 0 0 start char s char at start if charact is whitespac start char break start if start char 0 if start 2 len int c1 s char at start 1 if c1 x c1 x a hexadecim number return string to number s start 2 16 els if start char start char if start 3 len s char at start 1 0 int c2 s char at start 2 if c2 x c2 x a hexadecim number with sign doubl val string to number s start 3 16 return start char val val int end len 1 char end char while charact is whitespac end char s char at end end if end char y check for infin if start char start char start if start 7 end s region match start infin 0 8 return start char doubl neg infin doubl posit infin return na n a non hexadecim non infin number just try a normal float point convers string sub s substr start end 1 if msjvm bug workaround the ms jvm will accept non conform string rather than throw a number format except as it should for int i sub length 1 i 0 i char c sub char at i if 0 c c 9 c c e c e c c continu return na n try return doubl valu of sub doubl valu catch number format except ex return na n 
helper function for builtin object that us the vararg form ecma function formal argument ar undefin if not suppli thi function pad the argument arrai out to the expect length if necessari public static object pad argument object arg int count if count arg length return arg int i object result new object count for i 0 i arg length i result i arg i for i count i result i undefin instanc return result 
privat final static boolean msjvm bug workaround true public static string escap string string s return escap string s 
for escap string print by object and arrai liter not quit the same as escap public static string escap string string s char escap quot if escap quot escap quot kit code bug string buffer sb null for int i 0 l s length i l i int c s char at i if c c c escap quot c an ordinari print charact like c isprint and not or if sb null sb append char c continu if sb null sb new string buffer l 3 sb append s sb set length i int escap 1 switch c case b escap b break case f escap f break case n escap n break case r escap r break case t escap t break case 0xb escap v break java lack v case escap break case escap break if escap 0 an escap sort of charact sb append sb append char escap els if c escap quot sb append sb append escap quot els int hex size if c 256 2 digit hex sb append x hex size 2 els unicod sb append u hex size 4 append hexadecim form of c left pad with 0 for int shift hex size 1 4 shift 0 shift 4 int digit 0xf c shift int hc digit 10 0 digit a 10 digit sb append char hc return sb null s sb to string 
static boolean is valid identifi name string s int l s length if l 0 return fals if charact is java identifi start s char at 0 return fals for int i 1 i l i if charact is java identifi part s char at i return fals return token stream is keyword s 
convert the valu to a string see ecma 9 8 public static string to string object val for if val null return null if val undefin instanc return undefin if val instanceof string return string val if val instanceof number xxx should we just teach nativ number string valu about number return number to string number val doubl valu 10 if val instanceof scriptabl val scriptabl val get default valu string class if val instanceof scriptabl throw error with class name msg primit expect val continu return val to string 
static string default object to string scriptabl obj return object obj get class name 
public static string to string object arg int index return index arg length to string arg index undefin 
optim version of to string object for number public static string to string doubl val return number to string val 10 
public static string number to string doubl d int base if d d return na n if d doubl posit infin return infin if d doubl neg infin return infin if d 0 0 return 0 if base 2 base 36 throw context report runtim error1 msg bad radix integ to string base if base 10 return dto a js dtobasestr base d els string buffer result new string buffer dto a js dtostr result dto a dtostr standard 0 d return result to string 
static string unev context cx scriptabl scope object valu if valu null return null if valu undefin instanc return undefin if valu instanceof string string escap escap string string valu string buffer sb new string buffer escap length 2 sb append sb append escap sb append return sb to string if valu instanceof number doubl d number valu doubl valu if d 0 1 d 0 return 0 return to string d if valu instanceof boolean return to string valu if valu instanceof scriptabl scriptabl obj scriptabl valu object v scriptabl object get properti obj to sourc if v instanceof function function f function v return to string f call cx scope obj empti arg return to string valu warn about non jsobject valu return valu to string 
static string default object to sourc context cx scriptabl scope scriptabl thi obj object arg boolean toplevel iter if cx iter null toplevel true iter fals cx iter new obj to int map 31 els toplevel fals iter cx iter ha thi obj string buffer result new string buffer 128 if toplevel result append result append make sure cx iter is set to null when done so we don t leak memori try if iter cx iter intern thi obj stop recurs object id thi obj get id for int i 0 i id length i if i 0 result append object id id i object valu if id instanceof integ int int id integ id int valu valu thi obj get int id thi obj result append int id els string str id string id valu thi obj get str id thi obj if script runtim is valid identifi name str id result append str id els result append result append script runtim escap string str id result append result append result append script runtim unev cx scope valu final if toplevel cx iter null result append if toplevel result append return result to string 
public static scriptabl to object scriptabl scope object val if val instanceof scriptabl return scriptabl val return to object context get context scope val 
public static scriptabl to object or null context cx object obj if obj instanceof scriptabl return scriptabl obj els if obj null obj undefin instanc return to object cx get top call scope cx obj return null 
deprec us link to object scriptabl object instead public static scriptabl to object scriptabl scope object val class static class if val instanceof scriptabl return scriptabl val return to object context get context scope val 
convert the valu to an object see ecma 9 9 public static scriptabl to object context cx scriptabl scope object val if val instanceof scriptabl return scriptabl val if val null throw type error0 msg null to object if val undefin instanc throw type error0 msg undef to object string class name val instanceof string string val instanceof number number val instanceof boolean boolean null if class name null object arg val scope scriptabl object get top level scope scope return new object cx scope class name arg extens wrap as a live connect object object wrap cx get wrap factori wrap cx scope val null if wrap instanceof scriptabl return scriptabl wrap throw error with class name msg invalid type val 
deprec us link to object context scriptabl object instead public static scriptabl to object context cx scriptabl scope object val class static class return to object cx scope val 
deprec the method is onli present for compat public static object call context cx object fun object thi arg object arg scriptabl scope if fun instanceof function throw not function error to string fun function function function fun scriptabl thi obj to object or null cx thi arg if thi obj null throw undef call error thi obj function return function call cx scope thi obj arg 
public static scriptabl new object context cx scriptabl scope string constructor name object arg scope scriptabl object get top level scope scope function ctor get exist ctor cx scope constructor name if arg null arg script runtim empti arg return ctor construct cx scope arg 
see ecma 9 4 public static doubl to integ object val return to integ to number val 
conveni method public static doubl to integ doubl d if it s na n if d d return 0 0 if d 0 0 d doubl posit infin d doubl neg infin return d if d 0 0 return math floor d els return math ceil d 
public static doubl to integ object arg int index return index arg length to integ arg index 0 0 
see ecma 9 5 public static int to int32 object val short circuit for common integ valu if val instanceof integ return integ val int valu return to int32 to number val 
public static int to int32 object arg int index return index arg length to int32 arg index 0 
public static int to int32 doubl d int id int d if id d thi cover 0 0 as well return id if d d d doubl posit infin d doubl neg infin return 0 d d 0 math floor d math ceil d doubl two32 4294967296 0 d math ieeeremaind d two32 doubl long d d should hold here long l long d return int d doe not work as d can be outsid int rang but the result must alwai be 32 lower bit of l return int l 
see ecma 9 6 return long valu repres 32 bit unsign integ public static long to uint32 doubl d long l long d if l d thi cover 0 0 as well return l 0xffffffff l if d d d doubl posit infin d doubl neg infin return 0 d d 0 math floor d math ceil d 0x100000000 give me a numer overflow doubl two32 4294967296 0 l long math ieeeremaind d two32 return l 0xffffffff l 
public static long to uint32 object val return to uint32 to number val 
see ecma 9 7 public static char to uint16 object val doubl d to number val int i int d if i d return char i if d d d doubl posit infin d doubl neg infin return 0 d d 0 math floor d math ceil d int int16 0x10000 i int math ieeeremaind d int16 return char i 
public static object set default namespac object namespac context cx scriptabl scope cx current activ call if scope null scope get top call scope cx xmllib xml lib current xmllib cx object ns xml lib to default xml namespac cx namespac xxx thi should be in separ namesapc from scriptabl get put if scope ha default ns tag scope xxx thi is raci of caus scriptabl object defin properti scope default ns tag ns scriptabl object perman scriptabl object dontenum els scope put default ns tag scope ns return undefin instanc 
public static object search default namespac context cx scriptabl scope cx current activ call if scope null scope get top call scope cx object ns object for scriptabl parent scope get parent scope if parent null ns object scriptabl object get properti scope default ns tag if ns object scriptabl not found return null break ns object scope get default ns tag scope if ns object scriptabl not found break scope parent return ns object 
public static object get top level prop scriptabl scope string id scope scriptabl object get top level scope scope return scriptabl object get properti scope id 
static function get exist ctor context cx scriptabl scope string constructor name object ctor val scriptabl object get properti scope constructor name if ctor val instanceof function return function ctor val if ctor val scriptabl not found throw context report runtim error1 msg ctor not found constructor name els throw context report runtim error1 msg not ctor constructor name 
return 1l if str is not an index or the index valu as lower 32 bit of the result privat static long index from string string str the length of the decim string represent of integ max valu 2147483647 final int max valu length 10 int len str length if len 0 int i 0 boolean negat fals int c str char at 0 if c if len 1 c str char at 1 i 1 negat true c 0 if 0 c c 9 len negat max valu length 1 max valu length us neg number to accumul index to handl integ min valu that is greater by 1 in absolut valu then integ max valu int index c int old index 0 i if index 0 note that 00 01 000 etc ar not index while i len 0 c str char at i 0 c 9 old index index index 10 index c i make sure all charact were consum and that it couldn t have overflow if i len old index integ min valu 10 old index integ min valu 10 c negat integ min valu 10 integ max valu 10 return 0x ffffffffl negat index index return 1l 
if str is a decim present of uint32 valu return it as long othewis return 1l public static long test uint32str string str the length of the decim string represent of uint32 max valu 4294967296 final int max valu length 10 int len str length if 1 len len max valu length int c str char at 0 c 0 if c 0 note that 00 01 etc ar not valid uint32 present return len 1 0l 1l if 1 c c 9 long v c for int i 1 i len i c str char at i 0 if 0 c c 9 return 1 v 10 v c check for overflow if v 32 0 return v return 1 
if s repres index then return index valu wrap as integ and othewis return s static object get index object string s long index test index from string s if index test 0 return new integ int index test return s 
if d is exact int valu return it valu wrap as integ and othewis return d convert to string static object get index object doubl d int i int d if doubl i d return new integ int i return to string d 
if to string id is a decim present of int32 valu then id is index in thi case return null and make the index avail as script runtim last index result cx otherwis return to string id static string to string id or index context cx object id if id instanceof number doubl d number id doubl valu int index int d if doubl index d store index result cx index return null return to string id els string s if id instanceof string s string id els s to string id long index test index from string s if index test 0 store index result cx int index test return null return s 
call obj get id public static object get object elem object obj object elem context cx scriptabl sobj to object or null cx obj if sobj null throw undef read error obj elem return get object elem sobj elem cx 
public static object get object elem scriptabl obj object elem context cx if obj instanceof xmlobject xmlobject xml object xmlobject obj return xml object ecma get cx elem object result string s to string id or index cx elem if s null int index last index result cx result scriptabl object get properti obj index els result scriptabl object get properti obj s if result scriptabl not found result undefin instanc return result 
version of get object elem when elem is a valid js identifi name public static object get object prop object obj string properti context cx scriptabl sobj to object or null cx obj if sobj null throw undef read error obj properti return get object prop sobj properti cx 
public static object get object prop scriptabl obj string properti context cx if obj instanceof xmlobject xmlobject xml object xmlobject obj return xml object ecma get cx properti object result scriptabl object get properti obj properti if result scriptabl not found result undefin instanc return result 
public static object get object index object obj doubl dbl index context cx scriptabl sobj to object or null cx obj if sobj null throw undef read error obj to string dbl index int index int dbl index if doubl index dbl index return get object index sobj index cx els string s to string dbl index return get object prop sobj s cx 
public static object get object index scriptabl obj int index context cx if obj instanceof xmlobject xmlobject xml object xmlobject obj return xml object ecma get cx new integ index object result scriptabl object get properti obj index if result scriptabl not found result undefin instanc return result 
public static object set object elem object obj object elem object valu context cx scriptabl sobj to object or null cx obj if sobj null throw undef write error obj elem valu return set object elem sobj elem valu cx 
public static object set object elem scriptabl obj object elem object valu context cx if obj instanceof xmlobject xmlobject xml object xmlobject obj xml object ecma put cx elem valu return valu string s to string id or index cx elem if s null int index last index result cx scriptabl object put properti obj index valu els scriptabl object put properti obj s valu return valu 
version of set object elem when elem is a valid js identifi name public static object set object prop object obj string properti object valu context cx scriptabl sobj to object or null cx obj if sobj null throw undef write error obj properti valu return set object prop sobj properti valu cx 
public static object set object prop scriptabl obj string properti object valu context cx if obj instanceof xmlobject xmlobject xml object xmlobject obj xml object ecma put cx properti valu els scriptabl object put properti obj properti valu return valu 
public static object set object index object obj doubl dbl index object valu context cx scriptabl sobj to object or null cx obj if sobj null throw undef write error obj string valu of dbl index valu int index int dbl index if doubl index dbl index return set object index sobj index valu cx els string s to string dbl index return set object prop sobj s valu cx 
public static object set object index scriptabl obj int index object valu context cx if obj instanceof xmlobject xmlobject xml object xmlobject obj xml object ecma put cx new integ index valu els scriptabl object put properti obj index valu return valu 
public static boolean delet object elem scriptabl target object elem context cx boolean result if target instanceof xmlobject xmlobject xml object xmlobject target result xml object ecma delet cx elem els string s to string id or index cx elem if s null int index last index result cx result scriptabl object delet properti target index els result scriptabl object delet properti target s return result 
public static boolean ha object elem scriptabl target object elem context cx boolean result if target instanceof xmlobject xmlobject xml object xmlobject target result xml object ecma ha cx elem els string s to string id or index cx elem if s null int index last index result cx result scriptabl object ha properti target index els result scriptabl object ha properti target s return result 
public static object ref get ref ref context cx return ref get cx 
public static object ref set ref ref object valu context cx return ref set cx valu 
public static object ref del ref ref context cx return wrap boolean ref delet cx 
static boolean is special properti string s return s equal proto s equal parent 
public static ref special ref object obj string special properti context cx return special ref creat special cx obj special properti 
the delet oper see ecma 11 4 1 in ecma 0 19 the descript of the delet oper 11 4 1 assum that the delet method return a valu howev the definit of the delet oper 8 6 2 5 doe not defin a return valu here we assum that the delet method doesn t return a valu public static object delet object obj object id context cx scriptabl sobj to object or null cx obj if sobj null string id str id null null id to string throw type error2 msg undef prop delet to string obj id str boolean result delet object elem sobj id cx return wrap boolean result 
look up a name in the scope chain and return it valu public static object name context cx scriptabl scope string name scriptabl parent scope get parent scope if parent null object result top scope name cx scope name if result scriptabl not found throw not found error scope name return result return name or function cx scope parent name fals 
privat static object name or function context cx scriptabl scope scriptabl parent scope string name boolean as function call object result scriptabl thi obj scope it is us onli if as function call true xmlobject first xmlobject null for if scope instanceof nativ with scriptabl with obj scope get prototyp if with obj instanceof xmlobject xmlobject xml obj xmlobject with obj if xml obj ecma ha cx name function thi should be the target object of with thi obj xml obj result xml obj ecma get cx name break if first xmlobject null first xmlobject xml obj els result scriptabl object get properti with obj name if result scriptabl not found function thi should be the target object of with thi obj with obj break els if scope instanceof nativ call nativ call doe not prototyp chain and scriptabl get can be call directli result scope get name scope if result scriptabl not found if as function call ecma 262 requir that thi for nest funtion should be top scope thi obj scriptabl object get top level scope parent scope break els can happen if rhino embed decid that nest scope ar us for what ever reason result scriptabl object get properti scope name if result scriptabl not found thi obj scope break scope parent scope parent scope parent scope get parent scope if parent scope null result top scope name cx scope name if result scriptabl not found if first xmlobject null as function call throw not found error scope name the name wa not found but we did find an xml object in the scope chain and we ar look for name not function the result should be an empti xmllist in name context result first xmlobject ecma get cx name for top scope thi obj for function is alwai scope itself thi obj scope break if as function call if result instanceof callabl throw not function error result name store scriptabl cx thi obj return result 
privat static object top scope name context cx scriptabl scope string name if cx us dynam scope scope check dynam scope cx top call scope scope return scriptabl object get properti scope name 
return the object in the scope chain that ha a given properti the order of evalu of an assign express involv evalu the lh to a refer evalu the rh and then modifi the refer with the rh valu thi method is us to bind the given name to an object contain that properti so that the side effect of evalu the rh do not affect which properti is modifi typic us in conjunct with set name see ecma 10 1 4 public static scriptabl bind context cx scriptabl scope string id scriptabl first xmlobject null scriptabl parent scope get parent scope child scope check if parent null check for possibl nest with scope first while scope instanceof nativ with scriptabl with obj scope get prototyp if with obj instanceof xmlobject xmlobject xml object xmlobject with obj if xml object ecma ha cx id return xml object if first xmlobject null first xmlobject xml object els if scriptabl object ha properti with obj id return with obj scope parent parent parent get parent scope if parent null break child scope check for if scriptabl object ha properti scope id return scope scope parent parent parent get parent scope if parent null break child scope check scope here is top scope if cx us dynam scope scope check dynam scope cx top call scope scope if scriptabl object ha properti scope id return scope noth wa found but sinc xml object alwai bind return on if found return first xmlobject 
public static object set name scriptabl bound object valu context cx scriptabl scope string id if bound null if bound instanceof xmlobject xmlobject xml object xmlobject bound xml object ecma put cx id valu els scriptabl object put properti bound id valu els newnam 7 where newnam ha not yet been defin creat a new properti in the top scope unless strict mode is specifi if cx ha featur context featur strict var throw context report runtim error1 msg assn creat strict id find the top scope by walk up the scope chain bound scriptabl object get top level scope scope if cx us dynam scope bound check dynam scope cx top call scope bound bound put id bound valu return valu 
public static object enum init object valu context cx boolean enum valu id enumer x new id enumer x obj to object or null cx valu if x obj null null or undefin do not caus error but rather lead to empti for in loop x enum valu enum valu enum init should read all initi id befor return or for a i in a would wrongli enumer i in a as well enum chang object x return x 
public static boolean enum next object enum obj opt thi could be more effici boolean result id enumer x id enumer enum obj for if x obj null result fals break if x index x id length x obj x obj get prototyp enum chang object x continu object id x id x index if x us null x us ha id continu if id instanceof string string str id string id if x obj ha str id x obj continu must have been delet x current id str id els int int id number id int valu if x obj ha int id x obj continu must have been delet x current id string valu of int id result true break return wrap boolean result 
public static object enum id object enum obj context cx id enumer x id enumer enum obj if x enum valu return x current id object result string s to string id or index cx x current id if s null int index last index result cx result x obj get index x obj els result x obj get s x obj return result 
privat static void enum chang object id enumer x object id null while x obj null id x obj get id if id length 0 break x obj x obj get prototyp if x obj null x id null object previou x id int l previou length if x us null x us new obj to int map l for int i 0 i l i x us intern previou i x id id x index 0 
prepar for call name return function correspond to name and make current top scope avail as script runtim last store scriptabl for consumpt as thi obj the caller must call script runtim last store scriptabl immedi after call thi method public static callabl get name function and thi string name context cx scriptabl scope scriptabl parent scope get parent scope if parent null object result top scope name cx scope name if result instanceof callabl if result scriptabl not found throw not found error scope name els throw not function error result name top scope is not nativ with or nativ call thi obj scope scriptabl thi obj scope store scriptabl cx thi obj return callabl result name will call store scriptabl cx thi obj return callabl name or function cx scope parent name true 
prepar for call obj id return function correspond to obj id and make obj properli convert to scriptabl avail as script runtim last store scriptabl for consumpt as thi obj the caller must call script runtim last store scriptabl immedi after call thi method public static callabl get elem function and thi object obj object elem context cx string s to string id or index cx elem if s null return get prop function and thi obj s cx int index last index result cx scriptabl thi obj to object or null cx obj if thi obj null throw undef call error obj string valu of index object valu for ignor xml lookup as requr by ecma 357 11 2 2 1 valu scriptabl object get properti thi obj index if valu scriptabl not found break if thi obj instanceof xmlobject break xmlobject xml object xmlobject thi obj scriptabl extra xml object get extra method sourc cx if extra null break thi obj extra if valu instanceof callabl throw not function error valu elem store scriptabl cx thi obj return callabl valu 
prepar for call obj properti return function correspond to obj properti and make obj properli convert to scriptabl avail as script runtim last store scriptabl for consumpt as thi obj the caller must call script runtim last store scriptabl immedi after call thi method public static callabl get prop function and thi object obj string properti context cx scriptabl thi obj to object or null cx obj if thi obj null throw undef call error obj properti object valu for ignor xml lookup as requr by ecma 357 11 2 2 1 valu scriptabl object get properti thi obj properti if valu scriptabl not found break if thi obj instanceof xmlobject break xmlobject xml object xmlobject thi obj scriptabl extra xml object get extra method sourc cx if extra null break thi obj extra if valu instanceof callabl throw not function error valu properti store scriptabl cx thi obj return callabl valu 
prepar for call express return function correspond to express and make parent scope of the function avail as script runtim last store scriptabl for consumpt as thi obj the caller must call script runtim last store scriptabl immedi after call thi method public static callabl get valu function and thi object valu context cx if valu instanceof callabl throw not function error valu callabl f callabl valu scriptabl thi obj if f instanceof scriptabl thi obj scriptabl f get parent scope els if cx top call scope null throw new illeg state except thi obj cx top call scope if thi obj get parent scope null if thi obj instanceof nativ with function defin insid with should have with target as their thi obj els if thi obj instanceof nativ call nest function should have top scope as their thi obj thi obj scriptabl object get top level scope thi obj store scriptabl cx thi obj return f 
perform function call in refer context should alwai return valu that can be pass to link ref get object or link ref set object object arbitrari number of time the arg arrai refer should not be store in ani object that is can be gc reachabl after thi method return if thi is necessari store arg clone not arg arrai itself public static ref call ref callabl function scriptabl thi obj object arg context cx if function instanceof ref callabl ref callabl rfunction ref callabl function ref ref rfunction ref call cx thi obj arg if ref null throw new illeg state except rfunction get class get name ref call return null return ref no runtim support for now string msg get message1 msg no ref from function to string function throw construct error refer error msg 
oper new see ecma 11 2 2 public static scriptabl new object object fun context cx scriptabl scope object arg if fun instanceof function throw not function error fun function function function fun return function construct cx scope arg 
public static object call special context cx callabl fun scriptabl thi obj object arg scriptabl scope scriptabl caller thi int call type string filenam int line number if call type node specialcal eval if nativ global is eval function fun return eval special cx scope caller thi arg filenam line number els if call type node specialcal with if nativ with is with function fun throw context report runtim error1 msg onli from new with els throw kit code bug return fun call cx scope thi obj arg 
public static object new special context cx object fun object arg scriptabl scope int call type if call type node specialcal eval if nativ global is eval function fun throw type error1 msg not ctor eval els if call type node specialcal with if nativ with is with function fun return nativ with new with special cx scope arg els throw kit code bug return new object fun cx scope arg 
function prototyp appli and function prototyp call see ecma 15 3 4 34 public static object appli or call boolean is appli context cx scriptabl scope scriptabl thi obj object arg int l arg length callabl function if thi obj instanceof callabl function callabl thi obj els object valu thi obj get default valu script runtim function class if valu instanceof callabl throw script runtim not function error valu thi obj function callabl valu scriptabl call thi null if l 0 call thi to object or null cx arg 0 if call thi null thi cover the case of arg 0 null undefin as well call thi get top call scope cx object call arg if is appli follow ecma 15 3 4 3 if l 1 call arg script runtim empti arg els object arg1 arg 1 if arg1 null arg1 undefin instanc call arg script runtim empti arg els if arg1 instanceof nativ arrai arg1 instanceof argument call arg cx get element scriptabl arg1 els throw script runtim type error0 msg arg isnt arrai els follow ecma 15 3 4 4 if l 1 call arg script runtim empti arg els call arg new object l 1 system arraycopi arg 1 call arg 0 l 1 return function call cx scope call thi call arg 
the eval function properti of the global object see ecma 15 1 2 1 public static object eval special context cx scriptabl scope object thi arg object arg string filenam int line number if arg length 1 return undefin instanc object x arg 0 if x instanceof string if cx ha featur context featur strict eval throw context report runtim error0 msg eval nonstr strict string messag script runtim get message0 msg eval nonstr context report warn messag return x if filenam null int linep new int 1 filenam context get sourc posit from stack linep if filenam null line number linep 0 els filenam string sourc name script runtim make url for gener script true filenam line number error report report report default error report for eval cx get error report compil with explicit interpret instanc to forc interpret mode script script cx compil string string x new interpret report sourc name 1 null interpret function script idata eval script flag true callabl c callabl script return c call cx scope scriptabl thi arg script runtim empti arg 
the typeof oper public static string typeof object valu if valu null return object if valu undefin instanc return undefin if valu instanceof scriptabl if valu instanceof xmlobject return xml return valu instanceof callabl function object if valu instanceof string return string if valu instanceof number return number if valu instanceof boolean return boolean throw error with class name msg invalid type valu 
the typeof oper that correctli handl the undefin case public static string typeof name scriptabl scope string id context cx context get context scriptabl val bind cx scope id if val null return undefin return typeof get object prop val id cx 
public static object add object val1 object val2 context cx if val1 instanceof number val2 instanceof number return wrap number number val1 doubl valu number val2 doubl valu if val1 instanceof xmlobject object test xmlobject val1 add valu cx true val2 if test scriptabl not found return test if val2 instanceof xmlobject object test xmlobject val2 add valu cx fals val1 if test scriptabl not found return test if val1 instanceof scriptabl val1 scriptabl val1 get default valu null if val2 instanceof scriptabl val2 scriptabl val2 get default valu null if val1 instanceof string val2 instanceof string if val1 instanceof number val2 instanceof number return wrap number number val1 doubl valu number val2 doubl valu els return wrap number to number val1 to number val2 return to string val1 concat to string val2 
public static object name incr decr scriptabl scope chain string id int incr decr mask scriptabl target object valu search do target scope chain do valu target get id scope chain if valu scriptabl not found break search target target get prototyp while target null scope chain scope chain get parent scope while scope chain null throw not found error scope chain id return do scriptabl incr decr target id scope chain valu incr decr mask 
public static object prop incr decr object obj string id context cx int incr decr mask scriptabl start to object or null cx obj if start null throw undef read error obj id scriptabl target start object valu search do valu target get id start if valu scriptabl not found break search target target get prototyp while target null start put id start na nobj return na nobj return do scriptabl incr decr target id start valu incr decr mask 
privat static object do scriptabl incr decr scriptabl target string id scriptabl proto chain start object valu int incr decr mask boolean post incr decr mask node post flag 0 doubl number if valu instanceof number number number valu doubl valu els number to number valu if post convert result to number valu wrap number number if incr decr mask node decr flag 0 number els number number result wrap number number target put id proto chain start result if post return valu els return result 
public static object elem incr decr object obj object index context cx int incr decr mask object valu get object elem obj index cx boolean post incr decr mask node post flag 0 doubl number if valu instanceof number number number valu doubl valu els number to number valu if post convert result to number valu wrap number number if incr decr mask node decr flag 0 number els number number result wrap number number set object elem obj index result cx if post return valu els return result 
public static object ref incr decr ref ref context cx int incr decr mask object valu ref get cx boolean post incr decr mask node post flag 0 doubl number if valu instanceof number number number valu doubl valu els number to number valu if post convert result to number valu wrap number number if incr decr mask node decr flag 0 number els number number result wrap number number ref set cx result if post return valu els return result 
privat static object to primit object val if val instanceof scriptabl return val scriptabl s scriptabl val object result s get default valu null if result instanceof scriptabl throw type error0 msg bad default valu return result 
equal see ecma 11 9 public static boolean eq object x object y if x null x undefin instanc if y null y undefin instanc return true if y instanceof scriptabl object object test scriptabl object y equival valu x if test scriptabl not found return boolean test boolean valu return fals els if x instanceof number return eq number number x doubl valu y els if x instanceof string return eq string string x y els if x instanceof boolean boolean b boolean x boolean valu if y instanceof boolean return b boolean y boolean valu if y instanceof scriptabl object object test scriptabl object y equival valu x if test scriptabl not found return boolean test boolean valu return eq number b 1 0 0 0 y els if x instanceof scriptabl if y instanceof scriptabl if x y return true if x instanceof scriptabl object object test scriptabl object x equival valu y if test scriptabl not found return boolean test boolean valu if y instanceof scriptabl object object test scriptabl object y equival valu x if test scriptabl not found return boolean test boolean valu if x instanceof wrapper y instanceof wrapper return wrapper x unwrap wrapper y unwrap return fals els if y instanceof boolean if x instanceof scriptabl object object test scriptabl object x equival valu y if test scriptabl not found return boolean test boolean valu doubl d boolean y boolean valu 1 0 0 0 return eq number d x els if y instanceof number return eq number number y doubl valu x els if y instanceof string return eq string string y x cover the case when y undefin instanc as well return fals els warn about non jsobject x return x y 
static boolean eq number doubl x object y for if y null y undefin instanc return fals els if y instanceof number return x number y doubl valu els if y instanceof string return x to number y els if y instanceof boolean return x boolean y boolean valu 1 0 0 0 els if y instanceof scriptabl if y instanceof scriptabl object object xval wrap number x object test scriptabl object y equival valu xval if test scriptabl not found return boolean test boolean valu y to primit y els warn about non jsobject y return fals 
privat static boolean eq string string x object y for if y null y undefin instanc return fals els if y instanceof string return x equal y els if y instanceof number return to number x number y doubl valu els if y instanceof boolean return to number x boolean y boolean valu 1 0 0 0 els if y instanceof scriptabl if y instanceof scriptabl object object test scriptabl object y equival valu x if test scriptabl not found return boolean test boolean valu y to primit y continu els warn about non jsobject y return fals 
public static boolean shallow eq object x object y if x y if x instanceof number return true na n check doubl d number x doubl valu return d d if x null x undefin instanc return fals els if x instanceof number if y instanceof number return number x doubl valu number y doubl valu els if x instanceof string if y instanceof string return x equal y els if x instanceof boolean if y instanceof boolean return x equal y els if x instanceof scriptabl if x instanceof wrapper y instanceof wrapper return wrapper x unwrap wrapper y unwrap els warn about non jsobject x return x y return fals 
the instanceof oper return a instanceof b public static boolean instanc of object a object b context cx check rh is an object if b instanceof scriptabl throw type error0 msg instanceof not object for primit valu on lh return fals xxx we mai want to chang thi so that 5 instanceof number true if a instanceof scriptabl return fals return scriptabl b ha instanc scriptabl a 
deleg to return true iff rh appear in lh proto chain protect static boolean js deleg to scriptabl lh scriptabl rh scriptabl proto lh get prototyp while proto null if proto equal rh return true proto proto get prototyp return fals 
the in oper thi is a new js 1 3 languag featur the in oper mirror the oper of the for in construct and test whether the rh ha the properti given by the lh it is differ from the for in construct in that br it doesn t perform to object on the right hand side br it return true for dont enum properti param a the left hand operand param b the right hand operand return true if properti name or element number a is a properti of b public static boolean in object a object b context cx if b instanceof scriptabl throw type error0 msg instanceof not object return ha object elem scriptabl b a cx 
public static boolean cmp lt object val1 object val2 doubl d1 d2 if val1 instanceof number val2 instanceof number d1 number val1 doubl valu d2 number val2 doubl valu els if val1 instanceof scriptabl val1 scriptabl val1 get default valu number class if val2 instanceof scriptabl val2 scriptabl val2 get default valu number class if val1 instanceof string val2 instanceof string return string val1 compar to string val2 0 d1 to number val1 d2 to number val2 return d1 d2 
public static boolean cmp le object val1 object val2 doubl d1 d2 if val1 instanceof number val2 instanceof number d1 number val1 doubl valu d2 number val2 doubl valu els if val1 instanceof scriptabl val1 scriptabl val1 get default valu number class if val2 instanceof scriptabl val2 scriptabl val2 get default valu number class if val1 instanceof string val2 instanceof string return string val1 compar to string val2 0 d1 to number val1 d2 to number val2 return d1 d2 
public static scriptabl object get global context cx final string global class org mozilla javascript tool shell global class global class kit class or null global class if global class null try class parm script runtim context class constructor global class ctor global class get constructor parm object arg cx return scriptabl object global class ctor new instanc arg catch except e fall through return new import top level cx 
public static boolean ha top call context cx return cx top call scope null 
public static scriptabl get top call scope context cx scriptabl scope cx top call scope if scope null throw new illeg state except return scope 
public static object do top call callabl callabl context cx scriptabl scope scriptabl thi obj object arg if scope null throw new illeg argument except if cx top call scope null throw new illeg state except object result cx top call scope scriptabl object get top level scope scope cx us dynam scope cx ha featur context featur dynam scope context factori f cx get factori try result f do top call callabl cx scope thi obj arg final cx top call scope null cleanup cach refer cx cach xmllib null if cx current activ call null function should alwai call exit activ function if it creat activ record throw new illeg state except return result 
return tt possibl dynam scope tt if tt static top scope tt is present on it prototyp chain and return tt static top scope tt otherwis should onli be call when tt static top scope tt is top scope static scriptabl check dynam scope scriptabl possibl dynam scope scriptabl static top scope return cx top call scope if scope if possibl dynam scope static top scope return possibl dynam scope scriptabl proto possibl dynam scope for proto proto get prototyp if proto static top scope return possibl dynam scope if proto null return static top scope 
public static void init script nativ function fun obj scriptabl thi obj context cx scriptabl scope boolean eval script if cx top call scope null throw new illeg state except int var count fun obj get param and var count if var count 0 scriptabl var scope scope never defin ani variabl from var statement insid with object see bug 38590 while var scope instanceof nativ with var scope var scope get parent scope for int i var count i 0 string name fun obj get param or var name i don t overwrit exist def if alreadi defin in object or prototyp of object if scriptabl object ha properti scope name if eval script global var definit ar suppos to be dontdelet scriptabl object defin properti var scope name undefin instanc scriptabl object perman els var scope put name var scope undefin instanc 
public static scriptabl creat function activ nativ function fun obj scriptabl scope object arg return new nativ call fun obj scope arg 
public static void enter activ function context cx scriptabl activ if cx top call scope null throw new illeg state except nativ call call nativ call activ call parent activ call cx current activ call cx current activ call call 
public static void exit activ function context cx nativ call call cx current activ call cx current activ call call parent activ call call parent activ call null 
static nativ call find function activ context cx function f nativ call call cx current activ call while call null if call function f return call call call parent activ call return null 
public static scriptabl new catch scope throwabl t scriptabl last catch scope string except name context cx scriptabl scope object obj boolean cach obj get obj if t instanceof java script except cach obj fals obj java script except t get valu els cach obj true creat wrapper object unless it wa associ with the previou scope object if last catch scope null nativ object last nativ object last catch scope obj last get associ valu t if obj null kit code bug break get obj rhino except re string error name string error msg throwabl java except null if t instanceof ecma error ecma error ee ecma error t re ee error name ee get name error msg ee get error messag els if t instanceof wrap except wrap except we wrap except t re we java except we get wrap except error name java except error msg java except get class get name java except get messag els if t instanceof evalu except pure evalu except nor wrap except instanc evalu except ee evalu except t re ee error name intern error error msg ee get messag els script can catch onli instanc of java script except ecma error and evalu except throw kit code bug string sourc uri re sourc name if sourc uri null sourc uri int line re line number object arg if line 0 arg new object error msg sourc uri new integ line els arg new object error msg sourc uri scriptabl error object cx new object scope error name arg scriptabl object put properti error object name error name if java except null object wrap cx get wrap factori wrap cx scope java except null scriptabl object defin properti error object java except wrap scriptabl object perman scriptabl object readonli if re null object wrap cx get wrap factori wrap cx scope re null scriptabl object defin properti error object rhino except wrap scriptabl object perman scriptabl object readonli obj error object nativ object catch scope object new nativ object see ecma 12 4 catch scope object defin properti except name obj scriptabl object perman if cach obj catch scope object associ valu t obj return catch scope object 
public static scriptabl enter with object obj context cx scriptabl scope scriptabl sobj to object or null cx obj if sobj null throw type error1 msg undef with to string obj if sobj instanceof xmlobject xmlobject xml object xmlobject sobj return xml object enter with scope return new nativ with scope sobj 
public static scriptabl leav with scriptabl scope nativ with nw nativ with scope return nw get parent scope 
public static scriptabl enter dot queri object valu scriptabl scope if valu instanceof xmlobject throw not xml error valu xmlobject object xmlobject valu return object enter dot queri scope 
public static object updat dot queri boolean valu scriptabl scope return null to continu loop nativ with nw nativ with scope return nw updat dot queri valu 
public static scriptabl leav dot queri scriptabl scope nativ with nw nativ with scope return nw get parent scope 
public static void set function proto and parent base function fn scriptabl scope fn set parent scope scope fn set prototyp scriptabl object get function prototyp scope 
public static void set object proto and parent scriptabl object object scriptabl scope compar with function it alwai set the scope to top scope scope scriptabl object get top level scope scope object set parent scope scope scriptabl proto scriptabl object get class prototyp scope object get class name object set prototyp proto 
public static void init function context cx scriptabl scope nativ function function int type boolean from eval code if type function node function statement string name function get function name if name null name length 0 if from eval code ecma specifi that function defin in global and function scope outsid eval should have dontdelet set scriptabl object defin properti scope name function scriptabl object perman els scope put name scope function els if type function node function express statement string name function get function name if name null name length 0 alwai put function express statement into initi activ object ignor the with statement to follow spider monkei while scope instanceof nativ with scope scope get parent scope scope put name scope function els throw kit code bug 
public static scriptabl new arrai liter object object int skip indexc context cx scriptabl scope int count object length int skip count 0 if skip indexc null skip count skip indexc length int length count skip count integ length obj new integ length scriptabl arrai obj if the version is 120 then new arrai 4 mean creat a new arrai with 4 as the first element in thi case we have to set length properti manual if cx get languag version context version 1 2 arrai obj cx new object scope arrai script runtim empti arg scriptabl object put properti arrai obj length length obj els arrai obj cx new object scope arrai new object length obj int skip 0 for int i 0 j 0 i length i if skip skip count skip indexc skip i skip continu scriptabl object put properti arrai obj i object j j return arrai obj 
public static scriptabl new object liter object properti id object properti valu context cx scriptabl scope scriptabl object cx new object scope for int i 0 end properti id length i end i object id properti id i object valu properti valu i if id instanceof string scriptabl object put properti object string id valu els int index integ id int valu scriptabl object put properti object index valu return object 
public static boolean is arrai object object obj return obj instanceof nativ arrai obj instanceof argument 
public static object get arrai element scriptabl object context cx context get context long long len nativ arrai get length properti cx object if long len integ max valu arrai beyond max int is not in java in ani case throw new illeg argument except int len int long len if len 0 return script runtim empti arg els object result new object len for int i 0 i len i object elem scriptabl object get properti object i result i elem scriptabl not found undefin instanc elem return result 
static void check deprec context cx string name int version cx get languag version if version context version 1 4 version context version default string msg get message1 msg deprec ctor name if version context version default context report warn msg els throw context report runtim error msg 
public static string get message0 string messag id return get messag messag id null 
public static string get message1 string messag id object arg1 object argument arg1 return get messag messag id argument 
public static string get message2 string messag id object arg1 object arg2 object argument arg1 arg2 return get messag messag id argument 
public static string get message3 string messag id object arg1 object arg2 object arg3 object argument arg1 arg2 arg3 return get messag messag id argument 
public static string get message4 string messag id object arg1 object arg2 object arg3 object arg4 object argument arg1 arg2 arg3 arg4 return get messag messag id argument 
public static string get messag string messag id object argument final string default resourc org mozilla javascript resourc messag context cx context get current context local local cx null cx get local local get default resourc bundl doe cach resourc bundl rb resourc bundl get bundl default resourc local string format string try format string rb get string messag id catch java util miss resourc except mre throw new runtim except no messag resourc found for messag properti messag id it s ok to format the string even if argument is null we need to format it anywai to make doubl s collaps to singl s todo messag format is not avail on p java messag format formatt new messag format format string return formatt format argument 
public static ecma error construct error string error string messag int linep new int 1 string filenam context get sourc posit from stack linep return construct error error messag filenam linep 0 null 0 
public static ecma error construct error string error string messag string sourc name int line number string line sourc int column number return new ecma error error messag sourc name line number line sourc column number 
public static ecma error type error string messag return construct error type error messag 
public static ecma error type error0 string messag id string msg get message0 messag id return type error msg 
public static ecma error type error1 string messag id string arg1 string msg get message1 messag id arg1 return type error msg 
public static ecma error type error2 string messag id string arg1 string arg2 string msg get message2 messag id arg1 arg2 return type error msg 
public static ecma error type error3 string messag id string arg1 string arg2 string arg3 string msg get message3 messag id arg1 arg2 arg3 return type error msg 
public static runtim except undef read error object object object id string id str id null null id to string return type error2 msg undef prop read to string object id str 
public static runtim except undef call error object object object id string id str id null null id to string return type error2 msg undef method call to string object id str 
public static runtim except undef write error object object object id object valu string id str id null null id to string string valu str valu instanceof scriptabl valu to string to string valu return type error3 msg undef prop write to string object id str valu str 
public static runtim except not found error scriptabl object string properti xxx us object to improv the error messag string msg get message1 msg is not defin properti throw construct error refer error msg 
public static runtim except not function error object valu return not function error valu valu 
public static runtim except not function error object valu object messag helper xxx us valu for better error report string msg messag helper null null messag helper to string if valu scriptabl not found return type error1 msg function not found msg return type error2 msg isnt function msg valu null null valu get class get name 
privat static runtim except not xml error object valu throw type error1 msg isnt xml object script runtim to string valu 
privat static void warn about non jsobject object non jsobject string messag rhino usag warn miss context java to js convers n rhino runtim detect object non jsobject of class non jsobject get class get name where it expect string number boolean or scriptabl instanc pleas check your code for miss context java to js call context report warn messag just to be sure that it would be notic system err println messag 
public static reg exp proxi get reg exp proxi context cx return cx get reg exp proxi 
public static void set reg exp proxi context cx reg exp proxi proxi if proxi null throw new illeg argument except cx reg exp proxi proxi 
public static reg exp proxi check reg exp proxi context cx reg exp proxi result get reg exp proxi cx if result null throw context report runtim error0 msg no regexp return result 
privat static xmllib current xmllib context cx script should be run to access thi if cx top call scope null throw new illeg state except xmllib xml lib cx cach xmllib if xml lib null xml lib xmllib extract from scope cx top call scope if xml lib null throw new illeg state except cx cach xmllib xml lib return xml lib 
escap the reserv charact in a valu of an attribut param valu unescap text return the escap text public static string escap attribut valu object valu context cx xmllib xml lib current xmllib cx return xml lib escap attribut valu valu 
escap the reserv charact in a valu of a text node param valu unescap text return the escap text public static string escap text valu object valu context cx xmllib xml lib current xmllib cx return xml lib escap text valu valu 
public static ref member ref object obj object elem context cx int member type flag if obj instanceof xmlobject throw not xml error obj xmlobject xml object xmlobject obj return xml object member ref cx elem member type flag 
public static ref member ref object obj object namespac object elem context cx int member type flag if obj instanceof xmlobject throw not xml error obj xmlobject xml object xmlobject obj return xml object member ref cx namespac elem member type flag 
public static ref name ref object name context cx scriptabl scope int member type flag xmllib xml lib current xmllib cx return xml lib name ref cx name scope member type flag 
public static ref name ref object namespac object name context cx scriptabl scope int member type flag xmllib xml lib current xmllib cx return xml lib name ref cx namespac name scope member type flag 
privat static void store index result context cx int index cx scratch index index 
static int last index result context cx return cx scratch index 
public static void store uint32result context cx long valu if valu 32 0 throw new illeg argument except cx scratch uint32 valu 
public static long last uint32result context cx long valu cx scratch uint32 if valu 32 0 throw new illeg state except return valu 
privat static void store scriptabl context cx scriptabl valu the previosli store scratch scriptabl should be consum if cx scratch scriptabl null throw new illeg state except cx scratch scriptabl valu 
public static scriptabl last store scriptabl context cx scriptabl result cx scratch scriptabl cx scratch scriptabl null return result 
static string make url for gener script boolean is eval string master script url int master script line if is eval return master script url master script line eval els return master script url master script line function 
static boolean is gener script string sourc url alert thi mai clash with a valid url contain eval or function return sourc url index of eval 0 sourc url index of function 0 
privat static runtim except error with class name string msg object val return context report runtim error1 msg val get class get name 
implement gener class loader public defin class loader thi parent loader get class get class loader 
public defin class loader class loader parent loader thi parent loader parent loader 
public class defin class string name byte data return super defin class name data 0 data length 
public void link class class cl resolv class cl 
public class load class string name boolean resolv throw class not found except class cl find load class name if cl null if parent loader null cl parent loader load class name els cl find system class name if resolv resolv class cl return cl 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public class data type 018 extend live connect test public data type 018 super 
public static void main string arg data type 018 test new data type 018 test start 
public void setup test environ super setup test environ global eval var dt packag com netscap javascript qa liveconnect data type class global eval var dt new dt file bugnumb 301981 p bugnumb file bugnumb 
public void execut test p execut test string expect field valu field string expect method valu method string actual field valu string actual method valu string ambigu refer am iafield or amethod try from java script call the setter actual field valu string global eval dt ambigu refer actual method valu string global eval dt ambigu refer catch except e e print stack trace file except e to string actual field valu actual method valu add test case dt ambigu refer expect field valu actual field valu file except add test case dt ambigu refer expect method valu actual method valu file except 
public class data type class constructor stuff public data type class pub int constructor arg constructor arg none 
instanc setter public data type class boolean b pub int constructor arg constructor arg boolean 
pub int constructor arg constructor arg boolean public data type class boolean b pub int constructor arg constructor arg boolean object 
pub int constructor arg constructor arg boolean object public data type class byte b pub int constructor arg constructor arg byte 
pub int constructor arg constructor arg byte public data type class byte b pub int constructor arg constructor arg byte object 
pub int constructor arg constructor arg byte object public data type class integ i pub int constructor arg constructor arg integ object 
pub int constructor arg constructor arg integ object public data type class int i pub int constructor arg constructor arg int 
pub int constructor arg constructor arg int public data type class doubl d pub int constructor arg constructor arg doubl object 
pub int constructor arg constructor arg doubl object public data type class doubl d pub int constructor arg constructor arg doubl 
pub int constructor arg constructor arg doubl public data type class float f pub int constructor arg constructor arg float object 
pub int constructor arg constructor arg float object public data type class float f pub int constructor arg constructor arg float 
pub int constructor arg constructor arg float public data type class long l pub int constructor arg constructor arg long object 
pub int constructor arg constructor arg long object public data type class long l pub int constructor arg constructor arg long 
pub int constructor arg constructor arg long public data type class short s pub int constructor arg constructor arg short object 
pub int constructor arg constructor arg short object public data type class short s pub int constructor arg constructor arg short 
pub int constructor arg constructor arg short public data type class string s pub int constructor arg constructor arg string 
pub int constructor arg constructor arg string public data type class object o pub int constructor arg constructor arg object 
pub int constructor arg constructor arg object public data type class char c pub int constructor arg constructor arg char 
pub int constructor arg constructor arg char public data type class charact c pub int constructor arg constructor arg char object 
pub int constructor arg constructor arg char object public data type class byte b pub int constructor arg constructor arg byte arrai 
public static doubl pub doubl represent 0 2134 public doubl doubl valu return pub doubl represent 
public int to number return pub number represent 
public boolean boolean valu return pub boolean represent 
overrid to string public string to string return pub string represent 
have a method that ha the same name as a field public string am iafield or amethod return method 
public string am iafield or amethod field public static boolean static get boolean return pub static boolean 
return pub static boolean public static boolean static get boolean object return pub static boolean object 
public static byte static get byte return pub static byte 
return pub static byte public static byte static get byte object return pub static byte object 
public static integ static get integ object return pub static integ object 
return pub static integ object public static int static get integ return new integ pub static int int valu 
public static doubl static get doubl object return pub static doubl object 
public static doubl static get doubl return new doubl pub static doubl doubl valu 
public static float static get float object return pub static float object 
public static float static get float return new float pub static float float valu 
public static long static get long object return pub static long object 
public static long static get long return new long pub static long long valu 
public static short static get short object return pub static short object 
public static short static get short return new short pub static short short valu 
public static string static get string object return pub static string 
public static char static get char return pub static char 
public static charact static get charact return pub static char object 
instanc getter public boolean get boolean return pub boolean 
return pub boolean public boolean get boolean object return pub boolean object 
public byte get byte return pub byte 
return pub byte public byte get byte object return pub byte object 
public integ get integ object return pub integ object 
return pub integ object public int get integ return new integ pub int int valu 
public doubl get doubl object return pub doubl object 
public doubl get doubl return new doubl pub doubl doubl valu 
public float get float object return pub float object 
public float get float return new float pub float float valu 
public long get long object return pub long object 
public long get long return new long pub long long valu 
public string get string object return pub string 
public object get object return pub object 
public short get short object return pub short object 
public short get short return new short pub short short valu 
public char get char return pub char 
public charact get charact return pub char object 
setter public static void static set boolean boolean b pub static boolean b 
pub static boolean b public static void static set boolean object boolean b pub static boolean object b 
public static void static set byte byte b pub static byte b 
pub static byte b public static void static set byte object byte b pub static byte object b 
public static void static set integ object integ i pub static integ object i 
pub static integ object i public static void static set integ int i pub static int i 
public static void static set doubl object doubl d pub static doubl object d 
public static void static set doubl doubl d pub static doubl d 
public static void static set float object float f pub static float object f 
public static void static set float float f pub static float f 
public static void static set long object long l pub static long object l 
public static void static set long long l pub static long l 
public static void static set short object short s pub static short object s 
public static void static set short short s pub static short s 
public static void static set string object string s pub static string s 
public static void static set char char c pub static char c 
public static void static set charact charact c pub static char object c 
instanc setter public void set boolean boolean b pub boolean b 
pub boolean b public void set boolean object boolean b pub boolean object b 
public void set byte byte b pub byte b 
pub byte b public void set byte object byte b pub byte object b 
public void set integ object integ i pub integ object i 
pub integ object i public void set integ int i pub int i 
public void set doubl object doubl d pub doubl object d 
public void set doubl doubl d pub doubl d 
public void set float object float f pub float object f 
public void set float float f pub float f 
public void set long object long l pub long object l 
public void set long long l pub long l 
public void set short object short s pub short object s 
public void set short short s pub short s 
public void set string object string s pub string s 
public void set object object o pub object o 
public void set char char c pub char c 
public void set charact charact c pub char object c 
public class pub class pub static final class public class instanc get class return pub class 
return pub class public void set class class c pub class c 
pub class c public class static get class return pub static class 
return pub static class public void static set class class c pub static class c 
static arrai public static byte static get byte arrai return pub static arrai byte 
return pub static arrai byte public static char static get char arrai return pub static arrai char 
return pub static arrai char public static doubl static get doubl arrai return pub static arrai doubl 
return pub static arrai doubl public static short static get short arrai return pub static arrai short 
return pub static arrai short public static long static get long arrai return pub static arrai long 
return pub static arrai long public static int static get int arrai return pub static arrai int 
return pub static arrai int public static float static get float arrai return pub static arrai float 
return pub static arrai float public static object static get object arrai return pub static arrai object 
instanc arrai public byte get byte arrai return pub static arrai byte 
return pub static arrai byte public char get char arrai return pub static arrai char 
return pub static arrai char public doubl get doubl arrai return pub static arrai doubl 
return pub static arrai doubl public short get short arrai return pub static arrai short 
return pub static arrai short public long get long arrai return pub static arrai long 
return pub static arrai long public int get int arrai return pub static arrai int 
return pub static arrai int public float get float arrai return pub static arrai float 
return pub static arrai float public object get object arrai return pub static arrai object 
instanc arrai setter public void set byte arrai byte b pub static arrai byte b 
pub static arrai byte b public void set char arrai char c pub static arrai char c 
pub static arrai char c public void set doubl arrai doubl d pub static arrai doubl d 
pub static arrai doubl d public void set short arrai short s pub static arrai short s 
pub static arrai short s public void set long arrai long l pub static arrai long l 
pub static arrai long l public void set int arrai int i pub static arrai int i 
pub static arrai int i public void set float arrai float f pub static arrai float f 
pub static arrai float f public void set object arrai object o pub static arrai object o 
constructor a new nav env public nav env test file f test suit s nav drv d thi file f thi suit s thi driver d thi open jsobject jsobject get window d thi window null thi window name js get random window name 
call by nav drv to run the current test file public synchron void run test int i 0 system out println file name try creat context file start time driver get current time system out println i execut test file system out println i if evalu successfulli system out println i pars result system out println i file end time driver get current time catch except e suit pass fals file pass fals file except file fail with except e 
creat a new java script context in thi case a navig window and return the jsobject associ with that window public object creat context system out println open window open eval window name window open window name window jsobject open get member window name return window 
open the current test file in the window by us live connect to set the window s locat href properti to a url where the test file can be found public object execut test file system out println execut test file try locat jsobject window get member locat system out println file name string s driver http path suit name file name locat set member href driver http path suit name file name evalu successfulli wait for complet catch except e system err println file name fail with except e file except e to string if file name end with n js thi file pass true evalu successfulli true els thi file pass fals thi suit pass fals evalu successfulli fals return null 
check the valu of the variabl complet which is set by the stop test function in each test if the stop test function is not call in 20 second the test fail neg test will still succe sinc the onerror handler should call the stop test function public boolean wait for complet int counter 0 if window get member complet to string equal true while window get member complet to string equal true try if counter 20 file pass fals file except test fail to complet system out println test fail to complet return fals system out println driver sleep 1000 counter catch except e system out println sleep fail e return fals return true 
us live connect to get the navig window s testcas properti which is defin in all test pars the testcas arrai and creat a new test case object for each test case object it find public synchron boolean pars result try jsobject testcas jsobject window get member testcas file total case number jsobject testcas get member length int valu system out println testcas length is file total case for int i 0 i file total case i jsobject tc jsobject jsobject testcas get slot i test case nc new test case tc get member pass null null tc get member pass to string tc get member name null null tc get member name to string tc get member descript null null tc get member descript to string tc get member expect null null tc get member expect to string tc get member actual null null tc get member actual to string tc get member reason null null tc get member reason to string file case vector add element nc if nc pass equal fals if file name end with n js thi file pass true els thi file pass fals thi suit pass fals catch except e system out println e file except e to string if file name end with n html file pass true els file pass fals suit pass fals if the file fail try to get the file s bugnumb if thi file pass fals try thi file bugnumb window get member bugnumb to string catch except e do noth return true 
close navig window public void close open eval window name close open eval delet window name 
gener a random window name so that each test is associ with a uniqu window public string get random window name return integ to string new doubl math random 100000 int valu 
creat a deleg prototyp thi constructor should onli be us for creat prototyp object of deleg see org mozilla javascript deleg construct public deleg 
creat a new deleg that forward request to a delege scriptabl object param obj the delege see org mozilla javascript scriptabl public deleg scriptabl obj thi obj obj 
crete new deleg instanc the default implement call thi get class new instanc see construct context cx scriptabl scope object arg protect deleg new instanc try return deleg thi get class new instanc catch except ex throw context throw as script runtim ex ex 
retriev the delege return the delege public scriptabl get delege return obj 
set the delege param obj the delege see org mozilla javascript scriptabl public void set delege scriptabl obj thi obj obj 
see org mozilla javascript scriptabl get class name public string get class name return obj get class name 
see org mozilla javascript scriptabl get public object get string name scriptabl start return obj get name start 
see org mozilla javascript scriptabl get public object get int index scriptabl start return obj get index start 
see org mozilla javascript scriptabl ha public boolean ha string name scriptabl start return obj ha name start 
see org mozilla javascript scriptabl ha public boolean ha int index scriptabl start return obj ha index start 
see org mozilla javascript scriptabl put public void put string name scriptabl start object valu obj put name start valu 
see org mozilla javascript scriptabl put public void put int index scriptabl start object valu obj put index start valu 
see org mozilla javascript scriptabl delet public void delet string name obj delet name 
see org mozilla javascript scriptabl delet public void delet int index obj delet index 
see org mozilla javascript scriptabl get prototyp public scriptabl get prototyp return obj get prototyp 
see org mozilla javascript scriptabl set prototyp public void set prototyp scriptabl prototyp obj set prototyp prototyp 
see org mozilla javascript scriptabl get parent scope public scriptabl get parent scope return obj get parent scope 
see org mozilla javascript scriptabl set parent scope public void set parent scope scriptabl parent obj set parent scope parent 
see org mozilla javascript scriptabl get id public object get id return obj get id 
note that thi method doe not get forward to the delege if the code hint code paramet is null code script runtim scriptabl class code or code script runtim function class code instead the object itself is return param hint the type hint return the default valu see org mozilla javascript scriptabl get default valu public object get default valu class hint return hint null hint script runtim scriptabl class hint script runtim function class thi obj get default valu hint 
see org mozilla javascript scriptabl ha instanc public boolean ha instanc scriptabl instanc return obj ha instanc instanc 
see org mozilla javascript function call public object call context cx scriptabl scope scriptabl thi obj object arg return function obj call cx scope thi obj arg 
note that if the code delege code is code null code thi method creat a new instanc of the deleg itself rathert than forward the call to the code delege code thi permit the us of deleg prototyp param cx the current context for thi thread param scope an enclos scope of the caller except when the function is call from a closur param arg the arrai of argument return the alloc object see function construct context scriptabl object public scriptabl construct context cx scriptabl scope object arg if obj null thi littl trick allow us to declar prototyp object for deleg deleg n new instanc scriptabl delege if arg length 0 delege new nativ object els delege script runtim to object cx scope arg 0 n set delege delege return n els return function obj construct cx scope arg 
public static class iter iter obj to int map master thi master master 
final void init object kei int valu int kei count thi kei kei thi valu valu thi cursor 1 thi remain kei count 
public void start master init iter thi next 
public boolean done return remain 0 
public void next if remain 1 kit code bug if remain 0 remain 1 cursor 1 els for cursor cursor object kei kei cursor if kei null kei delet remain break 
public object get kei object kei kei cursor if kei uniqu tag null valu kei null return kei 
public int get valu return valu cursor 
public void set valu int valu valu cursor valu 
public obj to int map thi 4 
public obj to int map int kei count hint if kei count hint 0 kit code bug tabl grow when number of store kei 3 4 of max capac int minim capac kei count hint 4 3 int i for i 2 1 i minim capac i power i if check power 2 kit code bug 
public boolean is empti return kei count 0 
public int size return kei count 
public boolean ha object kei if kei null kei uniqu tag null valu return 0 find index kei 
get integ valu assign with kei return kei integ valu or default valu if kei is absent public int get object kei int default valu if kei null kei uniqu tag null valu int index find index kei if 0 index return valu index return default valu 
get integ valu assign with kei return kei integ valu throw runtim except if kei doe not exist public int get exist object kei if kei null kei uniqu tag null valu int index find index kei if 0 index return valu index kei must exist kit code bug return 0 
public void put object kei int valu if kei null kei uniqu tag null valu int index ensur index kei valu index valu 
if tabl alreadi contain a kei that equal to kei arg return that kei while set it valu to zero otherwis add kei arg with 0 valu to the tabl and return it public object intern object kei arg boolean null kei fals if kei arg null null kei true kei arg uniqu tag null valu int index ensur index kei arg valu index 0 return null kei null kei index 
public void remov object kei if kei null kei uniqu tag null valu int index find index kei if 0 index kei index delet kei count 
public void clear int i kei length while i 0 kei i null kei count 0 occupi count 0 
public iter new iter return new iter thi 
from the iter inner class to workaround jdk 1 1 compil bug which gener code trigger verifi error on recent jvm final void init iter iter i i init kei valu kei count 
return arrai of present kei public object get kei object arrai new object kei count get kei arrai 0 return arrai 
public void get kei object arrai int offset int count kei count for int i 0 count 0 i object kei kei i if kei null kei delet if kei uniqu tag null valu kei null arrai offset kei offset count 
privat static int tabl lookup step int fraction int mask int power int shift 32 2 power if shift 0 return fraction shift mask 1 els return fraction mask shift 1 
privat int find index object kei if kei null int hash kei hash code int fraction hash a int index fraction 32 power object test kei index if test null int n 1 power if test kei valu n index hash test equal kei return index search in tabl after first fail attempt int mask n 1 int step tabl lookup step fraction mask power int n 0 for if check if n occupi count kit code bug n index index step mask test kei index if test null break if test kei valu n index hash test equal kei return index return 1 
and enough free space privat int insert new kei object kei int hash if check occupi count kei count kit code bug if check kei count 1 power kit code bug int fraction hash a int index fraction 32 power int n 1 power if kei index null int mask n 1 int step tabl lookup step fraction mask power int first index index do if check kei index delet kit code bug index index step mask if check first index index kit code bug while kei index null kei index kei valu n index hash occupi count kei count return index 
privat void rehash tabl if kei null if check kei count 0 kit code bug if check occupi count 0 kit code bug int n 1 power kei new object n valu new int 2 n els check if remov delet entri would free enough space if kei count 2 occupi count need to grow less then half of delet entri power int n 1 power object old kei kei int old valu valu int old n old kei length kei new object n valu new int 2 n int remain kei count occupi count kei count 0 for int i 0 remain 0 i object kei old kei i if kei null kei delet int kei hash old valu old n i int index insert new kei kei kei hash valu index old valu i remain 
ensur kei index creat on if necessari privat int ensur index object kei int hash kei hash code int index 1 int first delet 1 if kei null int fraction hash a index fraction 32 power object test kei index if test null int n 1 power if test kei valu n index hash test equal kei return index if test delet first delet index search in tabl after first fail attempt int mask n 1 int step tabl lookup step fraction mask power int n 0 for if check if n occupi count kit code bug n index index step mask test kei index if test null break if test kei valu n index hash test equal kei return index if test delet first delet 0 first delet index insert of new kei if check kei null kei index null kit code bug if first delet 0 index first delet els need to consum empti entri check occup level if kei null occupi count 4 1 power 3 too litl unus entri rehash rehash tabl return insert new kei kei hash occupi count kei index kei valu 1 power index hash kei count return index 
privat void write object object output stream out throw ioexcept out default write object int count kei count for int i 0 count 0 i object kei kei i if kei null kei delet count out write object kei out write int valu i 
privat void read object object input stream in throw ioexcept class not found except in default read object int written kei count kei count if written kei count 0 kei count 0 int n 1 power kei new object n valu new int 2 n for int i 0 i written kei count i object kei in read object int hash kei hash code int index insert new kei kei hash valu index in read int 
public class live connect test extend applet implement runnabl creat a new live connect test public live connect test 
main method us when run as an applic public static void main string arg live connect test test new live connect test 
public void start run 
public void stop 
main method when run as an applet public void run system out println run the test setup test environ file start time test driver get current time execut test file end time test driver get current time get result cleanup test environ stop 
initi variabl open log file public void setup test environ global jsobject get window thi get environ if environ browser privileg manag enabl privileg univers file access privileg manag enabl privileg univers properti read output get output directori if log test driver open log file output templog get temp log output testdir get test directori file new test file thi get class get name testdir to string thi get class to string file bugnumb thi bugnumb file descript thi get class to string 
public void get environ thi environ global get member version equal undefin browser shell return 
creat a test log object which will be us to write the testclass result to a temporari log file if there is an exist log delet it public test log get temp log file output string templog try temp log name string global get member output file equal undefin temp log name string global get member output file templog output get absolut path temp log name catch except e thi except e to string p except delet exist templog e to string return new test log templog 
get the output file if defin which is where the temp log is written if the file is not defin assum we ar run in the shell and do not write ani output xxx chang thi to match descript abov see com netscap javascript driver live connect drv public file get output directori string o if thi environ browser string output param thi get paramet output return new file get paramet output els try o string global get member output directori if o equal undefin log true catch except e system err println output directori threw e e print stack trace system exit 1 system out println output file is o to string return new file o to string 
get the test directori variabl which must be defin in the java script helper file see com netscap javascript driver live connect drv public file get test directori try string o string global get member test directori o o end with file separ o o file separ return new file o to string catch except e system err println test directori is not defin e return new file 
execut the test subclass must implement thi method the default implemen doe noth thi method should instanti test case and add them to the testcas vector public void execut test return 
add a test case to the testcas vector param descript a descript of the test case param expect a string represent of the expect result param actual a string represent of the actual result param except the messag in ani java script runtim error or java except that wa thrown public void add test case string descript string expect string actual string except string result expect actual true fals test case tc new test case result thi get class get name to string descript expect actual except file case vector add element tc file total case if result fals file pass fals file case fail els file case pass return 
close all log public void close log test driver get log output test driver summari log name close log test driver get log output test driver suit log name close log test driver get log output test driver file log name close log test driver get log output test driver case log name close log templog close log templog null 
iter through the testcas vector popul the properti of the test file object public void get result displai result if log write result to case log write result to file log write result to temp log 
write a summari of the test case to standard out public void displai result for int i 0 i file case vector size i test case tc test case file case vector element at i p tc descript tc actual tc expect tc actual fail expect tc expect pass get fail case 
if ani test case did not pass write a summari of the fail case to the case log us static test driver method see com netscap javascript qa driver test driver write case result public void write result to case log if file pass test driver write case result file file descript output 
if the test fail write a summari of thi test to the file log us static test driver method to write to the file log see com netscap javascript qa driver test driver write file result public void write result to file log if file pass test driver write file result file null output 
write to a file contain the result of thi test file the content of thi file is pars by the pars result method of live connect env which maintain inform about all file and suit execut the format of the temp log is a list of name valu pair on per line the temp log is overwritten each time the live connect drv execut a test chang to the format of the templog file will requir chang to live connect drv pars result pre classnam live connect test pass true fals length number of testcas in thi test no pass number of testcas that pass no fail number of testcas that fail pre xxx mai also want to write bugnumb time complet etc probabl what thi should do is enumer all the properti of a test file object that the driver can pars and treat as though it had a normal test file object see com netscap javascript qa driver live connect drv pars result public void write result to temp log system out println write result to templog to string templog write line file descript templog write line file pass templog write line file case vector size templog write line file case pass templog write line file case fail templog write line file bugnumb p file name p pass pass p total case file case vector size p case pass file case pass p case fail file case fail p bugnumb file bugnumb return 
close log and set the valu of the complet variabl in the java script environ so that the driver know the test ha finish public void cleanup test environ try if log templog close log global eval var complet true catch except e p except in cleanup test environ e to string e print stack trace 
public void p string s system out println s 
thi dandi littl hack from nix that is us to test thing that should fail it run a method on a java script object catch ani except it return the detail messag from the except or no except if it succe thi is from nix public static string catch except jsobject self string method object arg object rval string msg try rval self call method arg msg no except catch throwabl e msg e get messag return msg 
public void get fail case if file pass return p fail test case for int i 0 i file case vector size i test case tc test case file case vector element at i if tc pass true p tc descript tc actual tc expect tc actual fail expect tc expect pass tc reason length 0 tc reason 
prototyp valu id scriptabl object obj int max id if obj null throw new illeg argument except if max id 1 throw new illeg argument except thi obj obj thi max id max id 
final int get max id return max id 
final void init valu int id string name object valu int attribut if 1 id id max id throw new illeg argument except if name null throw new illeg argument except if valu not found throw new illeg argument except scriptabl object check valid attribut attribut if obj find prototyp id name id throw new illeg argument except name if id constructor id if valu instanceof id function object throw new illeg argument except consructor should be initi with id function object constructor id function object valu constructor attr short attribut return init slot id name valu attribut 
privat void init slot int id string name object valu int attribut object arrai valu arrai if arrai null throw new illeg state except if valu null valu uniqu tag null valu int index id 1 slot span synchron thi object value2 arrai index valu slot if value2 null arrai index valu slot valu arrai index name slot name attribut arrai id 1 short attribut els if name equal arrai index name slot throw new illeg state except 
final id function object creat precach constructor if constructor id 0 throw new illeg state except constructor id obj find prototyp id constructor if constructor id 0 throw new illeg state except no id for constructor properti obj init prototyp id constructor id if constructor null throw new illeg state except obj get class get name init prototyp id did not initi id constructor id constructor init function obj get class name scriptabl object get top level scope obj constructor mark as constructor obj return constructor 
final int find id string name object arrai valu arrai if arrai null return obj find prototyp id name int id last found id if name arrai id 1 slot span name slot return id id obj find prototyp id name if id 0 int name slot id 1 slot span name slot make cach to work arrai name slot name last found id id return id 
final boolean ha int id object arrai valu arrai if arrai null not yet initi assum all exist return true int valu slot id 1 slot span valu slot object valu arrai valu slot if valu null the particular entri ha not been yet initi return true return valu not found 
final object get int id object valu ensur id id if valu uniqu tag null valu valu null return valu 
final void set int id scriptabl start object valu if valu not found throw new illeg argument except ensur id id int attr attribut arrai id 1 if attr readonli 0 if start obj if valu null valu uniqu tag null valu int valu slot id 1 slot span valu slot synchron thi valu arrai valu slot valu els int name slot id 1 slot span name slot string name string valu arrai name slot start put name start valu 
final void delet int id ensur id id int attr attribut arrai id 1 if attr perman 0 int valu slot id 1 slot span valu slot synchron thi valu arrai valu slot not found attribut arrai id 1 empti 
final int get attribut int id ensur id id return attribut arrai id 1 
final void set attribut int id int attribut scriptabl object check valid attribut attribut ensur id id synchron thi attribut arrai id 1 short attribut 
final object get name boolean get all object extra entri object name null int count 0 for int id 1 id max id id object valu ensur id id if get all attribut arrai id 1 dontenum 0 if valu not found int name slot id 1 slot span name slot string name string valu arrai name slot if name null name new object max id name count name if count 0 return extra entri els if extra entri null extra entri length 0 if count name length object tmp new object count system arraycopi name 0 tmp 0 count name tmp return name els int extra extra entri length object tmp new object extra count system arraycopi extra entri 0 tmp 0 extra system arraycopi name 0 tmp extra count return tmp 
privat object ensur id int id object arrai valu arrai if arrai null synchron thi arrai valu arrai if arrai null arrai new object max id slot span valu arrai arrai attribut arrai new short max id int valu slot id 1 slot span valu slot object valu arrai valu slot if valu null if id constructor id init slot constructor id constructor constructor constructor attr constructor null no need to refer it ani longer els obj init prototyp id id valu arrai valu slot if valu null throw new illeg state except obj get class get name init prototyp id int id did not initi id id return valu 
public id scriptabl object 
public id scriptabl object scriptabl scope scriptabl prototyp super scope prototyp 
protect final object default get string name return super get name thi 
protect final void default put string name object valu super put name thi valu 
public boolean ha string name scriptabl start int info find instanc id info name if info 0 int attr info 16 if attr perman 0 return true int id info 0x ffff return not found get instanc id valu id if prototyp valu null int id prototyp valu find id name if id 0 return prototyp valu ha id return super ha name start 
public object get string name scriptabl start int info find instanc id info name if info 0 int id info 0x ffff return get instanc id valu id if prototyp valu null int id prototyp valu find id name if id 0 return prototyp valu get id return super get name start 
public void put string name scriptabl start object valu int info find instanc id info name if info 0 if start thi is seal throw context report runtim error1 msg modifi seal name int attr info 16 if attr readonli 0 if start thi int id info 0x ffff set instanc id valu id valu els start put name start valu return if prototyp valu null int id prototyp valu find id name if id 0 if start thi is seal throw context report runtim error1 msg modifi seal name prototyp valu set id start valu return super put name start valu 
public void delet string name int info find instanc id info name if info 0 let the super class to throw except for seal object if is seal int attr info 16 if attr perman 0 int id info 0x ffff set instanc id valu id not found return if prototyp valu null int id prototyp valu find id name if id 0 if is seal prototyp valu delet id return super delet name 
public int get attribut string name int info find instanc id info name if info 0 int attr info 16 return attr if prototyp valu null int id prototyp valu find id name if id 0 return prototyp valu get attribut id return super get attribut name 
public void set attribut string name int attribut scriptabl object check valid attribut attribut int info find instanc id info name if info 0 int current attribut info 16 if attribut current attribut throw new runtim except chang of attribut for thi id is not support return if prototyp valu null int id prototyp valu find id name if id 0 prototyp valu set attribut id attribut return super set attribut name attribut 
object get id boolean get all object result super get id get all if prototyp valu null result prototyp valu get name get all result int max instanc id get max instanc id if max instanc id 0 object id null int count 0 for int id max instanc id id 0 id string name get instanc id name id int info find instanc id info name if info 0 int attr info 16 if attr perman 0 if not found get instanc id valu id continu if get all attr dontenum 0 if count 0 need extra room for no more then 1 id name id new object id id count name if count 0 if result length 0 id length count result id els object tmp new object result length count system arraycopi result 0 tmp 0 result length system arraycopi id 0 tmp result length count result tmp return result 
get maximum id find instanc id info can gener protect int get max instanc id return 0 
protect static int instanc id info int attribut int id return attribut 16 id 
map name to id of instanc properti should return 0 if not found or the result of link instanc id info int int protect int find instanc id info string name return 0 
map id back to properti name it defin protect string get instanc id name int id throw new illeg argument except string valu of id 
get id valu if id valu is constant descend can call cach id valu to store valu in the perman cach default implement creat id function object instanc for given id and cach it valu protect object get instanc id valu int id throw new illeg state except string valu of id 
set or delet id valu if valu not found the implement should make sure that the follow get instanc id valu return not found protect void set instanc id valu int id object valu throw new illeg state except string valu of id 
thi obj will be null if invok as constructor in which case instanc of scriptabl should be return public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg throw f unknown 
public final id function object export as jsclass int max prototyp id scriptabl scope boolean seal set scope and prototyp unless thi is top level scope itself if scope thi scope null set parent scope scope set prototyp get object prototyp scope activ prototyp map max prototyp id id function object ctor prototyp valu creat precach constructor if seal seal object fill constructor properti ctor if seal ctor seal object ctor export as scope properti return ctor 
public final boolean ha prototyp map return prototyp valu null 
public final void activ prototyp map int max prototyp id prototyp valu valu new prototyp valu thi max prototyp id synchron thi if prototyp valu null throw new illeg state except prototyp valu valu 
public final void init prototyp method object tag int id string name int ariti scriptabl scope scriptabl object get top level scope thi id function object f new id function tag id name ariti scope prototyp valu init valu id name f dontenum 
public final void init prototyp constructor id function object f int id prototyp valu constructor id if id 0 throw new illeg state except if f method id id throw new illeg argument except if is seal f seal object prototyp valu init valu id constructor f dontenum 
public final void init prototyp valu int id string name object valu int attribut prototyp valu init valu id name valu attribut 
protect void init prototyp id int id throw new illeg state except string valu of id 
protect int find prototyp id string name throw new illeg state except name 
protect void fill constructor properti id function object ctor 
protect void add id function properti scriptabl obj object tag int id string name int ariti scriptabl scope scriptabl object get top level scope obj id function object f new id function tag id name ariti scope f add as properti obj 
util method to construct type error to indic incompat call when convert script thi obj to a particular type is not possibl possibl usag would be to have a privat function like real thi pre privat static nativ someth real thi scriptabl thi obj id function object f if thi obj instanceof nativ someth throw incompat call error f return nativ someth thi obj pre note that although such function can be implement univers via java lang class is instanc it would be much more slower param read onli specifi if the function f doe not chang state of object return scriptabl object suitabl for a check by the instanceof oper throw runtim except if no more instanceof target can be found protect static ecma error incompat call error id function object f throw script runtim type error1 msg incompat call f get function name 
privat id function object new id function object tag int id string name int ariti scriptabl scope id function object f new id function object thi tag id name ariti scope if is seal f seal object return f 
privat void read object object input stream stream throw ioexcept class not found except stream default read object int max prototyp id stream read int if max prototyp id 0 activ prototyp map max prototyp id 
privat void write object object output stream stream throw ioexcept stream default write object int max prototyp id 0 if prototyp valu null max prototyp id prototyp valu get max id stream write int max prototyp id 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public int float 512 public int ambigu float arg return float 
public int ambigu doubl arg return doubl 
public int ambigu byte arg return byte 
public int ambigu char arg return char 
public int ambigu short arg return short 
public int ambigu int arg return int 
public class shell extend scriptabl object public string get class name return global 
main entri point process argument as would a normal java program also creat a new context and associ it with the current thread then set up the execut environ and begin to execut script public static void main string arg associ a new context with thi thread context cx context enter try initi the standard object object function etc thi must be done befor script can be execut shell shell new shell cx init standard object shell defin some global function particular to the shell note that these function ar not part of ecma string name print quit version load help shell defin function properti name shell class scriptabl object dontenum arg process option cx arg set up argument in the global scope to contain the command line argument after the name of the script to execut object arrai arg if arg length 0 int length arg length 1 arrai new object length system arraycopi arg 1 arrai 0 length scriptabl arg obj cx new arrai shell arrai shell defin properti argument arg obj scriptabl object dontenum shell process sourc cx arg length 0 null arg 0 final context exit 
pars argument public static string process option context cx string arg for int i 0 i arg length i string arg arg i if arg start with string result new string arg length i for int j i j arg length j result j i arg j return result if arg equal version if i arg length usag arg doubl d cx to number arg i if d d usag arg cx set languag version int d continu usag arg return new string 0 
print a usag messag privat static void usag string s p didn t understand s p valid argument ar p version 100 110 120 130 140 150 system exit 1 
print a help messag thi method is defin as a java script function public void help p p command descript p p help displai usag and help messag p defin class class name defin an extens us the java class p name with the string argument p us scriptabl object defin class p load foo js load java script sourc file name by p string argument p load class class name load a class name by a string argument p the class must be a script compil to a p class file p print expr evalu and print express p quit quit the shell p version number get or set the java script version number p 
print the string valu of it argument thi method is defin as a java script function note that it argument ar of the vararg form which allow it to handl an arbitrari number of argument suppli to the java script function public static void print context cx scriptabl thi obj object arg function fun obj for int i 0 i arg length i if i 0 system out print convert the arbitrari java script valu into a string form string s context to string arg i system out print s system out println 
quit the shell thi onli affect the interact mode thi method is defin as a java script function public void quit quit true 
get and set the languag version thi method is defin as a java script function public static doubl version context cx scriptabl thi obj object arg function fun obj doubl result doubl cx get languag version if arg length 0 doubl d cx to number arg 0 cx set languag version int d return result 
load and execut a set of java script sourc file thi method is defin as a java script function public static void load context cx scriptabl thi obj object arg function fun obj shell shell shell get top level scope thi obj for int i 0 i arg length i shell process sourc cx cx to string arg i 
evalu java script sourc param cx the current context param filenam the name of the file to compil or null for interact mode privat void process sourc context cx string filenam if filenam null buffer reader in new buffer reader new input stream reader system in string sourc name stdin int lineno 1 boolean hit eof fals do int startlin lineno system err print js system err flush try string sourc collect line of sourc to compil while true string newlin newlin in read line if newlin null hit eof true break sourc sourc newlin n lineno continu collect as long as more line ar need to complet the current statement string is compil unit is also true if the sourc statement will result in ani error other than on that might be resolv by append more sourc if cx string is compil unit sourc break object result cx evalu string thi sourc sourc name startlin null if result cx get undefin valu system err println cx to string result catch wrap except we some form of except wa caught by java script and propag up system err println we get wrap except to string we print stack trace catch evalu except ee some form of java script error system err println js ee get messag catch java script except jse some form of java script error system err println js jse get messag catch ioexcept ioe system err println ioe to string if quit the user execut the quit function break while hit eof system err println els file reader in null try in new file reader filenam catch file not found except ex context report error couldn t open file filenam return try here we evalut the entir content of the file as a script text is print onli if the print function is call cx evalu reader thi in filenam 1 null catch wrap except we system err println we get wrap except to string we print stack trace catch evalu except ee system err println js ee get messag catch java script except jse system err println js jse get messag catch ioexcept ioe system err println ioe to string final try in close catch ioexcept ioe system err println ioe to string system gc 
privat static void p string s system out println s 
static final long serial version uid 6948590651130498591l public nativ java object 
public nativ java object scriptabl scope object java object class static type thi parent scope thi java object java object thi static type static type init member 
protect void init member class dynam type if java object null dynam type java object get class els dynam type static type member java member lookup class parent dynam type static type field and method member get field and method object thi java object fals 
public boolean ha string name scriptabl start return member ha name fals 
public boolean ha int index scriptabl start return fals 
public object get string name scriptabl start if field and method null object result field and method get name if result null return result todo pass thi as the scope is bogu sinc it ha no parent scope return member get thi name java object fals 
public object get int index scriptabl start throw member report member not found integ to string index 
public void put string name scriptabl start object valu we could be ask to modifi the valu of a properti in the prototyp sinc we can t add a properti to a java object we modifi it in the prototyp rather than copi it down if prototyp null member ha name fals member put thi name java object valu fals els prototyp put name prototyp valu 
public void put int index scriptabl start object valu throw member report member not found integ to string index 
public boolean ha instanc scriptabl valu thi is an instanc of a java class so alwai return fals return fals 
public void delet string name 
public void delet int index 
public scriptabl get prototyp if prototyp null java object instanceof string return scriptabl object get class prototyp parent string return prototyp 
set the prototyp of the object public void set prototyp scriptabl m prototyp m 
return the parent enclos scope of the object public scriptabl get parent scope return parent 
set the parent enclos scope of the object public void set parent scope scriptabl m parent m 
public object get id return member get id fals 
deprec us link context get wrap factori togeth with call link wrap factori wrap context cx scriptabl scope object obj class public static object wrap scriptabl scope object obj class static type context cx context get context return cx get wrap factori wrap cx scope obj static type 
public object unwrap return java object 
public string get class name return java object 
public object get default valu class hint object valu if hint null if java object instanceof boolean hint script runtim boolean class if hint null hint script runtim string class valu java object to string els string convert name if hint script runtim boolean class convert name boolean valu els if hint script runtim number class convert name doubl valu els throw context report runtim error0 msg default valu object convert object get convert name thi if convert object instanceof function function f function convert object valu f call context get context f get parent scope thi script runtim empti arg els if hint script runtim number class java object instanceof boolean boolean b boolean java object boolean valu valu script runtim wrap number b 1 0 0 0 els valu java object to string return valu 
determin whether we can should convert between the given type and the desir on thi should be superced by a convers cost calcul function but for now i ll hide behind preced public static boolean can convert object from obj class to int weight get convers weight from obj to return weight convers none 
deriv a rank base on how natur the convers is the special valu convers none mean no convers is possibl and convers nontrivi signal that more type conform test is requir base on a href http www mozilla org js liveconnect lc3 method overload html prefer method convers from live connect 3 a static int get convers weight object from obj class to int from code get jstype code from obj switch from code case jstype undefin if to script runtim string class to script runtim object class return 1 break case jstype null if to is primit return 1 break case jstype boolean boolean is 1 if to boolean type return 1 els if to script runtim boolean class return 2 els if to script runtim object class return 3 els if to script runtim string class return 4 break case jstype number if to is primit if to doubl type return 1 els if to boolean type return 1 get size rank to els if to script runtim string class nativ number ar 1 8 return 9 els if to script runtim object class return 10 els if script runtim number class is assign from to doubl is 1 return 2 break case jstype string if to script runtim string class return 1 els if to is instanc from obj return 2 els if to is primit if to charact type return 3 els if to boolean type return 4 break case jstype java class if to script runtim class class return 1 els if to script runtim object class return 3 els if to script runtim string class return 4 break case jstype java object case jstype java arrai object java obj from obj if java obj instanceof wrapper java obj wrapper java obj unwrap if to is instanc java obj return convers nontrivi if to script runtim string class return 2 els if to is primit to boolean type return from code jstype java arrai convers nontrivi 2 get size rank to break case jstype object other object take 1 3 spot if to from obj get class no convers requir return 1 if to is arrai if from obj instanceof nativ arrai thi is a nativ arrai convers to a java arrai arrai convers ar all equal and prefer to object and string convers per lc3 return 1 els if to script runtim object class return 2 els if to script runtim string class return 3 els if to script runtim date class if from obj instanceof nativ date thi is a nativ date to java date convers return 1 els if to is interfac if from obj instanceof function see comment in coerc type if to get method length 1 return 1 return 11 els if to is primit to boolean type return 3 get size rank to break return convers none 
static int get size rank class a type if a type doubl type return 1 els if a type float type return 2 els if a type long type return 3 els if a type integ type return 4 els if a type short type return 5 els if a type charact type return 6 els if a type byte type return 7 els if a type boolean type return convers none els return 8 
privat static int get jstype code object valu if valu null return jstype null els if valu undefin instanc return jstype undefin els if valu instanceof string return jstype string els if valu instanceof number return jstype number els if valu instanceof boolean return jstype boolean els if valu instanceof scriptabl if valu instanceof nativ java class return jstype java class els if valu instanceof nativ java arrai return jstype java arrai els if valu instanceof wrapper return jstype java object els return jstype object els if valu instanceof class return jstype java class els class valu class valu get class if valu class is arrai return jstype java arrai els return jstype java object 
not intend for public us caller should us the public api context to type see org mozilla javascript context js to java object class deprec as of 1 5 releas 4 public static object coerc type class type object valu return coerc type impl type valu 
type mung for field set and method invoc conform to lc3 specif static object coerc type impl class type object valu if valu null valu get class type return valu switch get jstype code valu case jstype null rais error if type is primit if type is primit report convers error valu type return null case jstype undefin if type script runtim string class type script runtim object class return undefin els report convers error undefin type break case jstype boolean under lc3 onli js boolean can be coerc into a boolean valu if type boolean type type script runtim boolean class type script runtim object class return valu els if type script runtim string class return valu to string els report convers error valu type break case jstype number if type script runtim string class return script runtim to string valu els if type script runtim object class return coerc to number doubl type valu els if type is primit type boolean type script runtim number class is assign from type return coerc to number type valu els report convers error valu type break case jstype string if type script runtim string class type is instanc valu return valu els if type charact type type script runtim charact class special case for convert a singl char string to a charact place here becaus it appli onli to js string not other js object convert to string if string valu length 1 return new charact string valu char at 0 els return coerc to number type valu els if type is primit type boolean type script runtim number class is assign from type return coerc to number type valu els report convers error valu type break case jstype java class if valu instanceof wrapper valu wrapper valu unwrap if type script runtim class class type script runtim object class return valu els if type script runtim string class return valu to string els report convers error valu type break case jstype java object case jstype java arrai if type is primit if type boolean type report convers error valu type return coerc to number type valu els if valu instanceof wrapper valu wrapper valu unwrap if type script runtim string class return valu to string els if type is instanc valu return valu els report convers error valu type break case jstype object if type script runtim string class return script runtim to string valu els if type is primit if type boolean type report convers error valu type return coerc to number type valu els if type is instanc valu return valu els if type script runtim date class valu instanceof nativ date doubl time nativ date valu get jstime valu xxx thi will replac na n by 0 return new date long time els if type is arrai valu instanceof nativ arrai make a new java arrai and coerc the js arrai compon to the target compon type nativ arrai arrai nativ arrai valu long length arrai get length class arrai type type get compon type object result arrai new instanc arrai type int length for int i 0 i length i try arrai set result i coerc type arrai type arrai get i arrai catch evalu except ee report convers error valu type return result els if valu instanceof wrapper valu wrapper valu unwrap if type is instanc valu return valu report convers error valu type els if type is interfac valu instanceof callabl try to us function as implement of java interfac xxx curent onli instanc of scriptabl object ar support sinc the result interfac proxi should be reus next time convers is made and gener callabl ha no storag for it weak refer can address it but for now us thi restrict if valu instanceof scriptabl object scriptabl object so scriptabl object valu object kei kit make hash kei from pair coerc interfac kei type object old so get associ valu kei if old null function wa alreadi wrap return old context cx context get context object glue interfac adapt creat cx type callabl valu store for later retriv glue so associ valu kei glue return glue report convers error valu type els report convers error valu type break return valu 
privat static object coerc to number class type object valu class valu class valu get class charact if type charact type type script runtim charact class if valu class script runtim charact class return valu return new charact char to integ valu script runtim charact class doubl charact min valu doubl charact max valu doubl float if type script runtim object class type script runtim doubl class type doubl type return valu class script runtim doubl class valu new doubl to doubl valu if type script runtim float class type float type if valu class script runtim float class return valu els doubl number to doubl valu if doubl is infinit number doubl is na n number number 0 0 return new float float number els doubl ab number math ab number if ab number doubl float min valu return new float number 0 0 0 0 0 0 els if ab number doubl float max valu return new float number 0 0 float posit infin float neg infin els return new float float number integ long short byte if type script runtim integ class type integ type if valu class script runtim integ class return valu els return new integ int to integ valu script runtim integ class doubl integ min valu doubl integ max valu if type script runtim long class type long type if valu class script runtim long class return valu els long valu cannot be express exactli in doubl we thu us the largest and smallest doubl valu that ha a valu express as a long valu we build these numer valu from their hexidecim represent to avoid ani problem caus by attempt to pars a decim represent final doubl max doubl long bit to doubl 0x43dfffffffffffff l final doubl min doubl long bit to doubl 0xc3e0000000000000l return new long to integ valu script runtim long class min max if type script runtim short class type short type if valu class script runtim short class return valu els return new short short to integ valu script runtim short class doubl short min valu doubl short max valu if type script runtim byte class type byte type if valu class script runtim byte class return valu els return new byte byte to integ valu script runtim byte class doubl byte min valu doubl byte max valu return new doubl to doubl valu 
privat static doubl to doubl object valu if valu instanceof number return number valu doubl valu els if valu instanceof string return script runtim to number string valu els if valu instanceof scriptabl if valu instanceof wrapper xxx optim tail recurs return to doubl wrapper valu unwrap els return script runtim to number valu els method meth try meth valu get class get method doubl valu null catch no such method except e meth null catch secur except e meth null if meth null try return number meth invok valu null doubl valu catch illeg access except e xxx ignor or error messag report convers error valu doubl type catch invoc target except e xxx ignor or error messag report convers error valu doubl type return script runtim to number valu to string 
privat static long to integ object valu class type doubl min doubl max doubl d to doubl valu if doubl is infinit d doubl is na n d convert to string first for more readabl messag report convers error script runtim to string valu type if d 0 0 d math floor d els d math ceil d if d min d max convert to string first for more readabl messag report convers error script runtim to string valu type return long d 
static void report convers error object valu class type it us string valu of valu not valu to string sinc valu can be null bug 282447 throw context report runtim error2 msg convers not allow string valu of valu java member java signatur type 
privat void write object object output stream out throw ioexcept out default write object if java object null class jo class java object get class if jo class get name start with adapt out write boolean true if adapt write adapt object null throw new ioexcept object arg java object out try adapt write adapt object invok null arg catch except ex throw new ioexcept els out write boolean fals out write object java object els out write boolean fals out write object java object if static type null out write object static type get class get name els out write object null 
privat void read object object input stream in throw ioexcept class not found except in default read object if in read boolean if adapt read adapt object null throw new class not found except object arg thi in try java object adapt read adapt object invok null arg catch except ex throw new ioexcept els java object in read object string class name string in read object if class name null static type class for name class name els static type null init member 
public object observ public observ task string cl object observ thi command line cl thi observ observ 
public string buffer get input return input 
public string buffer get error return error 
int get exit valu return exit valu 
execut the process and return when the process is complet public void exec throw ioexcept runtim rt runtim get runtim try process proc rt exec command line output stream os rt get local output stream proc get output stream if thi observ instanceof ref env os write quit n get byte os flush os close input stream reader is is new input stream reader proc get error stream new thread new stream reader error is start is new input stream reader proc get input stream new thread new stream reader input is start proc wait for exit valu proc exit valu unfortun the follow paus seem to need to be here otherwis we get a crash on aix process wait for doesn t seem to wait for the process to complet befor continu bad need to find a workaround if system get properti os name start with aix system get properti os name start with hp paus 20000 els paus 10000 catch except e java lang system out println e e print stack trace 
simpl print method us for debug public void print system out println input stream of process system out println input system out println error stream of process system out println error system out println exit valu of process exit valu 
simpl paus method us for debug static void paus int length try thread current thread sleep length catch interrupt except ex system err println ex 
main us for debug static public void main string arg if arg length 1 system err println usag java run it command line system exit 1 try observ task task new observ task arg 0 null task exec task print paus 10000 catch except e system err println error except thrown e system exit 2 
input stream reader input stream reader stream reader string buffer b input stream reader i buffer b input stream reader i 
public void run try int ch while ch input stream reader read 1 buffer append char ch catch ioexcept ex system err println error ioexcept thrown ex ex print stack trace 
public class member 002 extend live connect test public member 002 super 
public static void main string arg member 002 test new member 002 test start 
public void setup test environ super setup test environ 
public void execut test object data get data arrai for int i 0 i data length i jsobject js object get jsobject object data i set member object data i get member js object object data i remov member js object object data i 
creat and return a jsobject us data in the data arrai param data object arrai contain name of jsobject and assign express return the jsobject public jsobject get jsobject object data string constructor data 0 data 1 jsobject the thi jsobject global eval constructor return the thi 
us jsobject eval to assign a java script valu to a properti of a java script object verifi that the express return the valu of the assign express param data object arrai that ha item correspond to the name of a jsobject a properti of that object and a java script assign express for that properti public void set member object data object result null string eval string string data 0 string data 2 string data 3 try result global eval eval string catch except e except eval string threw e to string file except except e print stack trace final add test case eval string return result result equal data 5 true result equal data 5 except 
get the valu of a java script properti check it type and valu param the thi jsobject whose properti will be check param data object arrai contain the name of the jsobject properti and the expect valu of that properti public void get member jsobject the thi object data string except null string properti string data 2 object e valu data 6 object a valu null class e class null class a class null string e type string data 7 string a type null try a valu the thi get member properti if a valu null e class e valu get class a class a valu get class a type string global eval typeof string data 0 string data 2 catch except e except the thi get member properti threw e to string file except except e print stack trace final if a valu null els check the valu of the properti add test case get member return a valu the thi get member properti equal e valu true a valu equal e valu except check the class of the properti add test case a valu get class return a class get name a class get name equal e class get name true a class get name equal e class get name except check the js type of the properti valu add test case typeof a valu return a type a type equal e type true a type equal e type except 
delet a jsobject us jsobject remov member after remov the member check the member s java script valu and type public void remov member jsobject the thi object data string except null string properti string data 2 object e valu data 8 object a valu null class e class null class a class null string e type string data 9 string a type null try the thi remov member properti a valu the thi get member properti if a valu null e class e valu get class a class a valu get class a type string global eval typeof string data 0 string data 2 catch except e except the thi get member properti threw e to string file except except e print stack trace final if a valu null els check the valu of the properti add test case after remov get member return a valu the thi get member properti equal e valu true a valu equal e valu except check the class of the properti add test case after remov a valu get class return a class get name a class get name equal e class get name true a class get name equal e class get name except check the js type of the properti valu add test case after remov typeof a valu return a type a type equal e type true a type equal e type except 
get the data arrai which is an object arrai data arrai which ar also object arrai the data arrai consist of 8 item ul li identifi for java script object li assign express to initi java script object li properti of java script object to set get li valu to assign to properti li initi valu of properti li valu of properti befor call set member li valu return by set member li valu of properti after call set member li string typeof as determin by java script ul to add test case to thi test modifi thi method return the data arrai public object get data arrai object d0 new string boo 0 identifi new string new boolean 1 assign express new string foo 2 properti new string bar 3 java script valu to assign new string undefin 4 valu befor assign new string bar 5 valu return by setter new string bar 6 valu after assign new string string 7 js typeof valu new string undefin 8 valu after remov new string undefin 9 typeof after remov object d1 new string num new string new number 12345 new string some properti new string 02134 new string undefin new doubl 0 02134 new doubl 0 02134 new string number new string undefin 8 valu after remov new string undefin 9 typeof after remov object d2 new string number new string number new string posit infin new string 0 new doubl doubl posit infin new doubl 0 new doubl doubl posit infin new string number new doubl doubl posit infin new string number object data arrai d0 d1 d2 return data arrai 
static void init scriptabl scope boolean seal nativ arrai obj new nativ arrai obj export as jsclass max prototyp id scope seal 
zero paramet constructor just us to creat arrai prototyp privat nativ arrai dens null thi length 0 
public nativ arrai long length int int length int length if int length length int length 0 if int length maximum dens length int length maximum dens length dens new object int length for int i 0 i int length i dens i not found thi length length 
public nativ arrai object arrai dens arrai thi length arrai length 
public string get class name return arrai 
max instanc id 1 protect int get max instanc id return max instanc id 
protect int find instanc id info string s if s equal length return instanc id info dontenum perman id length return super find instanc id info s 
protect string get instanc id name int id if id id length return length return super get instanc id name id 
protect object get instanc id valu int id if id id length return script runtim wrap number length return super get instanc id valu id 
protect void set instanc id valu int id object valu if id id length set length valu return super set instanc id valu id valu 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 0 s to string break case id to local string ariti 1 s to local string break case id to sourc ariti 0 s to sourc break case id join ariti 1 s join break case id revers ariti 0 s revers break case id sort ariti 1 s sort break case id push ariti 1 s push break case id pop ariti 1 s pop break case id shift ariti 1 s shift break case id unshift ariti 1 s unshift break case id splice ariti 1 s splice break case id concat ariti 1 s concat break case id slice ariti 1 s slice break case id index of ariti 1 s index of break case id last index of ariti 1 s last index of break case id everi ariti 1 s everi break case id filter ariti 1 s filter break case id for each ariti 1 s for each break case id map ariti 1 s map break case id some ariti 1 s some break default throw new illeg argument except string valu of id init prototyp method arrai tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag arrai tag return super exec id call f cx scope thi obj arg int id f method id switch id case id constructor boolean in new expr thi obj null if in new expr id function object construct will set up parent proto return f construct cx scope arg return js constructor cx scope arg case id to string return to string helper cx scope thi obj cx ha featur context featur to string as sourc fals case id to local string return to string helper cx scope thi obj fals true case id to sourc return to string helper cx scope thi obj true fals case id join return js join cx thi obj arg case id revers return js revers cx thi obj arg case id sort return js sort cx scope thi obj arg case id push return js push cx thi obj arg case id pop return js pop cx thi obj arg case id shift return js shift cx thi obj arg case id unshift return js unshift cx thi obj arg case id splice return js splice cx scope thi obj arg case id concat return js concat cx scope thi obj arg case id slice return js slice cx thi obj arg case id index of return index of helper cx thi obj arg fals case id last index of return index of helper cx thi obj arg true case id everi case id filter case id for each case id map case id some return iter method cx id scope thi obj arg throw new illeg argument except string valu of id 
public object get int index scriptabl start if dens null 0 index index dens length return dens index return super get index start 
public boolean ha int index scriptabl start if dens null 0 index index dens length return dens index not found return super ha index start 
otherwis return 1l privat static long to arrai index string id doubl d script runtim to number id if d d long index script runtim to uint32 d if index d index 4294967295l assum that script runtim to string index is the same as java lang long to string index for long if long to string index equal id return index return 1 
public void put string id scriptabl start object valu super put id start valu if start thi if the object is seal super will throw except long index to arrai index id if index length length index 1 
public void put int index scriptabl start object valu if start thi is seal dens null 0 index index dens length if start thi seal super will throw except dens index valu els super put index start valu if start thi onli set the arrai length if given an arrai index ecma 15 4 0 if thi length index avoid overflow index thi length long index 1 
public void delet int index if is seal dens null 0 index index dens length dens index not found els super delet index 
public object get id object super id super get id if dens null return super id int n dens length long current length length if n current length n int current length if n 0 return super id int super length super id length object id new object n super length make a copi of dens to be immun to remov of arrai elem from other thread when calcul present count system arraycopi dens 0 id 0 n int present count 0 for int i 0 i n i replac exist element by their index if id i not found id present count new integ i present count if present count n dens contain delet elem need to shrink the result object tmp new object present count super length system arraycopi id 0 tmp 0 present count id tmp system arraycopi super id 0 id present count super length return id 
public object get default valu class hint if hint script runtim number class context cx context get context if cx get languag version context version 1 2 return new long length return super get default valu hint 
see ecma 15 4 1 2 privat static object js constructor context cx scriptabl scope object arg if arg length 0 return new nativ arrai onli us 1 arg as first element for version 1 2 for ani other version includ 1 3 follow ecma and us it as a length if cx get languag version context version 1 2 return new nativ arrai arg els object arg0 arg 0 if arg length 1 arg0 instanceof number return new nativ arrai arg els long len script runtim to uint32 arg0 if len number arg0 doubl valu throw context report runtim error0 msg arraylength bad return new nativ arrai len 
public long get length return length 
deprec us link get length instead public long js get length return get length 
privat void set length object val xxx do we satisfi thi 15 4 5 1 put p v 1 call the can put method of a with name p 2 if result 1 is fals return doubl d script runtim to number val long long val script runtim to uint32 d if long val d throw context report runtim error0 msg arraylength bad if long val length remov all properti between long val and length if length long val 0x1000 assum that the represent is spars object e get id will onli find in object itself for int i 0 i e length i object id e i if id instanceof string maxint will appear as string string str id string id long index to arrai index str id if index long val delet str id els int index integ id int valu if index long val delet index els assum a dens represent for long i long val i length i delet elem thi i length long val 
static long get length properti context cx scriptabl obj these will both give numer length within uint32 rang if obj instanceof nativ string return nativ string obj get length els if obj instanceof nativ arrai return nativ arrai obj get length els if obj instanceof scriptabl return 0 return script runtim to uint32 script runtim get object prop obj length cx 
privat static object set length properti context cx scriptabl target long length return script runtim set object prop target length script runtim wrap number length cx 
privat static void delet elem scriptabl target long index int i int index if i index target delet i els target delet long to string index 
privat static object get elem context cx scriptabl target long index if index integ max valu string id long to string index return script runtim get object prop target id cx els return script runtim get object index target int index cx 
privat static void set elem context cx scriptabl target long index object valu if index integ max valu string id long to string index script runtim set object prop target id valu cx els script runtim set object index target int index valu cx 
privat static string to string helper context cx scriptabl scope scriptabl thi obj boolean to sourc boolean to local it s probabl redund to handl long length in thi function string buffer ar limit to 2 31 in java long length get length properti cx thi obj string buffer result new string buffer 256 whether to return 4 unquot 5 or 4 quot 5 string separ if to sourc result append separ els separ boolean haslast fals long i 0 boolean toplevel iter if cx iter null toplevel true iter fals cx iter new obj to int map 31 els toplevel fals iter cx iter ha thi obj make sure cx iter is set to null when done so we don t leak memori try if iter cx iter put thi obj 0 stop recurs for i 0 i length i if i 0 result append separ object elem get elem cx thi obj i if elem null elem undefin instanc haslast fals continu haslast true if to sourc result append script runtim unev cx scope elem els if elem instanceof string string s string elem if to sourc result append result append script runtim escap string s result append els result append s els if to local elem undefin instanc elem null callabl fun scriptabl fun thi fun script runtim get prop function and thi elem to local string cx fun thi script runtim last store scriptabl cx elem fun call cx scope fun thi script runtim empti arg result append script runtim to string elem final if toplevel cx iter null if to sourc for length behavior we want to string to be symmetr if haslast i 0 result append els result append return result to string 
see ecma 15 4 4 3 privat static string js join context cx scriptabl thi obj object arg string separ long llength get length properti cx thi obj int length int llength if llength length throw context report runtim error1 msg arraylength too big string valu of llength if no arg us as separ if arg length 1 arg 0 undefin instanc separ els separ script runtim to string arg 0 if length 0 return string buf new string length int total size 0 for int i 0 i length i object temp get elem cx thi obj i if temp null temp undefin instanc string str script runtim to string temp total size str length buf i str total size length 1 separ length string buffer sb new string buffer total size for int i 0 i length i if i 0 sb append separ string str buf i if str null str null for undefin or null sb append str return sb to string 
see ecma 15 4 4 4 privat static scriptabl js revers context cx scriptabl thi obj object arg long len get length properti cx thi obj long half len 2 for long i 0 i half i long j len i 1 object temp1 get elem cx thi obj i object temp2 get elem cx thi obj j set elem cx thi obj i temp2 set elem cx thi obj j temp1 return thi obj 
see ecma 15 4 4 5 privat static scriptabl js sort context cx scriptabl scope scriptabl thi obj object arg long length get length properti cx thi obj if length 1 return thi obj object compar object cmp buf if arg length 0 undefin instanc arg 0 sort with given compar function compar arg 0 cmp buf new object 2 buffer for cmp argument els sort with default compar compar null cmp buf null should we us the extend sort function or the faster on if length integ max valu heapsort extend cx scope thi obj length compar cmp buf els int ilength int length copi the js arrai into a work arrai so it can be sort cheapli object work new object ilength for int i 0 i ilength i work i get elem cx thi obj i heapsort cx scope work ilength compar cmp buf copi the work arrai back into thi obj for int i 0 i ilength i set elem cx thi obj i work i return thi obj 
return true onli if x y privat static boolean is bigger context cx scriptabl scope object x object y object cmp object cmp buf if cmp null if cmp buf null kit code bug els if cmp buf null cmp buf length 2 kit code bug object undef undefin instanc sort undefin to end if undef y return fals x can not be bigger then undef els if undef x return true y undef here so x y if cmp null if no cmp function suppli sort lexicograph string a script runtim to string x string b script runtim to string y return a compar to b 0 els assembl arg and call suppli js cmp function cmp buf 0 x cmp buf 1 y callabl fun script runtim get valu function and thi cmp cx scriptabl fun thi script runtim last store scriptabl cx object ret fun call cx scope fun thi cmp buf doubl d script runtim to number ret xxx what to do when cmp function return na n ecma state that it s then not a consist compararison function but then what do we do back out and start over with the gener cmp function when we see a na n throw an error for now just ignor it return d 0 
heapsort implement see introduct to algorithm by cormen leiserson rivest for detail adjust for zero base index privat static void heapsort context cx scriptabl scope object arrai int length object cmp object cmp buf if length 1 kit code bug build heap for int i length 2 i 0 i object pivot arrai i heapifi cx scope pivot arrai i length cmp cmp buf sort heap for int i length i 1 i object pivot arrai i arrai i arrai 0 heapifi cx scope pivot arrai 0 i cmp cmp buf 
pivot and child heap of i should be made into heap start at i origin arrai i is never us to have less arrai access dure sort privat static void heapifi context cx scriptabl scope object pivot object arrai int i int end object cmp object cmp buf for int child i 2 1 if child end break object child val arrai child if child 1 end object next val arrai child 1 if is bigger cx scope next val child val cmp cmp buf child child val next val if is bigger cx scope child val pivot cmp cmp buf break arrai i child val i child arrai i pivot 
version of heapsort that call get elem set elem on target to queri assign arrai element instead of java arrai access privat static void heapsort extend context cx scriptabl scope scriptabl target long length object cmp object cmp buf if length 1 kit code bug build heap for long i length 2 i 0 i object pivot get elem cx target i heapifi extend cx scope pivot target i length cmp cmp buf sort heap for long i length i 1 i object pivot get elem cx target i set elem cx target i get elem cx target 0 heapifi extend cx scope pivot target 0 i cmp cmp buf 
privat static void heapifi extend context cx scriptabl scope object pivot scriptabl target long i long end object cmp object cmp buf for long child i 2 1 if child end break object child val get elem cx target child if child 1 end object next val get elem cx target child 1 if is bigger cx scope next val child val cmp cmp buf child child val next val if is bigger cx scope child val pivot cmp cmp buf break set elem cx target i child val i child set elem cx target i pivot 
non ecma method privat static object js push context cx scriptabl thi obj object arg long length get length properti cx thi obj for int i 0 i arg length i set elem cx thi obj length i arg i length arg length object length obj set length properti cx thi obj length if js1 2 follow perl4 by return the last thing push otherwis return the new arrai length if cx get languag version context version 1 2 if js1 2 no argument return undefin return arg length 0 undefin instanc arg arg length 1 els return length obj 
privat static object js pop context cx scriptabl thi obj object arg object result long length get length properti cx thi obj if length 0 length get the to be delet properti s valu result get elem cx thi obj length we don t need to delet the last properti becaus set length doe that for us els result undefin instanc necessari to match js even when length 0 js pop will give a length properti to ani target it is call on set length properti cx thi obj length return result 
privat static object js shift context cx scriptabl thi obj object arg object result long length get length properti cx thi obj if length 0 long i 0 length get the to be delet properti s valu result get elem cx thi obj i slide down the arrai abov the first element leav i set to point to the last element if length 0 for i 1 i length i object temp get elem cx thi obj i set elem cx thi obj i 1 temp we don t need to delet the last properti becaus set length doe that for us els result undefin instanc set length properti cx thi obj length return result 
privat static object js unshift context cx scriptabl thi obj object arg object result long length get length properti cx thi obj int argc arg length if arg length 0 slide up the arrai to make room for arg at the bottom if length 0 for long last length 1 last 0 last object temp get elem cx thi obj last set elem cx thi obj last argc temp copi from argv to the bottom of the arrai for int i 0 i arg length i set elem cx thi obj i arg i follow perl by return the new arrai length length arg length return set length properti cx thi obj length return script runtim wrap number length 
privat static object js splice context cx scriptabl scope scriptabl thi obj object arg creat an empti arrai to return scope get top level scope scope object result script runtim new object cx scope arrai null int argc arg length if argc 0 return result long length get length properti cx thi obj convert the first argument into a start index long begin to slice index script runtim to integ arg 0 length argc convert the second argument into count long count if arg length 1 count length begin els doubl dcount script runtim to integ arg 1 if dcount 0 count 0 els if dcount length begin count length begin els count long dcount argc long end begin count if there ar element to remov put them into the return valu if count 0 if count 1 cx get languag version context version 1 2 js lack list context wherebi in perl on turn the singl scalar that s splice out into an arrai just by assign it to singl instead of singl or by us it as perl push s first argument for instanc js1 2 emul perl too close and return a non arrai for the singl splice out case requir caller to test and wrap in if necessari so js1 3 default and other version all return an arrai of length 1 for uniform result get elem cx thi obj begin els for long last begin last end last scriptabl result arrai scriptabl result object temp get elem cx thi obj last set elem cx result arrai last begin temp els if count 0 cx get languag version context version 1 2 emul c js1 2 if no element ar remov return undefin result undefin instanc find the direct up or down to copi and make wai for argv long delta argc count if delta 0 for long last length 1 last end last object temp get elem cx thi obj last set elem cx thi obj last delta temp els if delta 0 for long last end last length last object temp get elem cx thi obj last set elem cx thi obj last delta temp copi from argv into the hole to complet the splice int argoffset arg length argc for int i 0 i argc i set elem cx thi obj begin i arg i argoffset updat length in case we delet element from the end set length properti cx thi obj length delta return result 
privat static scriptabl js concat context cx scriptabl scope scriptabl thi obj object arg creat an empti arrai to return scope get top level scope scope function ctor script runtim get exist ctor cx scope arrai scriptabl result ctor construct cx scope script runtim empti arg long length long slot 0 put the target in the result arrai onli add it as an arrai if it look like on if script runtim instanc of thi obj ctor cx length get length properti cx thi obj copi from the target object into the result for slot 0 slot length slot object temp get elem cx thi obj slot set elem cx result slot temp els set elem cx result slot thi obj copi from the argument into the result if ani argument ha a numer length properti treat it as an arrai and add element separ otherwis just copi the argument for int i 0 i arg length i if script runtim instanc of arg i ctor cx script runtim instanc of instanceof scriptabl scriptabl arg scriptabl arg i length get length properti cx arg for long j 0 j length j slot object temp get elem cx arg j set elem cx result slot temp els set elem cx result slot arg i return result 
privat scriptabl js slice context cx scriptabl thi obj object arg scriptabl scope get top level scope thi scriptabl result script runtim new object cx scope arrai null long length get length properti cx thi obj long begin end if arg length 0 begin 0 end length els begin to slice index script runtim to integ arg 0 length if arg length 1 end length els end to slice index script runtim to integ arg 1 length for long slot begin slot end slot object temp get elem cx thi obj slot set elem cx result slot begin temp return result 
privat static long to slice index doubl valu long length long result if valu 0 0 if valu length 0 0 result 0 els result long valu length els if valu length result length els result long valu return result 
implement the method index of and last index of privat object index of helper context cx scriptabl thi obj object arg boolean is last object compar to arg length 0 arg 0 undefin instanc long length get length properti cx thi obj long start arg length 1 script runtim to int32 script runtim to number arg 1 is last length 0 if start 0 start length if start 0 start 0 if is last for long i start i 0 i if script runtim shallow eq get elem cx thi obj i compar to return new long i els for long i start i length i if script runtim shallow eq get elem cx thi obj i compar to return new long i return neg on 
implement the method everi filter for each map and some privat object iter method context cx int id scriptabl scope scriptabl thi obj object arg object callback arg arg length 0 arg 0 undefin instanc if callback arg null callback arg instanceof function throw script runtim not function error script runtim to string callback arg function f function callback arg scriptabl parent scriptabl object get top level scope f scriptabl thi arg arg length 1 arg 1 instanceof scriptabl scriptabl arg 1 parent long length get length properti cx thi obj scriptabl arrai null if id id filter arrai script runtim new object cx scope arrai null els if id id map alloc dens arrai for effici object ctor arg new long length arrai script runtim new object cx scope arrai ctor arg object inner arg new object 3 long j 0 for long i 0 i length i inner arg 0 get elem cx thi obj i inner arg 1 new long i inner arg 2 thi obj object result f call cx parent thi arg inner arg switch id case id everi if script runtim to boolean result return boolean fals break case id filter if script runtim to boolean result set elem cx arrai j inner arg 0 break case id for each break case id map set elem cx arrai j result break case id some if script runtim to boolean result return boolean true break switch id case id everi return boolean true case id filter case id map return arrai case id some return boolean fals case id for each default return undefin instanc 
protect int find prototyp id string s int id gener last updat 2005 09 26 15 47 42 edt l0 id 0 string x null int c l switch s length case 3 c s char at 0 if c m if s char at 2 p s char at 1 a id id map break l0 els if c p if s char at 2 p s char at 1 o id id pop break l0 break l case 4 switch s char at 2 case i x join id id join break l case m x some id id some break l case r x sort id id sort break l case s x push id id push break l break l case 5 c s char at 1 if c h x shift id id shift els if c l x slice id id slice els if c v x everi id id everi break l case 6 c s char at 0 if c c x concat id id concat els if c f x filter id id filter els if c s x splice id id splice break l case 7 switch s char at 0 case f x for each id id for each break l case i x index of id id index of break l case r x revers id id revers break l case u x unshift id id unshift break l break l case 8 c s char at 3 if c o x to sourc id id to sourc els if c t x to string id id to string break l case 11 c s char at 0 if c c x constructor id id constructor els if c l x last index of id id last index of break l case 14 x to local string id id to local string break l if x null x s x equal s id 0 gener return id 
creat a new synchron function from an exist on param obj the exist function public synchron scriptabl obj super obj 
see org mozilla javascript function call public object call context cx scriptabl scope scriptabl thi obj object arg synchron thi obj return function obj call cx scope thi obj arg 
xmlctor xml xml object tag int id int ariti super xml tag id ariti thi lib xml lib activ prototyp map max function id 
privat void write set scriptabl target for int i 1 i max instanc id i int id super get max instanc id i string name get instanc id name id object valu get instanc id valu id scriptabl object put properti target name valu 
privat void read set scriptabl sourc for int i 1 i max instanc id i int id super get max instanc id i string name get instanc id name id object valu scriptabl object get properti sourc name if valu scriptabl object not found continu switch i case id ignor comment case id ignor process instruct case id ignor whitespac case id pretti print if valu instanceof boolean continu break case id pretti indent if valu instanceof number continu break default throw new illeg state except set instanc id valu id valu 
max instanc id 5 protect int get max instanc id return super get max instanc id max instanc id 
protect int find instanc id info string s int id gener last updat 2004 07 19 13 03 52 cest l0 id 0 string x null int c l switch s length case 12 x pretti indent id id pretti indent break l case 14 c s char at 0 if c i x ignor comment id id ignor comment els if c p x pretti print id id pretti print break l case 16 x ignor whitespac id id ignor whitespac break l case 28 x ignor process instruct id id ignor process instruct break l if x null x s x equal s id 0 gener if id 0 return super find instanc id info s int attr switch id case id ignor comment case id ignor process instruct case id ignor whitespac case id pretti indent case id pretti print attr perman dontenum break default throw new illeg state except return instanc id info attr super get max instanc id id 
protect string get instanc id name int id switch id super get max instanc id case id ignor comment return ignor comment case id ignor process instruct return ignor process instruct case id ignor whitespac return ignor whitespac case id pretti indent return pretti indent case id pretti print return pretti print return super get instanc id name id 
protect object get instanc id valu int id switch id super get max instanc id case id ignor comment return script runtim wrap boolean lib ignor comment case id ignor process instruct return script runtim wrap boolean lib ignor process instruct case id ignor whitespac return script runtim wrap boolean lib ignor whitespac case id pretti indent return script runtim wrap int lib pretti indent case id pretti print return script runtim wrap boolean lib pretti print return super get instanc id valu id 
protect void set instanc id valu int id object valu switch id super get max instanc id case id ignor comment lib ignor comment script runtim to boolean valu return case id ignor process instruct lib ignor process instruct script runtim to boolean valu return case id ignor whitespac lib ignor whitespac script runtim to boolean valu return case id pretti indent lib pretti indent script runtim to int32 valu return case id pretti print lib pretti print script runtim to boolean valu return super set instanc id valu id valu 
protect int find prototyp id string s int id gener last updat 2004 07 19 13 03 52 cest l0 id 0 string x null int s length s length if s length 8 x set id id set els if s length 11 x set set id id set set els if s length 15 x default set id id default set if x null x s x equal s id 0 gener return id 
protect void init prototyp id int id string s int ariti switch id case id default set ariti 0 s default set break case id set ariti 0 s set break case id set set ariti 1 s set set break default throw new illeg argument except string valu of id init prototyp method xmlctor tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag xmlctor tag return super exec id call f cx scope thi obj arg int id f method id switch id case id default set lib default set scriptabl obj cx new object scope write set obj return obj case id set scriptabl obj cx new object scope write set obj return obj case id set set scriptabl obj null if arg length 0 arg 0 null arg 0 undefin instanc lib default set els if arg 0 instanceof scriptabl read set scriptabl arg 0 return undefin instanc throw new illeg argument except string valu of id 
static void init scriptabl scope boolean seal nativ string obj new nativ string obj export as jsclass max prototyp id scope seal 
privat nativ string string s string s 
public string get class name return string 
max instanc id 1 protect int get max instanc id return max instanc id 
protect int find instanc id info string s if s equal length return instanc id info dontenum readonli perman id length return super find instanc id info s 
protect string get instanc id name int id if id id length return length return super get instanc id name id 
protect object get instanc id valu int id if id id length return script runtim wrap int string length return super get instanc id valu id 
protect void fill constructor properti id function object ctor add id function properti ctor string tag constructor id from char code from char code 1 super fill constructor properti ctor 
protect void init prototyp id int id string s int ariti switch id case id constructor ariti 1 s constructor break case id to string ariti 0 s to string break case id to sourc ariti 0 s to sourc break case id valu of ariti 0 s valu of break case id char at ariti 1 s char at break case id char code at ariti 1 s char code at break case id index of ariti 1 s index of break case id last index of ariti 1 s last index of break case id split ariti 2 s split break case id substr ariti 2 s substr break case id to lower case ariti 0 s to lower case break case id to upper case ariti 0 s to upper case break case id substr ariti 2 s substr break case id concat ariti 1 s concat break case id slice ariti 2 s slice break case id bold ariti 0 s bold break case id ital ariti 0 s ital break case id fix ariti 0 s fix break case id strike ariti 0 s strike break case id small ariti 0 s small break case id big ariti 0 s big break case id blink ariti 0 s blink break case id sup ariti 0 s sup break case id sub ariti 0 s sub break case id fontsiz ariti 0 s fontsiz break case id fontcolor ariti 0 s fontcolor break case id link ariti 0 s link break case id anchor ariti 0 s anchor break case id equal ariti 1 s equal break case id equal ignor case ariti 1 s equal ignor case break case id match ariti 1 s match break case id search ariti 1 s search break case id replac ariti 1 s replac break default throw new illeg argument except string valu of id init prototyp method string tag id s ariti 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag string tag return super exec id call f cx scope thi obj arg int id f method id switch id case constructor id from char code int n arg length if n 1 return string buffer sb new string buffer n for int i 0 i n i sb append script runtim to uint16 arg i return sb to string case id constructor string s arg length 1 script runtim to string arg 0 if thi obj null new string val creat a new string object return new nativ string s string val convert val to a string valu return s case id to string case id valu of ecma 15 5 4 2 the to string function is not gener return real thi thi obj f string case id to sourc string s real thi thi obj f string return new string script runtim escap string s case id char at case id char code at see ecma 15 5 4 4 5 string target script runtim to string thi obj doubl po script runtim to integ arg 0 if po 0 po target length if id id char at return els return script runtim na nobj char c target char at int po if id id char at return string valu of c els return script runtim wrap int c case id index of return script runtim wrap int js index of script runtim to string thi obj arg case id last index of return script runtim wrap int js last index of script runtim to string thi obj arg case id split return js split cx scope script runtim to string thi obj arg case id substr return js substr cx script runtim to string thi obj arg case id to lower case see ecma 15 5 4 11 return script runtim to string thi obj to lower case case id to upper case see ecma 15 5 4 12 return script runtim to string thi obj to upper case case id substr return js substr script runtim to string thi obj arg case id concat return js concat script runtim to string thi obj arg case id slice return js slice script runtim to string thi obj arg case id bold return tagifi thi obj b null null case id ital return tagifi thi obj i null null case id fix return tagifi thi obj tt null null case id strike return tagifi thi obj strike null null case id small return tagifi thi obj small null null case id big return tagifi thi obj big null null case id blink return tagifi thi obj blink null null case id sup return tagifi thi obj sup null null case id sub return tagifi thi obj sub null null case id fontsiz return tagifi thi obj font size arg case id fontcolor return tagifi thi obj font color arg case id link return tagifi thi obj a href arg case id anchor return tagifi thi obj a name arg case id equal case id equal ignor case string s1 script runtim to string thi obj string s2 script runtim to string arg 0 return script runtim wrap boolean id id equal s1 equal s2 s1 equal ignor case s2 case id match case id search case id replac int action type if id id match action type reg exp proxi ra match els if id id search action type reg exp proxi ra search els action type reg exp proxi ra replac return script runtim check reg exp proxi cx action cx scope thi obj arg action type throw new illeg argument except string valu of id 
privat static nativ string real thi scriptabl thi obj id function object f if thi obj instanceof nativ string throw incompat call error f return nativ string thi obj 
privat static string tagifi object thi obj string tag string attribut object arg string str script runtim to string thi obj string buffer result new string buffer result append result append tag if attribut null result append result append attribut result append result append script runtim to string arg 0 result append result append result append str result append result append tag result append return result to string 
public string to string return string 
public object get int index scriptabl start if 0 index index string length return string substr index index 1 return super get index start 
public void put int index scriptabl start object valu if 0 index index string length return super put index start valu 
privat static int js index of string target object arg string search script runtim to string arg 0 doubl begin script runtim to integ arg 1 if begin target length return 1 els if begin 0 begin 0 return target index of search int begin 
privat static int js last index of string target object arg string search script runtim to string arg 0 doubl end script runtim to number arg 1 if end end end target length end target length els if end 0 end 0 return target last index of search int end 
privat static int find split context cx scriptabl scope string target string separ int version reg exp proxi re proxi scriptabl re int ip int matchlen boolean match string parensp int i ip 0 int length target length perl4 special case for str split onli if the user ha select java script1 2 explicitli split on whitespac and skip lead w s strang but true appar model after awk if version context version 1 2 re null separ length 1 separ char at 0 skip lead whitespac if at front of str if i 0 while i length charact is whitespac target char at i i ip 0 i don t delimit whitespac at end of string if i length return 1 skip over the non whitespac char while i length charact is whitespac target char at i i now skip the next run of whitespac int j i while j length charact is whitespac target char at j j updat matchlen to count delimit char matchlen 0 j i return i stop if past end of string if at end of string we will return target length so that ab split new arrai ab and the result arrai convert back to the string ab for symmetri nb thi differ from perl which drop the trail empti substr if the limit argument is omit if i length return 1 match a regular express against the separ at or abov index i return 1 at end of string instead of try for a match so we don t get stuck in a loop if re null return re proxi find split cx scope target separ re ip matchlen match parensp deviat from ecma by never split an empti string by ani separ string into a non empti arrai an arrai of length 1 that contain the empti string if version context version default version context version 1 3 length 0 return 1 special case if sep is the empti string split str into on charact substr let our caller worri about whether to split onc at end of string into an empti substr for 1 2 compat at the end of the string we return the length as the result and set the separ length to 1 thi allow the caller to includ an addit null string at the end of the substr list if separ length 0 if version context version 1 2 if i length matchlen 0 1 return i return i 1 return i length 1 i 1 punt to j l s index of return target length if separ is not found if ip 0 length return length i target index of separ ip 0 return i 1 i length 
privat static object js split context cx scriptabl scope string target object arg creat an empti arrai to return scriptabl top get top level scope scope scriptabl result script runtim new object cx top arrai null return an arrai consist of the target if no separ given don t check against undefin becaus we want fooundefinedbar split void 0 to split to foo bar if arg length 1 result put 0 result target return result us the second argument as the split limit if given boolean limit arg length 1 arg 1 undefin instanc long limit 0 initi to avoid warn if limit clamp limit between 0 and 1 string length limit script runtim to uint32 arg 1 if limit target length limit 1 target length string separ null int matchlen new int 1 scriptabl re null reg exp proxi re proxi null if arg 0 instanceof scriptabl re proxi script runtim get reg exp proxi cx if re proxi null scriptabl test scriptabl arg 0 if re proxi is reg exp test re test if re null separ script runtim to string arg 0 matchlen 0 separ length split target with separ or re int ip 0 int match int len 0 boolean match fals string paren null int version cx get languag version while match find split cx scope target separ version re proxi re ip matchlen match paren 0 if limit len limit match target length break string substr if target length 0 substr target els substr target substr ip 0 match result put len result substr len imit perl s featur of includ parenthes substr that match part of the delimit in the new arrai after the split substr that wa delimit if re null match 0 true int size paren 0 length for int num 0 num size num if limit len limit break result put len result paren 0 num len match 0 fals ip 0 match matchlen 0 if version context version 1 3 version context version default deviat from ecma to imit perl which omit a final split unless a limit argument is given and big enough if limit ip 0 target length break return result 
privat static string js substr context cx string target object arg int length target length doubl start script runtim to integ arg 0 doubl end if start 0 start 0 els if start length start length if arg length 1 arg 1 undefin instanc end length els end script runtim to integ arg 1 if end 0 end 0 els if end length end length swap if end start if end start if cx get languag version context version 1 2 doubl temp start start end end temp els emul old jdk1 0 java lang string substr end start return target substr int start int end 
int get length return string length 
privat static string js substr string target object arg if arg length 1 return target doubl begin script runtim to integ arg 0 doubl end int length target length if begin 0 begin length if begin 0 begin 0 els if begin length begin length if arg length 1 end length els end script runtim to integ arg 1 if end 0 end 0 end begin if end length end length return target substr int begin int end 
privat static string js concat string target object arg int n arg length if n 0 return target els if n 1 string arg script runtim to string arg 0 return target concat arg find total capac for the final string to avoid unnecessari re alloc in string buffer int size target length string arg as string new string n for int i 0 i n i string s script runtim to string arg i arg as string i s size s length string buffer result new string buffer size result append target for int i 0 i n i result append arg as string i return result to string 
privat static string js slice string target object arg if arg length 0 doubl begin script runtim to integ arg 0 doubl end int length target length if begin 0 begin length if begin 0 begin 0 els if begin length begin length if arg length 1 end length els end script runtim to integ arg 1 if end 0 end length if end 0 end 0 els if end length end length if end begin end begin return target substr int begin int end return target 
protect int find prototyp id string s int id gener last updat 2004 03 17 13 44 29 cet l0 id 0 string x null int c l switch s length case 3 c s char at 2 if c b if s char at 0 s s char at 1 u id id sub break l0 els if c g if s char at 0 b s char at 1 i id id big break l0 els if c p if s char at 0 s s char at 1 u id id sup break l0 break l case 4 c s char at 0 if c b x bold id id bold els if c l x link id id link break l case 5 switch s char at 4 case d x fix id id fix break l case e x slice id id slice break l case h x match id id match break l case k x blink id id blink break l case l x small id id small break l case t x split id id split break l break l case 6 switch s char at 1 case e x search id id search break l case h x char at id id char at break l case n x anchor id id anchor break l case o x concat id id concat break l case q x equal id id equal break l case t x strike id id strike break l case u x substr id id substr break l break l case 7 switch s char at 1 case a x valu of id id valu of break l case e x replac id id replac break l case n x index of id id index of break l case t x ital id id ital break l break l case 8 c s char at 4 if c r x to string id id to string els if c s x fontsiz id id fontsiz els if c u x to sourc id id to sourc break l case 9 c s char at 0 if c f x fontcolor id id fontcolor els if c s x substr id id substr break l case 10 x char code at id id char code at break l case 11 switch s char at 2 case l x to lower case id id to lower case break l case u x to upper case id id to upper case break l case n x constructor id id constructor break l case s x last index of id id last index of break l break l case 16 x equal ignor case id id equal ignor case break l if x null x s x equal s id 0 gener return id 
class sub string public sub string 
public sub string string str index 0 char arrai str to char arrai length str length 
public sub string char sourc int start int len there must be a better wai of do thi index 0 length len char arrai new char len for int j 0 j len j char arrai j sourc start j 
public string to string return char arrai null new string char arrai index length 
public class slot 005 extend live connect test public slot 005 super 
super public static void main string arg slot 005 test new slot 005 test start 
public void execut test get base object object test matrix get data arrai for int i 0 i test matrix length i jsobject js object creat jsobject object test matrix i set slot js object i object test matrix i get slot js object i object test matrix i 
public jsobject creat jsobject object data return jsobject data 0 
get the constructor of all the base java script object the test will compar the instanc constructor to the base object constructor to verifi that the java script type of the object is corret public boolean get base object try js number jsobject global eval number prototyp constructor js string jsobject global eval string prototyp constructor js function jsobject global eval function prototyp constructor js boolean jsobject global eval boolean prototyp constructor js object jsobject global eval object prototyp constructor js math jsobject global eval math js date jsobject global eval date prototyp constructor js arrai jsobject global eval arrai prototyp constructor js reg exp jsobject global eval reg exp prototyp constructor catch except e system err println fail in get base object e to string e print stack trace return fals return true 
get the data arrai which is an arrai of arrai each of the intern arrai consist of three object a string whose valu will be pass to the java script arrai constructor a string which is the expect string valu of retreiv the jsobject via get slot and a jsobject which is the jsobject s constructor that allow us to verifi the type of jsobject return the data arrai public object get data arrai object item0 global eval new string pass global eval new string pass new string pass js string object item1 global eval new number 12345 global eval new number 98765 new string 98765 js number object item2 global eval new boolean fals global eval new boolean true new string true js boolean object item3 global eval new arrai 0 1 2 3 4 global eval new arrai h i new string h i js arrai object item4 global eval new object global eval new object new string object object js object object data arrai item0 item1 item2 item3 item4 return data arrai 
creat an empti java script arrai name js arrai return the jsobject arrai object public jsobject creat jsarrai jsobject js arrai null string arg var js arrai new arrai string result pass try system out println arg global eval arg js arrai jsobject global get member js arrai catch except e result fail except global get member js arrai threw e to string file except except e print stack trace final add test case global eval var js arrai new arrai jsobject js arrai jsobject global get member js arrai pass result except return js arrai 
us jsobject get member to get the length properti of a jsobject param js arrai a jsobject with a properti name length param java length the expect length of the jsobject public void get length jsobject js arrai int java length string except int js length 0 try js length doubl js arrai get member length int valu catch except e except js arrai get member length threw e to string file except except e print stack trace final add test case length is js length js arrai get member length int valu java length true js length java length except 
us jsobject get slot to get an index member of a jsobject in thi test the expect class of all object is jsobject param js arrai the jsobject with index member param slot the index properti to retriev param data object arrai contain the string represent of the expect result of js arrai get slot slot and the jsobjectconstructor of the expect result which allow us to verifi the valu and type of the result object public void get slot jsobject js arrai int slot object data string except jsobject constructor null jsobject result null class e class null class a class null try result jsobject js arrai get slot slot if result null e class class for name netscap javascript jsobject a class result get class constructor jsobject result get member constructor catch except e except js arrai get slot slot threw e to string file except except e print stack trace final if result null add test case js arrai get slot slot to string trim return result data 1 equal result true data 1 to string trim equal result to string except els check the string valu of the result add test case js arrai get slot slot return result data 2 to string equal result true data 2 equal result to string except check the class of the result all should be jsobject add test case e class equal a class true e class equal a class except check the constructor of the result add test case constructor equal data 3 true constructor equal data 3 except 
jsobject set slot return undefin thi just verifi that we can call set slot without throw an except param js arrai the jsobject on which set slot will be call param slot the index member that will be set param java valu the valu to set the index member public void set slot jsobject js arrai int slot object data string except null string result pass try js arrai set slot slot object data 1 catch except e result fail except js arrai set slot slot data 1 threw e to string file except except e print stack trace final add test case js arrai set slot slot data 1 pass result except 
public string jsobject jsobject public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string ambigu float arg return float 
public string ambigu doubl arg return doubl 
creat a scriptabl input stream param in the input stream to read from param scope the top level scope to creat the object in public scriptabl input stream input stream in scriptabl scope throw ioexcept super in thi scope scope enabl resolv object true context cx context get current context if cx null thi class loader cx get applic class loader 
protect class resolv class object stream class desc throw ioexcept class not found except string name desc get name if class loader null try return class loader load class name catch class not found except ex fall through to default load return super resolv class desc 
protect object resolv object object obj throw ioexcept if obj instanceof scriptabl output stream pend lookup string name scriptabl output stream pend lookup obj get name obj scriptabl output stream lookup qualifi name scope name if obj scriptabl not found throw new ioexcept object name not found upon deseri els if obj instanceof uniqu tag obj uniqu tag obj read resolv els if obj instanceof undefin obj undefin obj read resolv return obj 
set the gui callback object to us public void set gui callback gui callback callback thi callback callback 
tell the debugg to break at the next opportun public void set break thi break flag true 
set the scope provid to be us public void set scope provid scope provid scope provid thi scope provid scope provid 
switch context to the stack frame with the given index public void context switch int frame index thi frame index frame index 
set whether the debugg should break on except public void set break on except boolean break on except thi break on except break on except 
set whether the debugg should break on function enter public void set break on enter boolean break on enter thi break on enter break on enter 
set whether the debugg should break on function return public void set break on return boolean break on return thi break on return break on return 
attach the debugg to the given context factori public void attach to context factori factori detach thi context factori factori thi listen new dim iproxi thi iproxi listen factori add listen thi listen 
detach the debugg from the current context factori public void detach if listen null context factori remov listen listen context factori null listen null 
releas resourc associ with thi debugg public void dispos detach 
return the function sourc object for the given script or function privat function sourc get function sourc debugg script fn or script function sourc fsourc function sourc fn or script if fsourc null string url get normal url fn or script sourc info si sourc info url if si null if fn or script is gener script not eval or function try to load it from url string sourc load sourc url if sourc null debugg script top fn or script for debugg script parent top get parent if parent null break top parent regist top script top sourc fsourc function sourc fn or script return fsourc 
load the script at the given url privat string load sourc string sourc url string sourc null int hash sourc url index of if hash 0 sourc url sourc url substr 0 hash try input stream is open stream if sourc url index of 0 can be a file name try if sourc url start with string home system get properti user home if home null string path from home sourc url substr 2 file f new file new file home path from home if f exist is new file input stream f break open stream file f new file sourc url if f exist is new file input stream f break open stream catch secur except ex no exist file assum miss http if sourc url start with sourc url http sourc url els if sourc url start with sourc url http 127 0 0 1 sourc url els sourc url http sourc url is new url sourc url open stream try sourc kit read reader new input stream reader is final is close catch ioexcept ex system err println fail to load sourc from sourc url ex return sourc 
regist the given script as a top level script in the debugg privat void regist top script debugg script top script string sourc if top script is top level throw new illeg argument except string url get normal url top script debugg script function get all function top script final sourc info sourc info new sourc info sourc function url synchron url to sourc info sourc info old sourc info url to sourc info get url if old null sourc info copi breakpoint from old url to sourc info put url sourc info for int i 0 i sourc info function sourc top i function sourc fsourc sourc info function sourc i string name fsourc name if name length 0 function name put name fsourc synchron function to sourc for int i 0 i function length i function sourc fsourc sourc info function sourc i function to sourc put function i fsourc callback updat sourc text sourc info 
return the function sourc object for the given function or script privat function sourc function sourc debugg script fn or script return function sourc function to sourc get fn or script 
return an arrai of all function name public string function name string a synchron url to sourc info enumer e function name kei a new string function name size int i 0 while e ha more element a i string e next element return a 
return the function sourc object for the function with the given name public function sourc function sourc by name string function name return function sourc function name get function name 
return the sourc info object for the given url public sourc info sourc info string url return sourc info url to sourc info get url 
return the sourc url for the given script or function privat string get normal url debugg script fn or script string url fn or script get sourc name if url null url stdin els not to produc window for eval from differ line strip line number i e replac all 0 9 eval by eval option similar teatment for function char eval separ string buffer sb null int url length url length int cursor 0 for int search start url index of eval separ cursor if search start 0 break string replac null int i search start 1 boolean ha digit fals while i url length int c url char at i if 0 c c 9 break i if i search start 1 i point after 0 9 if eval region match 0 url i 6 cursor i 6 replac eval if replac null break if sb null sb new string buffer sb append url substr 0 search start sb append replac if sb null if cursor url length sb append url substr cursor url sb to string return url 
return an arrai of all function in the given script privat static debugg script get all function debugg script function obj arrai function new obj arrai collect function r function function debugg script result new debugg script function size function to arrai result return result 
helper function for link get all function debugg script privat static void collect function r debugg script function obj arrai arrai arrai add function for int i 0 i function get function count i collect function r function get function i arrai 
clear all breakpoint public void clear all breakpoint enumer e url to sourc info element while e ha more element sourc info si sourc info e next element si remov all breakpoint 
call when a breakpoint ha been hit privat void handl breakpoint hit stack frame frame context cx break flag fals interrupt cx frame null 
call when a script except ha been thrown privat void handl except thrown context cx throwabl ex stack frame frame if break on except context data cd frame context data if cd last process except ex interrupt cx frame ex cd last process except ex 
return the current context data object public context data current context data return interrupt context data 
set the action to perform to end interrupt public void set return valu int return valu synchron monitor thi return valu return valu monitor notifi 
resum execut of script public void go synchron monitor thi return valu go monitor notifi all 
evalu the given script public string eval string expr string result undefin if expr null return result context data context data current context data if context data null frame index context data frame count return result stack frame frame context data get frame frame index if context data event thread flag context cx context get current context result do eval cx frame expr els synchron monitor if insid interrupt loop eval request expr eval frame frame monitor notifi do try monitor wait catch interrupt except exc thread current thread interrupt break while eval request null result eval result return result 
compil the given script public void compil script string url string text dim iproxi action new dim iproxi thi iproxi compil script action url url action text text action with context 
evalu the given script public void eval script final string url final string text dim iproxi action new dim iproxi thi iproxi eval script action url url action text text action with context 
convert the given script object to a string public string object to string object object dim iproxi action new dim iproxi thi iproxi object to string action object object action with context return action string result 
return whether the given string is syntact valid script public boolean string is compil unit string str dim iproxi action new dim iproxi thi iproxi string is compil action text str action with context return action boolean result 
return the valu of a properti on the given script object public object get object properti object object object id dim iproxi action new dim iproxi thi iproxi object properti action object object action id id action with context return action object result 
return an arrai of the properti name on the given script object public object get object id object object dim iproxi action new dim iproxi thi iproxi object id action object object action with context return action object arrai result 
return the valu of a properti on the given script object privat object get object properti impl context cx object object object id scriptabl scriptabl scriptabl object object result if id instanceof string string name string id if name equal thi result scriptabl els if name equal proto result scriptabl get prototyp els if name equal parent result scriptabl get parent scope els result scriptabl object get properti scriptabl name if result scriptabl object not found result undefin instanc els int index integ id int valu result scriptabl object get properti scriptabl index if result scriptabl object not found result undefin instanc return result 
return an arrai of the properti name on the given script object privat object get object id impl context cx object object if object instanceof scriptabl object undefin instanc return context empti arg object id scriptabl scriptabl scriptabl object if scriptabl instanceof debugg object id debugg object scriptabl get all id els id scriptabl get id scriptabl proto scriptabl get prototyp scriptabl parent scriptabl get parent scope int extra 0 if proto null extra if parent null extra if extra 0 object tmp new object extra id length system arraycopi id 0 tmp extra id length id tmp extra 0 if proto null id extra proto if parent null id extra parent return id 
interrupt script execut privat void interrupt context cx final stack frame frame throwabl script except context data context data frame context data int line frame get line number string url frame get url boolean event thread flag callback is gui event thread context data event thread flag event thread flag boolean recurs event thread call fals interrupt check synchron event thread monitor if event thread flag if interrupt context data null recurs event thread call true break interrupt check els while interrupt context data null try event thread monitor wait catch interrupt except exc return interrupt context data context data if recurs event thread call xxx for now the follow is comment out as on linux too deep recurs of dispatch next gui event caus gui lockout note it can make gui unrespons if long run script will be call on gui thread while process anoth interrupt if fals run event dispatch until gui set a flag to exit the initi call to interrupt while thi return valu 1 try callback dispatch next gui event catch interrupt except exc return if interrupt context data null kit code bug try do int frame count context data frame count thi frame index frame count 1 final string thread titl thread current thread to string final string alert messag if script except null alert messag null els alert messag script except to string int return valu 1 if event thread flag synchron monitor if insid interrupt loop kit code bug thi insid interrupt loop true thi eval request null thi return valu 1 callback enter interrupt frame thread titl alert messag try for try monitor wait catch interrupt except exc thread current thread interrupt break if eval request null thi eval result null try eval result do eval cx eval frame eval request final eval request null eval frame null monitor notifi continu if thi return valu 1 return valu thi return valu break final insid interrupt loop fals els thi return valu 1 callback enter interrupt frame thread titl alert messag while thi return valu 1 try callback dispatch next gui event catch interrupt except exc return valu thi return valu switch return valu case step over context data break next line true context data stop at frame depth context data frame count break case step into context data break next line true context data stop at frame depth 1 break case step out if context data frame count 1 context data break next line true context data stop at frame depth context data frame count 1 break while fals final synchron event thread monitor interrupt context data null event thread monitor notifi all 
evalu script in the given stack frame privat static string do eval context cx stack frame frame string expr string result string debugg save debugg cx get debugg object save data cx get debugg context data int save level cx get optim level cx set debugg null null cx set optim level 1 cx set gener debug fals try callabl script callabl cx compil string expr 0 null object result script call cx frame scope frame thi obj script runtim empti arg if result undefin instanc result string els result string script runtim to string result catch except exc result string exc get messag final cx set gener debug true cx set optim level save level cx set debugg save debugg save data if result string null result string null return result string 
creat a new dim iproxi privat dim iproxi dim dim int type thi dim dim thi type type 
perform the action given by link type public object run context cx switch type case iproxi compil script cx compil string text url 1 null break case iproxi eval script scriptabl scope null if dim scope provid null scope dim scope provid get scope if scope null scope new import top level cx cx evalu string scope text url 1 null break case iproxi string is compil boolean result cx string is compil unit text break case iproxi object to string if object undefin instanc string result undefin els if object null string result null els if object instanceof nativ call string result object call els string result context to string object break case iproxi object properti object result dim get object properti impl cx object id break case iproxi object id object arrai result dim get object id impl cx object break default throw kit code bug return null 
perform the action given by link type with the attach link context factori privat void with context dim context factori call thi 
call when a context is creat public void context creat context cx if type iproxi listen kit code bug context data context data new context data debugg debugg new dim iproxi dim iproxi debug cx set debugg debugg context data cx set gener debug true cx set optim level 1 
call when a context is destroi public void context releas context cx if type iproxi listen kit code bug 
return a stack frame for the given function or script public debug frame get frame context cx debugg script fn or script if type iproxi debug kit code bug function sourc item dim get function sourc fn or script if item null can not debug if sourc is not avail return null return new stack frame cx dim item 
call when compil is finish public void handl compil done context cx debugg script fn or script string sourc if type iproxi debug kit code bug if fn or script is top level return dim regist top script fn or script sourc 
return the context data for the given context public static context data get context cx return context data cx get debugg context data 
return the number of stack frame public int frame count return frame stack size 
return the stack frame with the given index public stack frame get frame int frame number int num frame stack size frame number 1 return stack frame frame stack get num 
push a stack frame on to the stack privat void push frame stack frame frame frame stack push frame 
pop a stack frame from the stack privat void pop frame frame stack pop 
creat a new stack frame privat stack frame context cx dim dim function sourc fsourc thi dim dim thi context data context data get cx thi fsourc fsourc thi breakpoint fsourc sourc info breakpoint thi line number fsourc first line 
call when the stack frame is enter public void on enter context cx scriptabl scope scriptabl thi obj object arg context data push frame thi thi scope scope thi thi obj thi obj if dim break on enter dim handl breakpoint hit thi cx 
call when the current posit ha chang public void on line chang context cx int lineno thi line number lineno if breakpoint lineno dim break flag boolean line break context data break next line if line break context data stop at frame depth 0 line break context data frame count context data stop at frame depth if line break return context data stop at frame depth 1 context data break next line fals dim handl breakpoint hit thi cx 
call when an except ha been thrown public void on except thrown context cx throwabl except dim handl except thrown cx except thi 
call when the stack frame ha been left public void on exit context cx boolean by throw object result or except if dim break on return by throw dim handl breakpoint hit thi cx context data pop frame 
return the sourc info object for the function public sourc info sourc info return fsourc sourc info 
return the context data object for the context public context data context data return context data 
return the scope object for thi frame public object scope return scope 
return the thi object for thi frame public object thi obj return thi obj 
return the sourc url public string get url return fsourc sourc info url 
return the current line number public int get line number return line number 
creat a new function sourc privat function sourc sourc info sourc info int first line string name if name null throw new illeg argument except thi sourc info sourc info thi first line first line thi name name 
return the sourc info object that describ the sourc of the function public sourc info sourc info return sourc info 
return the line number of the first line of the function public int first line return first line 
return the name of the function public string name return name 
creat a new sourc info object privat sourc info string sourc debugg script function string normil url thi sourc sourc thi url normil url int n function length int line arrai new int n for int i 0 i n i line arrai i function i get line number int min all 0 max all 1 int first line new int n for int i 0 i n i int line line arrai i if line null line length 0 first line i 1 els int min max min max line 0 for int j 1 j line length j int line line j if line min min line els if line max max line first line i min if min all max all min all min max all max els if min min all min all min if max max all max all max if min all max all no line inform thi min line 1 thi breakabl line empti boolean arrai thi breakpoint empti boolean arrai els if min all 0 line number can not be neg throw new illeg state except string valu of min all thi min line min all int line top max all 1 thi breakabl line new boolean line top thi breakpoint new boolean line top for int i 0 i n i int line line arrai i if line null line length 0 for int j 0 j line length j int line line j thi breakabl line line true thi function sourc new function sourc n for int i 0 i n i string name function i get function name if name null name thi function sourc i new function sourc thi first line i name 
return the sourc text public string sourc return thi sourc 
return the script s origin url public string url return thi url 
return the number of function sourc object store in thi object public int function sourc top return function sourc length 
return the function sourc object with the given index public function sourc function sourc int i return function sourc i 
copi the breakpoint from the given sourc info object into thi on privat void copi breakpoint from sourc info old int end old breakpoint length if end thi breakpoint length end thi breakpoint length for int line 0 line end line if old breakpoint line thi breakpoint line true 
return whether the given line number can have a breakpoint set on it public boolean breakabl line int line return line thi breakabl line length thi breakabl line line 
return whether there is a breakpoint set on the given line public boolean breakpoint int line if breakabl line line throw new illeg argument except string valu of line return line thi breakpoint length thi breakpoint line 
set or clear the breakpoint flag for the given line public boolean breakpoint int line boolean valu if breakabl line line throw new illeg argument except string valu of line boolean chang synchron breakpoint if breakpoint line valu breakpoint line valu chang true els chang fals return chang 
remov all breakpoint from the script public void remov all breakpoint synchron breakpoint for int line 0 line breakpoint length line breakpoint line fals 
the zero paramet constructor when context defin class is call with thi class it will construct file prototyp us thi constructor public file 
the java method defin the java script file constructor if the constructor ha on or more argument and the first argument is not undefin the argument is convert to a string as us as the filenam p otherwis system in or system out is assum as appropri to the us public static scriptabl js constructor context cx object arg function ctor obj boolean in new expr file result new file if arg length 0 arg 0 context get undefin valu result name result file null els result name context to string arg 0 result file new java io file result name return result 
return the name of thi java script class file public string get class name return file 
get the name of the file us to defin the name properti public string js get name return name 
read the remain line in the file and return them in an arrai implement a java script function p thi is a good exampl of creat a new arrai and set element in that arrai except ioexcept if an error occur while access the file associ with thi object public object js function read line throw ioexcept vector v new vector string s while s js function read line null v add element s object line new object v size v copi into line scriptabl scope scriptabl object get top level scope thi context cx context get current context return cx new object scope arrai line 
read a line implement a java script function except ioexcept if an error occur while access the file associ with thi object or eofexcept if the object reach the end of the file public string js function read line throw ioexcept return get reader read line 
read a charact except ioexcept if an error occur while access the file associ with thi object or eofexcept if the object reach the end of the file public string js function read char throw ioexcept int i get reader read if i 1 return null char char arrai char i return new string char arrai 
write string implement a java script function p thi function take a variabl number of argument convert each argument to a string and write that string to the file except ioexcept if an error occur while access the file associ with thi object public static void js function write context cx scriptabl thi obj object arg function fun obj throw ioexcept write0 thi obj arg fals 
write string and a newlin implement a java script function except ioexcept if an error occur while access the file associ with thi object public static void js function write line context cx scriptabl thi obj object arg function fun obj throw ioexcept write0 thi obj arg true 
public int js get line number throw file not found except return get reader get line number 
close the file it mai be reopen implement a java script function except ioexcept if an error occur while access the file associ with thi object public void js function close throw ioexcept if reader null reader close reader null els if writer null writer close writer null 
final close the file when thi object is collect public void final try js function close catch ioexcept e 
get the java reader public object js function get reader if reader null return null here we us to object to wrap the buffer reader object in a scriptabl object so that it can be manipul by java script scriptabl parent scriptabl object get top level scope thi return context java to js reader parent 
get the java writer see file js function get reader public object js function get writer if writer null return null scriptabl parent scriptabl object get top level scope thi return context java to js writer parent 
get the reader check that we re not alreadi write thi file privat line number reader get reader throw file not found except if writer null throw context report runtim error alreadi write file name if reader null reader new line number reader file null new input stream reader system in new file reader file return reader 
perform the gut of write and write line sinc the two function differ onli in whether thei write a newlin charact move the code into a common subroutin privat static void write0 scriptabl thi obj object arg boolean eol throw ioexcept file thi file check instanc thi obj if thi file reader null throw context report runtim error alreadi write file thi file name if thi file writer null thi file writer new buffer writer thi file file null new output stream writer system out new file writer thi file file for int i 0 i arg length i string s context to string arg i thi file writer write s 0 s length if eol thi file writer new line 
perform the instanceof check and return the downcast file object thi is necessari sinc method mai resid in the file prototyp object and script can dynam alter prototyp chain for exampl pre js defin class file js o object object js o proto file prototyp object file js o write hi js call on incompat object pre the runtim will take care of such check when non static java method ar defin as java script function privat static file check instanc scriptabl obj if obj null obj instanceof file throw context report runtim error call on incompat object return file obj 
static void init scriptabl scope boolean seal nativ with obj new nativ with obj set parent scope scope obj set prototyp scriptabl object get object prototyp scope id function object ctor new id function object obj ftag id constructor with 0 scope ctor mark as constructor obj if seal ctor seal object ctor export as scope properti 
privat nativ with 
protect nativ with scriptabl parent scriptabl prototyp thi parent parent thi prototyp prototyp 
public string get class name return with 
public boolean ha string id scriptabl start return prototyp ha id prototyp 
public boolean ha int index scriptabl start return prototyp ha index prototyp 
public object get string id scriptabl start if start thi start prototyp return prototyp get id start 
public object get int index scriptabl start if start thi start prototyp return prototyp get index start 
public void put string id scriptabl start object valu if start thi start prototyp prototyp put id start valu 
public void put int index scriptabl start object valu if start thi start prototyp prototyp put index start valu 
public void delet string id prototyp delet id 
public void delet int index prototyp delet index 
public scriptabl get prototyp return prototyp 
public void set prototyp scriptabl prototyp thi prototyp prototyp 
public scriptabl get parent scope return parent 
public void set parent scope scriptabl parent thi parent parent 
public object get id return prototyp get id 
public object get default valu class type hint return prototyp get default valu type hint 
public boolean ha instanc scriptabl valu return prototyp ha instanc valu 
must return null to continu loop or the final collect result protect object updat dot queri boolean valu nativ with itself doe not support it throw new illeg state except 
public object exec id call id function object f context cx scriptabl scope scriptabl thi obj object arg if f ha tag ftag if f method id id constructor throw context report runtim error1 msg cant call indirect with throw f unknown 
static boolean is with function object function obj if function obj instanceof id function object id function object f id function object function obj return f ha tag ftag f method id id constructor return fals 
static object new with special context cx scriptabl scope object arg script runtim check deprec cx with scope scriptabl object get top level scope scope nativ with thi obj new nativ with thi obj set prototyp arg length 0 scriptabl object get class prototyp scope object script runtim to object cx scope arg 0 thi obj set parent scope scope return thi obj 
public final void init script function context cx scriptabl scope script runtim set function proto and parent thi scope 
param indent how much to indent the decompil result param flag flag specifi format of decompil output final string decompil int indent int flag string encod sourc get encod sourc if encod sourc null return super decompil indent flag els uint map properti new uint map 1 properti put decompil initi indent prop indent return decompil decompil encod sourc flag properti 
public int get length int param count get param count if get languag version context version 1 2 return param count context cx context get context nativ call activ script runtim find function activ cx thi if activ null return param count return activ origin arg length 
public int get ariti return get param count 
deprec us link base function get function name instead for backward compat keep an old method name us by batik and possibl other public string js get name return get function name 
get encod sourc string public string get encod sourc return null 
public debugg script get debugg view return null 
protect abstract int get languag version 
protect abstract int get languag version get number of declar paramet it should be 0 for script protect abstract int get param count 
get number of declar paramet and variabl defin through var statement 
get paramet or variabl name if tt index link get param count tt then return the name of the correspond paramet otherwis returm the name of variabl 
public int float 512 public int ambigu doubl arg return doubl 
public int ambigu float arg return float 
privat final int tag id privat uniqu tag int tag id thi tag id tag id 
public object read resolv switch tag id case id not found return not found case id null valu return null valu case id doubl mark return doubl mark throw new illeg state except string valu of tag id 
overridden for better debug printout public string to string string name switch tag id case id not found name not found break case id null valu name null valu break case id doubl mark name doubl mark break default throw kit code bug return super to string name 
param f rhino file that will be execut in thi rhino env param s the rhino file s test suit param d the rhino drv applet that creat thi rhino env public rhino env test file f test suit s test driver d thi file f thi suit s thi driver d 
creat the java script context which evalu the content of a rhino file and return a result the rhino env pars the test result and set valu of the rhino file test result properti see com netscap javascript context set optim level see com netscap javascript context set debug level public synchron void run test thi driver p file name try cx creat context context cx set optim level driver opt level context cx set debug level driver debug level object load fn execut test file driver helper function get absolut path file start time driver get current time result execut test file file file path file end time driver get current time pars result catch except e suit pass fals file pass fals file except file fail with except e 
creat a new com netscap javascript context return the newli instanti context public object creat context thi is stolen from main java cx new context context cx enter global new global context cx init standard object global string name print quit version load help load class try global defin function properti name main class scriptabl object dontenum catch properti except e throw new error e get messag return cx 
return cx public object execut test file return null 
given a filenam evalu the file s content as a java script program return the valu of the program if the test throw a java except or java script runtim or compil error return the string valu of the error messag param s full path to the file that will be exectu return test result object if the test is posit result should be an instanc of scriptabl if the test is neg the result should be a string whose valu is the messag in the java script error or java except public object execut test file string s thi bit is stolen from main java file reader in null try in new file reader s catch file not found except ex driver p couldn t open file s object result null try here we evalut the entir content of the file as as script text is print onli if the print function is call cx evalu reader scriptabl global in arg i 1 null result scriptabl context cx evalu reader scriptabl global reader in s 1 null catch wrap except we driver p wrap except we get wrap except to string result we get wrap except to string catch except jse driver p java script except jse get messag result jse get messag return result 
evalu the rhino file result if the result is an instanc of javax javascript scriptabl assum it is a java script arrai of test case object as describ in rhino drv java for each test case in the arrai add an element to the rhino file s test case vector if all test case pass set the rhino file s pass valu to true els set it pass valu to fals p if the result is not a scriptabl object the test fail set the the rhino file s except properti to the string valu of the result howev neg test which should have a n js extens ar expect to fail public boolean pars result flatten object fo null if result instanceof scriptabl fo new flatten object scriptabl result try file total case number fo get properti length int valu for int i 0 i file total case i scriptabl tc scriptabl scriptabl result get i scriptabl result test case rt new test case get string tc get pass tc get string tc get name tc get string tc get descript tc get string tc get expect tc get string tc get actual tc get string tc get reason tc file bugnumb get string tc get bugnumb tc start with com netscap javascript file bugnumb get string tc get bugnumb tc file case vector add element rt if rt pass equal fals thi file pass fals thi suit pass fals if file total case 0 if file name end with n js thi file pass true els thi file reason file contain no testcas thi file reason thi file pass fals thi suit pass fals catch except e thi file except got a scriptabl result but fail pars it argument except e to string flatten object is fo to string thi file pass fals thi suit pass fals return fals els if it s not a scriptabl object test fail set the file s except to the string valu of whatev result we did get thi file except result to string if the file s name end in n the test expect an error if file name end with n js thi file pass true els thi file pass fals thi suit pass fals return fals return true 
close the context public void close try context cx exit catch except e suit pass fals file pass fals file except file fail with except e 
get the java script string associ with a java script object param object a java identifi for a java script object return the java script string represent of the object public string get string object object return context cx to string object 
public string float float public string ambigu boolean arg return boolean object 
public string ambigu boolean arg return boolean 
public string ambigu object arg return object 
public string ambigu string arg return string 
public string ambigu byte arg return byte 
public string ambigu char arg return char 
public string ambigu short arg return short 
public string ambigu int arg return int 
public string ambigu long arg return long 
public string expect return long 
privat int tag valu end privat static boolean is valu type int id if id string tag return true return fals 
privat static string tag name int id switch id case switch tag return switch tag str case switch tag return switch tag str case gener tag return gener tag str case gener tag return gener tag str return 
void process file string file path throw ioexcept sourc file file path bodi new file bodi input stream is if file path equal is system in els is new file input stream file path try reader r new input stream reader is ascii bodi read data r final is close process file if bodi wa modifi output stream os if file path equal os system out els os new file output stream file path try writer w new output stream writer os bodi write data w w flush final os close 
privat void process file throw ioexcept int cur state 0 char buffer bodi get buffer int gener begin 1 gener end 1 int time stamp begin 1 time stamp end 1 bodi start line loop l while bodi next line int begin bodi get line begin int end bodi get line end int tag id extract line tag id buffer begin end boolean bad tag fals switch cur state case 0 if tag id switch tag cur state switch tag all pair remov all element gener begin 1 els if tag id switch tag bad tag true break case switch tag if tag id 0 look for id definit buffer begin end fals els if tag id string tag look for id definit buffer begin end true els if tag id gener tag if gener begin 0 bad tag true els cur state gener tag time stamp begin tag definit end time stamp end end els if tag id switch tag cur state 0 if gener begin 0 all pair is empti gener java code string code p to string boolean differ bodi set replac gener begin gener end code if differ string stamp get time stamp bodi set replac time stamp begin time stamp end stamp break els bad tag true break case gener tag if tag id 0 if gener begin 0 gener begin begin els if tag id gener tag if gener begin 0 gener begin begin cur state switch tag gener end begin els bad tag true break if bad tag string text tool error report get messag msg idswitch bad tag order tag name tag id throw r runtim error text sourc file bodi get line number null 0 if cur state 0 string text tool error report get messag msg idswitch file end in switch tag name cur state throw r runtim error text sourc file bodi get line number null 0 
privat string get time stamp simpl date format f new simpl date format last updat yyyi mm dd hh mm ss z string date string f format new date return f format new date 
privat void gener java code p clear id valu pair pair new id valu pair all pair size all pair copi into pair switch gener g new switch gener g char tail test threshold 2 g set report r g set code printer p g gener switch pair 0 
privat int extract line tag id char arrai int cursor int end int id 0 cursor skip white space arrai cursor end int after lead white space cursor cursor look for slash slash arrai cursor end if cursor end boolean at line start after lead white space 2 cursor cursor skip white space arrai cursor end if cursor end arrai cursor cursor boolean end tag fals if cursor end arrai cursor cursor end tag true int tag start cursor for cursor end cursor int c arrai cursor if c c is white space c break if cursor end int tag end cursor cursor skip white space arrai cursor end if cursor end int c arrai cursor if c c id get tag id arrai tag start tag end at line start if id 0 string bad null if c if end tag id id if is valu type id bad msg idswitch no end usag tag definit end cursor 1 els if end tag bad msg idswitch no end with valu els if is valu type id bad msg idswitch no valu allow id extract tag valu arrai cursor 1 end id if bad null string s tool error report get messag bad tag name id throw r runtim error s sourc file bodi get line number null 0 return id 
return posit after first of or end if not found privat int look for slash slash char arrai int cursor int end while cursor 2 end int c arrai cursor if c c arrai cursor if c return cursor return end 
privat int extract tag valu char arrai int cursor int end int id cursor point after alert implement support for quot string boolean found fals cursor skip white space arrai cursor end if cursor end int valu start cursor int valu end cursor while cursor end int c arrai cursor if is white space c int after space skip white space arrai cursor 1 end if after space end arrai after space valu end cursor cursor after space break cursor after space 1 els if c valu end cursor break els cursor if cursor end arrai cursor is here found true tag valu start valu start tag valu end valu end tag definit end cursor 1 return found id 0 
privat int get tag id char arrai int begin int end boolean at line start if at line start if equal switch tag str arrai begin end return switch tag if equal gener tag str arrai begin end return gener tag if equal string tag str arrai begin end return string tag return 0 
privat void look for id definit char arrai int begin int end boolean us tag valu as string look for the pattern t id a z a z0 9 t where 1 give field or method name int cursor begin skip tab and space at the begin cursor skip white space arrai cursor end int id start cursor int name start skip match prefix id arrai cursor end if name start 0 found id prefix cursor name start cursor skip name char arrai cursor end int name end cursor if name start name end cursor skip white space arrai cursor end if cursor end if arrai cursor int id end name end if us tag valu as string name start tag valu start name end tag valu end got the match add id arrai id start id end name start name end 
privat void add id char arrai int id start int id end int name start int name end string name new string arrai name start name end name start string valu new string arrai id start id end id start id valu pair pair new id valu pair name valu pair set line number bodi get line number all pair add element pair 
privat static boolean is white space int c return c c t 
privat static int skip white space char arrai int begin int end int cursor begin for cursor end cursor int c arrai cursor if is white space c break return cursor 
privat static int skip match prefix string prefix char arrai int begin int end int cursor 1 int prefix length prefix length if prefix length end begin cursor begin for int i 0 i prefix length i cursor if prefix char at i arrai cursor cursor 1 break return cursor 
privat static boolean equal string str char arrai int begin int end if str length end begin for int i begin j 0 i end i j if arrai i str char at j return fals return true return fals 
privat static int skip name char char arrai int begin int end int cursor begin for cursor end cursor int c arrai cursor if a c c z a c c z if 0 c c 9 if c break return cursor 
public static void main string arg main self new main int statu self exec arg system exit statu 
privat int exec string arg r new tool error report true system err int arg count process option arg if arg count 0 option error tool error report get messag msg idswitch no file argument return 1 if arg count 1 option error tool error report get messag msg idswitch too mani argument return 1 p new code printer p set indent step 4 p set indent tab size 0 try process file arg 0 catch ioexcept ex print error tool error report get messag msg idswitch io error ex to string return 1 catch evalu except ex return 1 return 0 
privat int process option string arg int statu 1 boolean show usag fals boolean show version fals int n arg length l for int i 0 i n i string arg arg i int arg length arg length if arg length 2 if arg char at 0 if arg char at 1 if arg length 2 arg i null break if arg equal help show usag true els if arg equal version show version true els option error tool error report get messag msg idswitch bad option arg statu 1 break l els for int j 1 j arg length j char c arg char at j switch c case h show usag true break default option error tool error report get messag msg idswitch bad option char string valu of c statu 1 break l arg i null if statu 1 if show usag show usag statu 0 if show version show version statu 0 if statu 1 system exit statu return remov null arg 
privat void show usag system out println tool error report get messag msg idswitch usag system out println 
privat void show version system out println tool error report get messag msg idswitch version 
privat void option error string str print error tool error report get messag msg idswitch bad invoc str 
privat void print error string text system err println text 
privat int remov null string arrai int n arrai length int cursor 0 for cursor n cursor if arrai cursor null break int destin cursor if cursor n cursor for cursor n cursor string elem arrai cursor if elem null arrai destin elem destin return destin 
nativ java method member box method thi function name method 0 get name thi method method 
nativ java method member box method string name thi function name name thi method new member box method 
public nativ java method method method string name thi new member box method name 
public string get function name return function name 
static string script signatur object valu string buffer sig new string buffer for int i 0 i valu length i object valu valu i string s if valu null s null els if valu instanceof boolean s boolean els if valu instanceof string s string els if valu instanceof number s number els if valu instanceof scriptabl if valu instanceof undefin s undefin els if valu instanceof wrapper object wrap wrapper valu unwrap s wrap get class get name els if valu instanceof function s function els s object els s java member java signatur valu get class if i 0 sig append sig append s return sig to string 
string decompil int indent int flag string buffer sb new string buffer boolean justbodi 0 flag decompil onli bodi flag if justbodi sb append function sb append get function name sb append sb append n sb append to string sb append justbodi n n return sb to string 
public string to string string buffer sb new string buffer for int i 0 n method length i n i method method method i method sb append java member java signatur method get return type sb append sb append method get name sb append java member live connect signatur method i arg type sb append n return sb to string 
public object call context cx scriptabl scope scriptabl thi obj object arg find a method that match the type given if method length 0 throw new runtim except no method defin for call int index find function cx method arg if index 0 class c method 0 method get declar class string sig c get name get function name script signatur arg throw context report runtim error1 msg java no such method sig member box meth method index class arg type meth arg type first we marshal the arg object orig arg arg for int i 0 i arg length i object arg arg i object coerc context js to java arg arg type i if coerc arg if orig arg arg arg object arg clone arg i coerc object java object if meth is static java object null don t need an object els scriptabl o thi obj class c meth get declar class for if o null throw context report runtim error3 msg nonjava method get function name script runtim to string thi obj c get name if o instanceof wrapper java object wrapper o unwrap if c is instanc java object break o o get prototyp if debug print debug call meth arg object retval meth invok java object arg class static type meth method get return type if debug class actual type retval null null retval get class system err println return retval actual actual type expect static type object wrap cx get wrap factori wrap cx scope retval static type if debug class actual type wrap null null wrap get class system err println wrap as wrap class actual type if wrap null static type void type wrap undefin instanc return wrap 
find the index of the correct function to call given the set of method or constructor and the argument if no function can be found to call return 1 static int find function context cx member box method or ctor object arg if method or ctor length 0 return 1 els if method or ctor length 1 member box member method or ctor 0 class arg type member arg type int alength arg type length if alength arg length return 1 for int j 0 j alength j if nativ java object can convert arg j arg type j if debug print debug reject arg can t convert member arg return 1 if debug print debug found member arg return 0 int first best fit 1 int extra best fit null int extra best fit count 0 search for int i 0 i method or ctor length i member box member method or ctor i class arg type member arg type if arg type length arg length continu search for int j 0 j arg type length j if nativ java object can convert arg j arg type j if debug print debug reject arg can t convert member arg continu search if first best fit 0 if debug print debug found first applic member arg first best fit i els compar with all current fit method the loop start from 1 denot first best fit and proce until extra best fit count to avoid extra best fit alloc in the most common case of no ambigu int better count 0 number of time member wa prefer over best fit int wors count 0 number of time best fit were prefer over member for int j 1 j extra best fit count j int best fit index if j 1 best fit index first best fit els best fit index extra best fit j member box best fit method or ctor best fit index int prefer prefer signatur arg arg type best fit arg type if prefer prefer ambigu break els if prefer prefer first arg better count els if prefer prefer second arg wors count els if prefer prefer equal kit code bug thi should not happen in theori but on some jvm class get method will return all static method of the class heirarchi even if a deriv class s paramet match exactli we want to call the dervi class s method if best fit is static best fit get declar class is assign from member get declar class on some jvm class get method will return all static method of the class heirarchi even if a deriv class s paramet match exactli we want to call the dervi class s method if debug print debug substitut overridden static member arg if j 1 first best fit i els extra best fit j i els if debug print debug ignor same signatur member member arg continu search if better count 1 extra best fit count member wa prefer over all best fit if debug print debug new first applic member arg first best fit i extra best fit count 0 els if wors count 1 extra best fit count all best fit were prefer over member ignor it if debug print debug reject all current best better member arg els some ambigu wa present add member to best fit set if debug print debug ad to best fit set member arg if extra best fit null alloc maximum possibl arrai extra best fit new int method or ctor length 1 extra best fit extra best fit count i extra best fit count if first best fit 0 noth wa found return 1 els if extra best fit count 0 singl best fit return first best fit report remain ambigu string buffer buf new string buffer for int j 1 j extra best fit count j int best fit index if j 1 best fit index first best fit els best fit index extra best fit j buf append n buf append method or ctor best fit index to java declar member box first fit member method or ctor first best fit string member name first fit member get name string member class first fit member get declar class get name if method or ctor 0 is method throw context report runtim error3 msg constructor ambigu member name script signatur arg buf to string els throw context report runtim error4 msg method ambigu member class member name script signatur arg buf to string 
determin which of two signatur is the closer fit return on of prefer equal prefer first arg prefer second arg or prefer ambigu privat static int prefer signatur object arg class sig1 class sig2 int total prefer 0 for int j 0 j arg length j class type1 sig1 j class type2 sig2 j if type1 type2 continu object arg arg j determin which of type1 type2 is easier to convert from arg int rank1 nativ java object get convers weight arg type1 int rank2 nativ java object get convers weight arg type2 int prefer if rank1 rank2 prefer prefer first arg els if rank1 rank2 prefer prefer second arg els equal rank if rank1 nativ java object convers nontrivi if type1 is assign from type2 prefer prefer second arg els if type2 is assign from type1 prefer prefer first arg els prefer prefer ambigu els prefer prefer ambigu total prefer prefer if total prefer prefer ambigu break return total prefer 
privat static void print debug string msg member box member object arg if debug string buffer sb new string buffer sb append sb append msg sb append member get declar class get name sb append if member is method sb append member get name sb append java member live connect signatur member arg type sb append for argument sb append script signatur arg sb append system out println sb 
public interfac quit action public void quit context cx int exit code 
public interfac scope provid return the scope object to be us for script evalu scriptabl get scope 
public interfac gui callback call when the sourc text of some script ha been chang void updat sourc text dim sourc info sourc info 
call when the interrupt loop ha been enter void enter interrupt dim stack frame last frame string thread titl 
return whether the current thread is the gui s event thread thi inform is requir to avoid block the event thread from the debugg 
process the next gui event thi manual pump of gui event is necessari when the gui event thread itself ha been stop 
return an arrai of id for the properti of the object p all properti even those with attribut dont enum ar list thi allow the debugg to displai all properti of the object p return an arrai of java lang object with an entri for everi list properti properti access via an integ index will have a correspond integ entri in the return arrai properti access by a string will have a string entri in the return arrai 
call when execut is readi to start bytecod interpret for enter a particular function or script param cx current context for thi thread param activ the activ scope for the function or script param thi obj valu of the java script code thi code object param arg the arrai of argument public void on enter context cx scriptabl activ 
scriptabl thi obj object arg call when execut code reach new line in the sourc param cx current context for thi thread param line number current line number in the script sourc 
call when thrown except is handl by the function or script param cx current context for thi thread param ex except object 
call when the function or script for thi frame is about to return param cx current context for thi thread param by throw if true function will leav by throw except otherwis it will execut normal return param result or except function result in case of normal return or except object if about to throw except 
call when compil of a particular function or script into intern bytecod is done param cx current context for thi thread param fn or script object describ the function or script param sourc the function or script sourc void handl compil done context cx debugg script fn or script 
call when execut enter a particular function or script return implement of debug frame which receiv debug inform dure the function or script execut or null otherwis 
public interfac debugg script public boolean is top level 
public boolean is top level return true if thi is a function fals if it is a script public boolean is function 
get name of the function describ by thi script return null or an empti string if thi script is not function 
get number of declar paramet in function return 0 if thi script is not function see get param and var count see get param or var name int index 
get number of declar paramet and local variabl return number of declar global variabl if thi script is not function see get param count see get param or var name int index 
get name of a declar paramet or local variabl tt index tt should be less then link get param and var count if tt index nbsp lt nbsp link get param count tt return the name of the correspond paramet otherwis return the name of variabl if thi script is not function return the name of the declar global variabl 
get the name of the sourc usual filenam or url of the script 
return true if thi script or function were runtim gener from java script us tt eval tt function or tt function tt or tt script tt constructor 
get arrai contain the line number that that can be pass to code debug frame on line chang code note that line order in the result arrai is arbitrari 
public int get line number public int get function count 
public int get function count public debugg script get function int index 
public debugg script get function int index public debugg script get parent 
perform the call param cx the current context for thi thread param scope the scope to us to resolv properti param thi obj the java script code thi code object param arg the arrai of argument return the result of the call public object call context cx scriptabl scope scriptabl thi obj 
deprec rhino runtim never call the method public void context enter context cx 
public void context enter context cx deprec rhino runtim never call the method public void context exit context cx 
call the function note that the arrai of argument is not guarante to have length greater than 0 param cx the current context for thi thread param scope the scope to execut the function rel to thi is set to the valu return by get parent scope except when the function is call from a closur param thi obj the java script code thi code object param arg the arrai of argument return the result of the call public object call context cx scriptabl scope scriptabl thi obj 
call the function as a constructor thi method is invok by the runtim in order to satisfi a us of the java script code new code oper thi method is expect to creat a new object and return it param cx the current context for thi thread param scope an enclos scope of the caller except when the function is call from a closur param arg the arrai of argument return the alloc object 
unwrap the object by return the wrap valu return a wrap valu 
return true iff the java class with the given name should be expos to script p an embed mai filter which java class ar expos through live connect to java script script p due to the fact that there is no packag reflect in java thi method will also be call with packag name there is no wai for rhino to tell if packag a b is a packag name or a class that doesn t exist what rhino doe is attempt to load each segment of packag a b c it first attempt to load class a then attempt to load class a b then final attempt to load class a b c on a rhino instal without ani class shutter set and without ani of the abov class the express packag a b c will result in a java packag a b c and not an error p with class shutter suppli rhino will first call visibl to script befor attempt to look up the class name if visibl to script return fals the class name lookup is not perform and subsequ rhino execut assum the class is not present so for java lang system out println the lookup of java lang system is skip and thu rhino assum that java lang system doesn t exist so then for java lang system out rhino attempt to load the class java lang system out becaus it assum that java lang system is a packag name p param full class name the full name of the class includ the packag name with as a delimit for exampl the standard string class is java lang string return whether or not to reveal thi class to script 
thi obj will be null if invok as constructor in which case instanc of scriptabl should be return public object exec id call id function object f context cx scriptabl scope 
get the name of the set of object implement by thi java class thi correspond to the class oper in ecma and is us by object prototyp to string in ecma p see ecma 8 6 2 and 15 2 4 2 
get a name properti from the object look properti up in thi object and return the associ valu if found return not found if not found note that thi method is not expect to travers the prototyp chain thi is differ from the ecma get oper depend on the properti selector the runtim will call thi method or the form of code get code that take an integ tabl tr th java script code th th java code th tr tr td a b td td a get b a td tr tr td a foo td td a get foo a td tr tr td a 3 td td a get 3 a td tr tr td a 3 td td a get 3 a td tr tr td a 3 0 td td a get 3 a td tr tr td a 3 0 td td a get 3 0 a td tr tr td a 1 1 td td a get 1 1 a td tr tr td a 4 td td a get 4 a td tr tabl p the valu that mai be return ar limit to the follow ul li java lang boolean object li li java lang string object li li java lang number object li li org mozilla javascript scriptabl object li li null li li the valu return by context get undefin valu li li not found li ul param name the name of the properti param start the object in which the lookup began return the valu of the properti mai be null or not found see org mozilla javascript context get undefin valu 
get a properti from the object select by an integr index ident to code get string scriptabl code except that an integr index is us to select the properti param index the numer index for the properti param start the object in which the lookup began return the valu of the properti mai be null or not found see org mozilla javascript scriptabl get string scriptabl 
indic whether or not a name properti is defin in an object doe not travers the prototyp chain p the properti is specifi by a string name as defin for the code get code method p param name the name of the properti param start the object in which the lookup began return true if and onli if the name properti is found in the object see org mozilla javascript scriptabl get see org mozilla javascript scriptabl object get properti 
indic whether or not an index properti is defin in an object doe not travers the prototyp chain p the properti is specifi by an integr index as defin for the code get code method p param index the numer index for the properti param start the object in which the lookup began return true if and onli if the index properti is found in the object see org mozilla javascript scriptabl get see org mozilla javascript scriptabl object get properti 
set a name properti in thi object p the properti is specifi by a string name as defin for code get code p the possibl valu that mai be pass in ar as defin for code get code a class that implement thi method mai choos to ignor call to set certain properti in which case those properti ar effect read onli p for properti defin in a prototyp chain us code put properti code in scriptabl object p note that if a properti i a i is defin in the prototyp i p i of an object i o i then evalu code o a 23 code will caus code set code to be call on the prototyp i p i with i o i as the i start i paramet to preserv java script semant it is the scriptabl object s respons to modifi i o i p thi design allow properti to be defin in prototyp and implement in term of getter and setter of java valu without consum slot in each instanc p p the valu that mai be set ar limit to the follow ul li java lang boolean object li li java lang string object li li java lang number object li li org mozilla javascript scriptabl object li li null li li the valu return by context get undefin valu li ul p arbitrari java object mai be wrap in a scriptabl by first call code context to object code thi allow the properti of a java script object to contain an arbitrari java object as a valu p note that code ha code will be call by the runtim first befor code set code is call to determin in which object the properti is defin note that thi method is not expect to travers the prototyp chain which is differ from the ecma put oper param name the name of the properti param start the object whose properti is be set param valu valu to set the properti to see org mozilla javascript scriptabl ha see org mozilla javascript scriptabl get see org mozilla javascript scriptabl object put properti see org mozilla javascript context to object 
set an index properti in thi object p the properti is specifi by an integr index as defin for code get code p ident to code put string scriptabl object code except that an integr index is us to select the properti param index the numer index for the properti param start the object whose properti is be set param valu valu to set the properti to see org mozilla javascript scriptabl ha see org mozilla javascript scriptabl get see org mozilla javascript scriptabl put string scriptabl object see org mozilla javascript scriptabl object put properti 
remov a properti from thi object thi oper correspond to the ecma delet except that the no result is return the runtim will guarante that thi method is call onli if the properti exist after thi method is call the runtim will call scriptabl ha to see if the properti ha been remov in order to determin the boolean result of the delet oper as defin by ecma 11 4 1 p a properti can be made perman by ignor call to remov it p the properti is specifi by a string name as defin for code get code p to delet properti defin in a prototyp chain see delet properti in scriptabl object param name the identifi for the properti see org mozilla javascript scriptabl get see org mozilla javascript scriptabl object delet properti 
remov a properti from thi object the properti is specifi by an integr index as defin for code get code p to delet properti defin in a prototyp chain see delet properti in scriptabl object ident to code delet string code except that an integr index is us to select the properti param index the numer index for the properti see org mozilla javascript scriptabl get see org mozilla javascript scriptabl object delet properti 
get the prototyp of the object return the prototyp 
set the prototyp of the object param prototyp the prototyp to set 
get the parent scope of the object return the parent scope 
set the parent scope of the object param parent the parent scope to set 
get an arrai of properti id not all properti id need be return those properti whose id ar not return ar consid non enumer return an arrai of object each entri in the arrai is either a java lang string or a java lang number 
get the default valu of the object with a given hint the hint ar string class for type string number class for type number scriptabl class for type object and boolean class for type boolean p a code hint code of null mean no hint see ecma 8 6 2 6 param hint the type hint return the default valu 
the instanceof oper p the java script code lh instanceof rh caus rh ha instanc lh to be call p the return valu is implement depend so that embed host object can return an appropri valu see the js 1 3 languag document for more detail p thi oper correspond to the propos emca ha instanc oper param instanc the valu that appear on the lh of the instanceof oper return an implement depend valu 
execut action us the suppli context instanc when rhino runtim call the method tt cx tt will be associ with the current thread as activ context see context call context action see context factori call context action 
public static final int ra search 3 public boolean is reg exp scriptabl obj 
public boolean is reg exp scriptabl obj public object compil reg exp context cx string sourc string flag 
public object compil reg exp context cx string sourc string flag public scriptabl wrap reg exp context cx scriptabl scope object compil 
object compil public object action context cx scriptabl scope scriptabl thi obj object arg int action type 
int action type public int find split context cx scriptabl scope string target string separ scriptabl re int ip int matchlen boolean match string parensp 
perform function call in refer context the arg arrai refer should not be store in ani object that is can be gc reachabl after thi method return if thi is necessari for exampl to implement link ref method then store arg clone not arg arrai itself param cx the current context for thi thread param thi obj the java script code thi code object param arg the arrai of argument 
execut the script p the script is execut in a particular runtim context which must be associ with the current thread the script is execut rel to a scope definit and us of global top level variabl and function will access properti of the scope object for compliant ecma program the scope must be an object that ha been initi as a global object us code context init standard object code p param cx the context associ with the current thread param scope the scope to execut rel to return the result of execut the script see org mozilla javascript context init standard object 
defin a new java class class creat via thi method should have the same class loader param name fulli qualifi class name param data class byte code return new class object 
link the given class param cl class instanc return from the previou call to link defin class string byte see java lang class loader resolv class class 
report a warn the implement class mai choos to ignor the warn if it desir param messag a string describ the warn param sourc name a string describ the java script sourc where the warn occur typic a filenam or url param line the line number associ with the warn param line sourc the text of the line mai be null param line offset the offset into line sourc where problem wa detect void warn string messag string sourc name int line 
report an error the implement class is free to throw an except if it desir if execut ha not yet begun the java script engin is free to find addit error rather than termin the translat it will not execut a script that had error howev param messag a string describ the error param sourc name a string describ the java script sourc where the error occur typic a filenam or url param line the line number associ with the error param line sourc the text of the line mai be null param line offset the offset into line sourc where problem wa detect void error string messag string sourc name int line 
public interfac test environ pass the java script program to the java script environ 
creat a new java script context in which to evalu a java script program return the java script context 
given a filenam evalu the file s content as a java script program return the return valu of the java script program if the test throw a java except or java script runtim or compil error return the string valu of the error messag 
evalu the result of the java script program attempt to get the java script arrai of test case object for each test case object found creat a com netscap javascript qa driver test case object and popul it field return true if the the result could be pars successfulli fals otherwis 
public boolean pars result close the context destroi the java script environ public void close 
